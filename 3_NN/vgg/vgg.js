// Generated by js_of_ocaml 3.0.1
(function(joo_global_object)
   {"use strict";
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function caml_str_repeat(n,s)
     {if(s.repeat)return s.repeat(n);
      var r="",l=0;
      if(n == 0)return r;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    function raw_array_sub(a,i,l)
     {var b=new Array(l);for(var j=0;j < l;j++)b[j] = a[i + j];return b}
    function caml_subarray_to_string(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,raw_array_sub(a,i,Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_string(s.c,0,s.c.length);
      s.t = 0}
    function caml_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return !/[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 128)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 128;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & -64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 224)
           {v = c - 12416;if(v < 128)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & -64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 240)
               {v = c - 925824;if(v < 2048 || v >= 55295 && v < 57344)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & -64)
                  ==
                  128
                  &&
                  c1
                  <
                  245)
                 {v = c2 - 63447168 + (c << 6);
                  if(v < 65536 || v > 1114111)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 65535)
          t += String.fromCharCode(55232 + (v >> 10),56320 + (v & 1023));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_to_js_string(s)
     {switch(s.t)
       {case 9:return s.c;
        default:caml_convert_string_to_bytes(s);case 0:
         if(caml_is_ascii(s.c)){s.t = 9;return s.c}s.t = 8;
        case 8:return caml_utf16_of_utf8(s.c)
        }}
    function MlString(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlString.prototype.toString = function(){return caml_to_js_string(this)};
    function caml_new_string(s){return new MlString(0,s,s.length)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_new_string(msg))}
    var caml_global_data=[0];
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_ba_blit(src,dst){dst.blit(src);return 0}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    var caml_ba_views;
    function caml_ba_init_views()
     {if(!caml_ba_views)
       {var g=joo_global_object;
        caml_ba_views
        =
        [[g.Float32Array,
          g.Float64Array,
          g.Int8Array,
          g.Uint8Array,
          g.Int16Array,
          g.Uint16Array,
          g.Int32Array,
          g.Int32Array,
          g.Int32Array,
          g.Int32Array,
          g.Float32Array,
          g.Float64Array,
          g.Uint8Array],
         [0,0,0,0,0,0,0,1,0,0,2,2,0]]}}
    function caml_js_from_array(a){return raw_array_sub(a,1,a.length - 1)}
    function caml_ba_create_from(data,data2,data_type,kind,layout,dims)
     {var n_dims=dims.length,size=caml_ba_get_size(dims);
      function offset_c(index)
       {var ofs=0;
        if(n_dims != index.length)
         caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
        for(var i=0;i < n_dims;i++)
         {if(index[i] < 0 || index[i] >= dims[i])caml_array_bound_error();
          ofs = ofs * dims[i] + index[i]}
        return ofs}
      function offset_fortran(index)
       {var ofs=0;
        if(n_dims != index.length)
         caml_invalid_argument("Bigarray.get/set: wrong number of indices");
        for(var i=n_dims - 1;i >= 0;i--)
         {if(index[i] < 1 || index[i] > dims[i])caml_array_bound_error();
          ofs = ofs * dims[i] + (index[i] - 1)}
        return ofs}
      var offset=layout == 0?offset_c:offset_fortran,dim0=dims[0];
      function get_std(index){var ofs=offset(index),v=data[ofs];return v}
      function get_int64(index)
       {var off=offset(index),l=data[off],h=data2[off];
        return [255,
                l & 16777215,
                l >>> 24 & 255 | (h & 65535) << 8,
                h >>> 16 & 65535]}
      function get_complex(index)
       {var off=offset(index),r=data[off],i=data2[off];return [254,r,i]}
      var get=data_type == 1?get_int64:data_type == 2?get_complex:get_std;
      function get1_c(i)
       {if(i < 0 || i >= dim0)caml_array_bound_error();return data[i]}
      function get1_fortran(i)
       {if(i < 1 || i > dim0)caml_array_bound_error();return data[i - 1]}
      function get1_any(i){return get([i])}
      var get1=data_type == 0?layout == 0?get1_c:get1_fortran:get1_any;
      function set_std_raw(off,v){data[off] = v}
      function set_int64_raw(off,v)
       {data[off] = v[1] | (v[2] & 255) << 24;
        data2[off] = v[2] >>> 8 & 65535 | v[3] << 16}
      function set_complex_raw(off,v){data[off] = v[1];data2[off] = v[2]}
      function set_std(index,v)
       {var ofs=offset(index);return set_std_raw(ofs,v)}
      function set_int64(index,v){return set_int64_raw(offset(index),v)}
      function set_complex(index,v){return set_complex_raw(offset(index),v)}
      var set=data_type == 1?set_int64:data_type == 2?set_complex:set_std;
      function set1_c(i,v)
       {if(i < 0 || i >= dim0)caml_array_bound_error();data[i] = v}
      function set1_fortran(i,v)
       {if(i < 1 || i > dim0)caml_array_bound_error();data[i - 1] = v}
      function set1_any(i,v){set([i],v)}
      var set1=data_type == 0?layout == 0?set1_c:set1_fortran:set1_any;
      function nth_dim(i)
       {if(i < 0 || i >= n_dims)caml_invalid_argument("Bigarray.dim");
        return dims[i]}
      function fill(v)
       {if(data_type == 0)for(var i=0;i < data.length;i++)set_std_raw(i,v);
        if(data_type == 1)for(var i=0;i < data.length;i++)set_int64_raw(i,v);
        if(data_type == 2)for(var i=0;i < data.length;i++)set_complex_raw(i,v)}
      function blit(from)
       {if(n_dims != from.num_dims)
         caml_invalid_argument("Bigarray.blit: dimension mismatch");
        for(var i=0;i < n_dims;i++)
         if(dims[i] != from.nth_dim(i))
          caml_invalid_argument("Bigarray.blit: dimension mismatch");
        data.set(from.data);
        if(data_type != 0)data2.set(from.data2)}
      function sub(ofs,len)
       {var changed_dim,mul=1;
        if(layout == 0)
         {for(var i=1;i < n_dims;i++)mul = mul * dims[i];changed_dim = 0}
        else
         {for(var i=0;i < n_dims - 1;i++)mul = mul * dims[i];
          changed_dim = n_dims - 1;
          ofs = ofs - 1}
        if(ofs < 0 || len < 0 || ofs + len > dims[changed_dim])
         caml_invalid_argument("Bigarray.sub: bad sub-array");
        var
         new_data=data.subarray(ofs * mul,(ofs + len) * mul),
         new_data2=
          data_type == 0?null:data2.subarray(ofs * mul,(ofs + len) * mul),
         new_dims=[];
        for(var i=0;i < n_dims;i++)new_dims[i] = dims[i];
        new_dims[changed_dim] = len;
        return caml_ba_create_from
                (new_data,new_data2,data_type,kind,layout,new_dims)}
      function slice(vind)
       {var num_inds=vind.length,index=[],sub_dims=[],ofs;
        if(num_inds >= n_dims)
         caml_invalid_argument("Bigarray.slice: too many indices");
        if(layout == 0)
         {for(var i=0;i < num_inds;i++)index[i] = vind[i];
          for(;i < n_dims;i++)index[i] = 0;
          ofs = offset(index);
          sub_dims = dims.slice(num_inds)}
        else
         {for(var i=0;i < num_inds;i++)index[n_dims - num_inds + i] = vind[i];
          for(var i=0;i < n_dims - num_inds;i++)index[i] = 1;
          ofs = offset(index);
          sub_dims = dims.slice(0,num_inds)}
        var
         size=caml_ba_get_size(sub_dims),
         new_data=data.subarray(ofs,ofs + size),
         new_data2=data_type == 0?null:data2.subarray(ofs,ofs + size);
        return caml_ba_create_from
                (new_data,new_data2,data_type,kind,layout,sub_dims)}
      function reshape(vdim)
       {var new_dim=[],num_dims=vdim.length;
        if(num_dims < 1)
         caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
        var num_elts=1;
        for(var i=0;i < num_dims;i++)
         {new_dim[i] = vdim[i];
          if(new_dim[i] < 0)
           caml_invalid_argument("Bigarray.reshape: negative dimension");
          num_elts = num_elts * new_dim[i]}
        if(num_elts != size)
         caml_invalid_argument("Bigarray.reshape: size mismatch");
        return caml_ba_create_from(data,data2,data_type,kind,layout,new_dim)}
      function compare(b,total)
       {if(layout != b.layout)return b.layout - layout;
        if(n_dims != b.num_dims)return b.num_dims - n_dims;
        for(var i=0;i < n_dims;i++)
         if(nth_dim(i) != b.nth_dim(i))return nth_dim(i) < b.nth_dim(i)?-1:1;
        switch(kind)
         {case 0:
          case 1:
          case 10:
          case 11:
           var x,y;
           for(var i=0;i < data.length;i++)
            {x = data[i];
             y = b.data[i];
             if(x < y)return -1;
             if(x > y)return 1;
             if(x != y)
              if(x != y)
               {if(!total)return NaN;if(x == x)return 1;if(y == y)return -1}
             if(data2)
              {x = data2[i];
               y = b.data2[i];
               if(x < y)return -1;
               if(x > y)return 1;
               if(x != y)
                if(x != y)
                 {if(!total)return NaN;if(x == x)return 1;if(y == y)return -1}}}
           break;
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 8:
          case 9:
          case 12:
           for(var i=0;i < data.length;i++)
            {if(data[i] < b.data[i])return -1;if(data[i] > b.data[i])return 1}
           break;
          case 7:
           for(var i=0;i < data.length;i++)
            {if(data2[i] < b.data2[i])return -1;
             if(data2[i] > b.data2[i])return 1;
             if(data[i] < b.data[i])return -1;
             if(data[i] > b.data[i])return 1}
           break
          }
        return 0}
      return {data:data,
              data2:data2,
              data_type:data_type,
              num_dims:n_dims,
              nth_dim:nth_dim,
              kind:kind,
              layout:layout,
              size:size,
              sub:sub,
              slice:slice,
              blit:blit,
              fill:fill,
              reshape:reshape,
              get:get,
              get1:get1,
              set:set,
              set1:set1,
              compare:compare}}
    function caml_ba_create(kind,layout,dims_ml)
     {caml_ba_init_views();
      var
       dims=caml_js_from_array(dims_ml),
       size=caml_ba_get_size(dims),
       view=caml_ba_views[0][kind];
      if(!view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size),data_type=caml_ba_views[1][kind],data2=null;
      if(data_type != 0)data2 = new view(size);
      return caml_ba_create_from(data,data2,data_type,kind,layout,dims)}
    function caml_ba_dim(ba,dim){return ba.nth_dim(dim)}
    function caml_ba_fill(ba,init){ba.fill(init);return 0}
    function caml_ba_get_1(ba,i0){return ba.get1(i0)}
    function caml_ba_get_generic(ba,index)
     {return ba.get(caml_js_from_array(index))}
    function caml_ba_kind(ba){return ba.kind}
    function caml_ba_num_dims(ba,_dim){return ba.num_dims}
    function caml_ba_reshape(ba,vind)
     {return ba.reshape(caml_js_from_array(vind))}
    function caml_ba_set_1(ba,i0,v){return ba.set1(i0,v)}
    function caml_ba_set_generic(ba,index,v)
     {return ba.set(caml_js_from_array(index),v)}
    function caml_ba_slice(ba,vind){return ba.slice(caml_js_from_array(vind))}
    function caml_ba_sub(ba,ofs,len){return ba.sub(ofs,len)}
    function caml_convert_string_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_string(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_string(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_string(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_string_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    var caml_blit_bytes=caml_blit_string;
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 255;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_string_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function raw_array_append_one(a,x)
     {var l=a.length,b=new Array(l + 1),i=0;
      for(;i < l;i++)b[i] = a[i];
      b[i] = x;
      return b}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      var n=f.length,argsLen=args.length,d=n - argsLen;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen
                (f.apply(null,raw_array_sub(args,0,n)),
                 raw_array_sub(args,n,argsLen - n));
       else
        return function(x)
         {return caml_call_gen(f,raw_array_append_one(args,x))}}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.22507385850720138e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_int64_compare(x,y)
     {var x3=x[3] << 16,y3=y[3] << 16;
      if(x3 > y3)return 1;
      if(x3 < y3)return -1;
      if(x[2] > y[2])return 1;
      if(x[2] < y[2])return -1;
      if(x[1] > y[1])return 1;
      if(x[1] < y[1])return -1;
      return 0}
    function caml_int_compare(a,b)
     {if(a < b)return -1;if(a == b)return 0;return 1}
    function caml_string_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?-1:s1.c > s2.c?1:0}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(!(total && a === b))
         if(a instanceof MlString)
          if(b instanceof MlString)
           {if(a !== b){var x=caml_string_compare(a,b);if(x != 0)return x}}
          else
           return 1;
         else
          if(a instanceof Array && a[0] === (a[0] | 0))
           {var ta=a[0];
            if(ta === 254)ta = 0;
            if(ta === 250)
             {a = a[1];continue}
            else
             if(b instanceof Array && b[0] === (b[0] | 0))
              {var tb=b[0];
               if(tb === 254)tb = 0;
               if(tb === 250)
                {b = b[1];continue}
               else
                if(ta != tb)
                 return ta < tb?-1:1;
                else
                 switch(ta)
                  {case 248:
                    var x=caml_int_compare(a[2],b[2]);if(x != 0)return x;break;
                   case 251:caml_invalid_argument("equal: abstract value");
                   case 255:
                    var x=caml_int64_compare(a,b);if(x != 0)return x;break;
                   default:
                    if(a.length != b.length)return a.length < b.length?-1:1;
                    if(a.length > 1)stack.push(a,b,1)}}
             else
              return 1}
          else
           if
            (b instanceof MlString
             ||
             b instanceof Array
             &&
             b[0]
             ===
             (b[0] | 0))
            return -1;
           else
            if(typeof a != "number" && a && a.compare)
             return a.compare(b,total);
            else
             if(typeof a == "function")
              caml_invalid_argument("compare: functional value");
             else
              {if(a < b)return -1;
               if(a > b)return 1;
               if(a != b)
                {if(!total)return NaN;if(a == a)return 1;if(b == b)return -1}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(-x)) / 2}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlString(len?2:9,"",len)}
    function caml_raise_constant(tag){throw tag}
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_equal(x,y){return +(caml_compare_val(x,y,false) == 0)}
    function caml_fill_string(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_string_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_bytes=caml_fill_string;
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return -1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return -1;
      return 0}
    function caml_bytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_parse_format(fmt)
     {fmt = caml_bytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:-1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_new_string(buffer)}
    function caml_format_float(fmt,x)
     {var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == -Infinity){f.sign = -1;x = -x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(!isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = x.toFixed(prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+s.slice(j + 1);
           if(exp < -4 || x >= 1e+21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_format_int(fmt,i)
     {if(caml_bytes_of_string(fmt) == "%d")return caml_new_string("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = -1;i = -i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    var caml_oo_last_id=0;
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_greaterequal(x,y)
     {return +(caml_compare_val(x,y,false) >= 0)}
    function caml_greaterthan(x,y){return +(caml_compare_val(x,y,false) > 0)}
    if(!Math.imul)
     Math.imul
     =
     function(x,y){y |= 0;return ((x >> 16) * y << 16) + (x & 65535) * y | 0};
    var caml_mul=Math.imul;
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,3432918353 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,461845907);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (3864292196 | 0) | 0}
    function caml_hash_mix_int64(h,v)
     {var lo=v[1] | v[2] << 24,hi=v[2] >>> 8 | v[3] << 16;
      h = caml_hash_mix_int(h,hi ^ lo);
      return h}
    var log2_ok=Math.log2 && Math.log2(1.12355820928894744e+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return -Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int64_bits_of_float(x)
     {if(!isFinite(x))
       {if(isNaN(x))return [255,1,0,32752];
        return x > 0?[255,0,0,32752]:[255,0,0,65520]}
      var sign=x == 0 && 1 / x == -Infinity?32768:x >= 0?0:32768;
      if(sign)x = -x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,-1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 15 | sign | exp << 4;
      return [255,r1,r2,r3]}
    function caml_hash_mix_float(h,v0)
     {var
       v=caml_int64_bits_of_float(v0),
       lo=v[1] | v[2] << 24,
       hi=v[2] >>> 8 | v[3] << 16;
      h = caml_hash_mix_int(h,lo);
      h = caml_hash_mix_int(h,hi);
      return h}
    function caml_hash_mix_string_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_string_str(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_string(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_string_str(h,v.c);break;
        case 2:h = caml_hash_mix_string_arr(h,v.c)
        }
      return h}
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,2246822507 | 0);
      h ^= h >>> 13;
      h = caml_mul(h,3266489909 | 0);
      h ^= h >>> 16;
      return h}
    var HASH_QUEUE_SIZE=256;
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > HASH_QUEUE_SIZE)sz = HASH_QUEUE_SIZE;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v instanceof Array && v[0] === (v[0] | 0))
         switch(v[0])
          {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
           case 250:queue[--rd] = v[1];break;
           case 255:h = caml_hash_mix_int64(h,v);num--;break;
           default:
            var tag=v.length - 1 << 10 | v[0];
            h = caml_hash_mix_int(h,tag);
            for(i = 1,len = v.length;i < len;i++)
             {if(wr >= sz)break;queue[wr++] = v[i]}
            break}
        else
         if(v instanceof MlString)
          {h = caml_hash_mix_string(h,v);num--}
         else
          if(v === (v | 0))
           {h = caml_hash_mix_int(h,v + v + 1);num--}
          else
           if(v === +v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 1073741823}
    function caml_int64_to_bytes(x)
     {return [x[3] >> 8,
              x[3] & 255,
              x[2] >> 16,
              x[2] >> 8 & 255,
              x[2] & 255,
              x[1] >> 16,
              x[1] >> 8 & 255,
              x[1] & 255]}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           case 255:
            count--;
            hash_accu = hash_accu * 65599 + obj[1] + (obj[2] << 24) | 0;
            break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(obj instanceof MlString)
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=obj.l,i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=obj.l,i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(obj === (obj | 0))
           {count--;hash_accu = hash_accu * 65599 + obj | 0}
          else
           if(obj === +obj)
            {count--;
             var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
             for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}}
      hash_aux(obj);
      return hash_accu & 1073741823}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 128)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 128;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 2048)
         {t += String.fromCharCode(192 | c >> 6);
          t += String.fromCharCode(128 | c & 63)}
        else
         if(c < 55296 || c >= 57343)
          t
          +=
          String.fromCharCode(224 | c >> 12,128 | c >> 6 & 63,128 | c & 63);
         else
          if
           (c
            >=
            56319
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            56320
            ||
            d
            >
            57343)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 56613888;
            t
            +=
            String.fromCharCode
             (240 | c >> 18,128 | c >> 12 & 63,128 | c >> 6 & 63,128 | c & 63)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_js_to_string(s)
     {var tag=9;
      if(!caml_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlString(tag,s,s.length)}
    function caml_hexstring_of_float(x,prec,style)
     {if(!isFinite(x))
       {if(isNaN(x))return caml_js_to_string("nan");
        return caml_js_to_string(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == -Infinity?1:x >= 0?0:1;
      if(sign)x = -x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > -1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_js_to_string
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function MlStringReader(s,i){this.s = caml_bytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_new_string(this.s.substring(i,i + len))}};
    function caml_int64_float_of_bits(x)
     {var exp=(x[3] & 32767) >> 4;
      if(exp == 2047)
       return (x[1] | x[2] | x[3] & 15) == 0
               ?x[3] & 32768?-Infinity:Infinity
               :NaN;
      var k=Math.pow(2,-24),res=(x[1] * k + x[2]) * k + (x[3] & 15);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,-1026);
      if(x[3] & 32768)res = -res;
      return res}
    function caml_int64_of_bytes(a)
     {return [255,
              a[7] | a[6] << 8 | a[5] << 16,
              a[4] | a[3] << 8 | a[2] << 16,
              a[1] | a[0] << 8]}
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 64)
         if(code >= 128)
          {var tag=code & 15,size=code >> 4 & 7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 63;
        else
         if(code >= 32)
          {var len=code & 31,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0:return reader.read8s();
            case 1:return reader.read16s();
            case 2:return reader.read32s();
            case 3:caml_failwith("input_value: integer too large");break;
            case 4:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 5:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 6:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 8:
             var
              header=reader.read32u(),
              tag=header & 255,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 19:caml_failwith("input_value: data block too large");break;
            case 9:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 10:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 12:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 11:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 14:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 13:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 7:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 15:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 16:
            case 17:caml_failwith("input_value: code pointer");break;
            case 18:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             switch(s)
              {case "_j":
                var t=new Array(8);
                for(var j=0;j < 8;j++)t[j] = reader.read8u();
                var v=caml_int64_of_bytes(t);
                if(intern_obj_table)intern_obj_table[obj_counter++] = v;
                return v;
               case "_i":
                var v=reader.read32s();
                if(intern_obj_table)intern_obj_table[obj_counter++] = v;
                return v;
               case "_n":
                switch(reader.read8u())
                 {case 1:
                   var v=reader.read32s();
                   if(intern_obj_table)intern_obj_table[obj_counter++] = v;
                   return v;
                  case 2:
                   caml_failwith("input_value: native integer value too large");
                  default:
                   caml_failwith("input_value: ill-formed native integer")}
               default:
                caml_failwith("input_value: unknown custom block identifier")}
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_int64_add(x,y)
     {var
       z1=x[1] + y[1],
       z2=x[2] + y[2] + (z1 >> 24),
       z3=x[3] + y[3] + (z2 >> 24);
      return [255,z1 & 16777215,z2 & 16777215,z3 & 65535]}
    function caml_int64_neg(x)
     {var y1=-x[1],y2=-x[2] + (y1 >> 24),y3=-x[3] + (y2 >> 24);
      return [255,y1 & 16777215,y2 & 16777215,y3 & 65535]}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_int64_sub(x,y)
     {var
       z1=x[1] - y[1],
       z2=x[2] - y[2] + (z1 >> 24),
       z3=x[3] - y[3] + (z2 >> 24);
      return [255,z1 & 16777215,z2 & 16777215,z3 & 65535]}
    function caml_int64_ucompare(x,y)
     {if(x[3] > y[3])return 1;
      if(x[3] < y[3])return -1;
      if(x[2] > y[2])return 1;
      if(x[2] < y[2])return -1;
      if(x[1] > y[1])return 1;
      if(x[1] < y[1])return -1;
      return 0}
    function caml_int64_lsl1(x)
     {x[3] = x[3] << 1 | x[2] >> 23;
      x[2] = (x[2] << 1 | x[1] >> 23) & 16777215;
      x[1] = x[1] << 1 & 16777215}
    function caml_int64_lsr1(x)
     {x[1] = (x[1] >>> 1 | x[2] << 23) & 16777215;
      x[2] = (x[2] >>> 1 | x[3] << 23) & 16777215;
      x[3] = x[3] >>> 1}
    function caml_int64_udivmod(x,y)
     {var
       offset=0,
       modulus=caml_obj_dup(x),
       divisor=caml_obj_dup(y),
       quotient=[255,0,0,0];
      while(caml_int64_ucompare(modulus,divisor) > 0)
       {offset++;caml_int64_lsl1(divisor)}
      while(offset >= 0)
       {offset--;
        caml_int64_lsl1(quotient);
        if(caml_int64_ucompare(modulus,divisor) >= 0)
         {quotient[1]++;modulus = caml_int64_sub(modulus,divisor)}
        caml_int64_lsr1(divisor)}
      return [0,quotient,modulus]}
    function caml_int64_is_zero(x){return (x[3] | x[2] | x[1]) == 0}
    function caml_int64_div(x,y)
     {if(caml_int64_is_zero(y))caml_raise_zero_divide();
      var sign=x[3] ^ y[3];
      if(x[3] & 32768)x = caml_int64_neg(x);
      if(y[3] & 32768)y = caml_int64_neg(y);
      var q=caml_int64_udivmod(x,y)[1];
      if(sign & 32768)q = caml_int64_neg(q);
      return q}
    function caml_int64_of_int32(x)
     {return [255,x & 16777215,x >> 24 & 16777215,x >> 31 & 65535]}
    function caml_int64_to_int32(x){return x[1] | x[2] << 24}
    function caml_int64_is_negative(x){return x[3] << 16 < 0}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = -1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=caml_int64_udivmod(x,wbase);
        x = p[1];
        buffer = cvtbl.charAt(caml_int64_to_int32(p[2])) + buffer}
      while
       (!caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    var caml_int64_offset=Math.pow(2,-24);
    function caml_int64_mul(x,y)
     {var
       z1=x[1] * y[1],
       z2=(z1 * caml_int64_offset | 0) + x[2] * y[1] + x[1] * y[2],
       z3=
        (z2 * caml_int64_offset | 0)
        +
        x[3]
        *
        y[1]
        +
        x[2]
        *
        y[2]
        +
        x[1]
        *
        y[3];
      return [255,z1 & 16777215,z2 & 16777215,z3 & 65535]}
    function caml_string_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_ml_string_length(s){return s.l}
    function caml_parse_sign_and_base(s)
     {var
       i=0,
       len=caml_ml_string_length(s),
       base=10,
       sign=len > 0 && caml_string_unsafe_get(s,0) == 45?(i++,-1):1;
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return -1}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=-1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_lessequal(x,y){return +(caml_compare_val(x,y,false) <= 0)}
    function caml_lessthan(x,y){return +(caml_compare_val(x,y,false) < 0)}
    function caml_log10_float(x){return Math.LOG10E * Math.log(x)}
    function caml_make_vect(len,init)
     {var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_string_unsafe_get(s,i)
               <<
               24
               |
               caml_string_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_string_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_string_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (2224400062 | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function caml_string_of_array(a){return new MlString(4,a,a.length)}
    var
     caml_md5_string=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 128 << 8 * (i & 3);
           for(i = (i & ~3) + 8;(i & 63) < 60;i += 4)buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 536870911;
           var w=[1732584193,4023233417,2562383102,271733878];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,3614090360);
             d = ff(d,a,b,c,buffer[i + 1],12,3905402710);
             c = ff(c,d,a,b,buffer[i + 2],17,606105819);
             b = ff(b,c,d,a,buffer[i + 3],22,3250441966);
             a = ff(a,b,c,d,buffer[i + 4],7,4118548399);
             d = ff(d,a,b,c,buffer[i + 5],12,1200080426);
             c = ff(c,d,a,b,buffer[i + 6],17,2821735955);
             b = ff(b,c,d,a,buffer[i + 7],22,4249261313);
             a = ff(a,b,c,d,buffer[i + 8],7,1770035416);
             d = ff(d,a,b,c,buffer[i + 9],12,2336552879);
             c = ff(c,d,a,b,buffer[i + 10],17,4294925233);
             b = ff(b,c,d,a,buffer[i + 11],22,2304563134);
             a = ff(a,b,c,d,buffer[i + 12],7,1804603682);
             d = ff(d,a,b,c,buffer[i + 13],12,4254626195);
             c = ff(c,d,a,b,buffer[i + 14],17,2792965006);
             b = ff(b,c,d,a,buffer[i + 15],22,1236535329);
             a = gg(a,b,c,d,buffer[i + 1],5,4129170786);
             d = gg(d,a,b,c,buffer[i + 6],9,3225465664);
             c = gg(c,d,a,b,buffer[i + 11],14,643717713);
             b = gg(b,c,d,a,buffer[i + 0],20,3921069994);
             a = gg(a,b,c,d,buffer[i + 5],5,3593408605);
             d = gg(d,a,b,c,buffer[i + 10],9,38016083);
             c = gg(c,d,a,b,buffer[i + 15],14,3634488961);
             b = gg(b,c,d,a,buffer[i + 4],20,3889429448);
             a = gg(a,b,c,d,buffer[i + 9],5,568446438);
             d = gg(d,a,b,c,buffer[i + 14],9,3275163606);
             c = gg(c,d,a,b,buffer[i + 3],14,4107603335);
             b = gg(b,c,d,a,buffer[i + 8],20,1163531501);
             a = gg(a,b,c,d,buffer[i + 13],5,2850285829);
             d = gg(d,a,b,c,buffer[i + 2],9,4243563512);
             c = gg(c,d,a,b,buffer[i + 7],14,1735328473);
             b = gg(b,c,d,a,buffer[i + 12],20,2368359562);
             a = hh(a,b,c,d,buffer[i + 5],4,4294588738);
             d = hh(d,a,b,c,buffer[i + 8],11,2272392833);
             c = hh(c,d,a,b,buffer[i + 11],16,1839030562);
             b = hh(b,c,d,a,buffer[i + 14],23,4259657740);
             a = hh(a,b,c,d,buffer[i + 1],4,2763975236);
             d = hh(d,a,b,c,buffer[i + 4],11,1272893353);
             c = hh(c,d,a,b,buffer[i + 7],16,4139469664);
             b = hh(b,c,d,a,buffer[i + 10],23,3200236656);
             a = hh(a,b,c,d,buffer[i + 13],4,681279174);
             d = hh(d,a,b,c,buffer[i + 0],11,3936430074);
             c = hh(c,d,a,b,buffer[i + 3],16,3572445317);
             b = hh(b,c,d,a,buffer[i + 6],23,76029189);
             a = hh(a,b,c,d,buffer[i + 9],4,3654602809);
             d = hh(d,a,b,c,buffer[i + 12],11,3873151461);
             c = hh(c,d,a,b,buffer[i + 15],16,530742520);
             b = hh(b,c,d,a,buffer[i + 2],23,3299628645);
             a = ii(a,b,c,d,buffer[i + 0],6,4096336452);
             d = ii(d,a,b,c,buffer[i + 7],10,1126891415);
             c = ii(c,d,a,b,buffer[i + 14],15,2878612391);
             b = ii(b,c,d,a,buffer[i + 5],21,4237533241);
             a = ii(a,b,c,d,buffer[i + 12],6,1700485571);
             d = ii(d,a,b,c,buffer[i + 3],10,2399980690);
             c = ii(c,d,a,b,buffer[i + 10],15,4293915773);
             b = ii(b,c,d,a,buffer[i + 1],21,2240044497);
             a = ii(a,b,c,d,buffer[i + 8],6,1873313359);
             d = ii(d,a,b,c,buffer[i + 15],10,4264355552);
             c = ii(c,d,a,b,buffer[i + 6],15,2734768916);
             b = ii(b,c,d,a,buffer[i + 13],21,1309151649);
             a = ii(a,b,c,d,buffer[i + 4],6,4149444226);
             d = ii(d,a,b,c,buffer[i + 11],10,3174756917);
             c = ii(c,d,a,b,buffer[i + 2],15,718787259);
             b = ii(b,c,d,a,buffer[i + 9],21,3951481745);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 255;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_ml_bytes_length(s){return s.l}
    var caml_ml_channels=new Array();
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(!chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(!chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(-1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = name instanceof MlString?name.toString():name;
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_raise_no_such_file(name)
     {name = name instanceof MlString?name.toString():name;
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_string_get(s,i)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlString(len?2:9,"",len)}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_string(len | 0);
      caml_blit_string(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_string_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_string(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_string(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_string(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_string_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(!this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun(caml_new_string(this.root),caml_new_string(name));
        if(res != 0)this.content[name] = new MlFakeFile(res[1])}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);if(m && !seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_string(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(content instanceof MlString)
       this.content[name] = new MlFakeFile(content);
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_string_of_array(content));
       else
        if(content.toString)
         {var mlstring=caml_new_string(content.toString());
          this.content[name] = new MlFakeFile(mlstring)}};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_array_of_string(s)
     {if(s.t != 4)caml_convert_string_to_array(s);return s.c}
    function caml_string_unsafe_set(s,i,c)
     {c &= 255;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_string_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    var Buffer=joo_global_object.Buffer;
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len){this.fs.ftruncateSync(this.fd,len | 0)};
    MlNodeFile.prototype.length
    =
    function(){return this.fs.fstatSync(this.fd).size};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(!a instanceof joo_global_object.Uint8Array)
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=new Buffer(a);
      this.fs.writeSync(this.fd,buffer,buf_offset,len,offset);
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(!(a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=new Buffer(a);
      this.fs.readSync(this.fd,buffer,buf_offset,len,offset);
      for(var i=0;i < len;i++)
       caml_string_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var a=new (joo_global_object.Uint8Array)(1),buffer=new Buffer(a);
      this.fs.readSync(this.fd,buffer,0,1,offset);
      return buffer[0]};
    MlNodeFile.prototype.close = function(){this.fs.closeSync(this.fd)};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name){return this.fs.existsSync(this.nm(name))?1:0};
    MlNodeDevice.prototype.readdir
    =
    function(name){return this.fs.readdirSync(this.nm(name))};
    MlNodeDevice.prototype.is_dir
    =
    function(name){return this.fs.statSync(this.nm(name)).isDirectory()?1:0};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {var b=this.fs.existsSync(this.nm(name))?1:0;
      this.fs.unlinkSync(this.nm(name));
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      var fd=this.fs.openSync(this.nm(name),res);
      return new MlNodeFile(fd)};
    MlNodeDevice.prototype.rename
    =
    function(o,n){this.fs.renameSync(this.nm(o),this.nm(n))};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0],jsoo_mount_point=[];
    if
     (typeof module
      !==
      "undefined"
      &&
      module.exports
      &&
      typeof require
      !==
      "undefined")
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (!res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_new_string(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function js_print_stdout(s)
     {var g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(!caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (name.toString()
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (name.toString()
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_string(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_string(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_string(0)));
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function caml_ml_output(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(!chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var string;
      if(offset == 0 && caml_ml_string_length(buffer) == len)
       string = buffer;
      else
       {string = caml_create_string(len);
        caml_blit_string(buffer,offset,string,0,len)}
      var jsstring=string.toString(),id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output_char(chanid,c)
     {var s=caml_new_string(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_ml_set_channel_name(){return 0}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = -i;f = -f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_notequal(x,y){return +(caml_compare_val(x,y,false) != 0)}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_obj_tag(x)
     {return x instanceof Array?x[0]:x instanceof MlString?252:1e3}
    var
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 255},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 255},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,2224400062);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v)
          {var writer=new Writer(),stack=[];
           function extern_rec(v)
            {if(v instanceof Array && v[0] === (v[0] | 0))
              {if(v[0] == 255)
                {writer.write(8,18);
                 for(var i=0;i < 3;i++)writer.write(8,"_j\0".charCodeAt(i));
                 var b=caml_int64_to_bytes(v);
                 for(var i=0;i < 8;i++)writer.write(8,b[i]);
                 writer.size_32 += 4;
                 writer.size_64 += 3;
                 return}
               if(v[0] == 251)
                caml_failwith("output_value: abstract value (Abstract)");
               if(v[0] < 16 && v.length - 1 < 8)
                writer.write(8,128 + v[0] + (v.length - 1 << 4));
               else
                writer.write_code(32,8,v.length - 1 << 10 | v[0]);
               writer.size_32 += v.length;
               writer.size_64 += v.length;
               if(v.length > 1)stack.push(v,1)}
             else
              if(v instanceof MlString)
               {var len=caml_ml_string_length(v);
                if(len < 32)
                 writer.write(8,32 + len);
                else
                 if(len < 256)
                  writer.write_code(8,9,len);
                 else
                  writer.write_code(32,10,len);
                for(var i=0;i < len;i++)
                 writer.write(8,caml_string_unsafe_get(v,i));
                writer.size_32 += 1 + ((len + 4) / 4 | 0);
                writer.size_64 += 1 + ((len + 8) / 8 | 0)}
              else
               if(v != (v | 0))
                {var type_of_v=typeof v;
                 caml_failwith
                  ("output_value: abstract value (" + type_of_v + ")")}
               else
                if(v >= 0 && v < 64)
                 writer.write(8,64 + v);
                else
                 if(v >= -(1 << 7) && v < 1 << 7)
                  writer.write_code(8,0,v);
                 else
                  if(v >= -(1 << 15) && v < 1 << 15)
                   writer.write_code(16,1,v);
                  else
                   writer.write_code(32,2,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_output_value_to_string(v,_fl)
     {return caml_string_of_array(caml_output_val(v))}
    function caml_register_global(n,v,name_opt)
     {caml_global_data[n + 1] = v;if(name_opt)caml_global_data[name_opt] = v}
    var caml_named_values={};
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_bytes_of_string(nm)] = v;return 0}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(-x)) / 2}
    function caml_string_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_sys_const_max_wosize(){return 2147483647 / 4 | 0}
    function caml_sys_get_config(){return [0,caml_new_string("Unix"),32,0]}
    function caml_sys_getcwd(){return caml_new_string(caml_current_dir)}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=name.toString();
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_js_to_string(g.process.env[n]);
      caml_raise_not_found()}
    function caml_sys_random_seed()
     {var x=new Date() ^ 4294967295 * Math.random();return [0,x]}
    var caml_initial_time=new Date() * 0.001;
    function caml_sys_time(){return new Date() * 0.001 - caml_initial_time}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(-x);return (y - z) / (y + z)}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_return_exn_constant(tag){return tag}
    function caml_named_value(nm){return caml_named_values[nm]}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_js_to_string(String(e))]}
    function unix_gettimeofday(){return new Date().getTime() / 1e3}
    function unix_inet_addr_of_string(){return 0}
    function unix_localtime(t)
     {var
       d=new Date(t * 1e3),
       januaryfirst=new Date(d.getFullYear(),0,1),
       doy=Math.floor((d - januaryfirst) / 864e5),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4?f(a0,a1,a2,a3):caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5?f(a0,a1,a2,a3,a4):caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    function caml_call8(f,a0,a1,a2,a3,a4,a5,a6,a7)
     {return f.length == 8
              ?f(a0,a1,a2,a3,a4,a5,a6,a7)
              :caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7])}
    var
     Out_of_memory=[248,caml_new_string("Out_of_memory"),-1],
     Sys_error=[248,caml_new_string("Sys_error"),-2],
     Failure=[248,caml_new_string("Failure"),-3],
     Invalid_argument=[248,caml_new_string("Invalid_argument"),-4],
     End_of_file=[248,caml_new_string("End_of_file"),-5],
     Division_by_zero=[248,caml_new_string("Division_by_zero"),-6],
     Not_found=[248,caml_new_string("Not_found"),-7],
     Match_failure=[248,caml_new_string("Match_failure"),-8],
     Stack_overflow=[248,caml_new_string("Stack_overflow"),-9],
     Sys_blocked_io=[248,caml_new_string("Sys_blocked_io"),-10],
     Assert_failure=[248,caml_new_string("Assert_failure"),-11],
     Undefined_recursive_module=
      [248,caml_new_string("Undefined_recursive_module"),-12],
     mode$0=[0,0,[0,7,0]],
     mode=[0,1,[0,3,[0,4,[0,7,0]]]],
     param=
      [0,
       [11,caml_new_string("invalid box description "),[3,0,0]],
       caml_new_string("invalid box description %S")],
     zero=[254,0,0],
     one=[254,1,0],
     partial=[11,caml_new_string(" t:"),[2,0,[11,caml_new_string(" }\n"),0]]],
     init$0=caml_new_string(""),
     row_prefix=caml_new_string("R"),
     col_prefix=caml_new_string("C"),
     partial$0=
      [4,
       0,
       [0,2,2],
       0,
       [12,46,[4,0,[0,2,3],0,[12,32,[2,0,[11,caml_new_string(" : "),0]]]]]],
     s=caml_new_string("INFO"),
     partial$1=[12,44,[4,3,0,0,[11,caml_new_string("]\n"),0]]],
     partial$2=[12,44,[4,3,0,0,[11,caml_new_string("]\n"),0]]],
     partial$3=[12,10,0],
     a=[0,0],
     partial$4=
      [11,caml_new_string(" | L: "),[8,0,0,[0,6],[12,91,[2,0,[12,93,0]]]]];
    caml_register_global
     (11,Undefined_recursive_module,"Undefined_recursive_module");
    caml_register_global(10,Assert_failure,"Assert_failure");
    caml_register_global(9,Sys_blocked_io,"Sys_blocked_io");
    caml_register_global(8,Stack_overflow,"Stack_overflow");
    caml_register_global(7,Match_failure,"Match_failure");
    caml_register_global(6,Not_found,"Not_found");
    caml_register_global(5,Division_by_zero,"Division_by_zero");
    caml_register_global(4,End_of_file,"End_of_file");
    caml_register_global(3,Invalid_argument,"Invalid_argument");
    caml_register_global(2,Failure,"Failure");
    caml_register_global(1,Sys_error,"Sys_error");
    caml_register_global(0,Out_of_memory,"Out_of_memory");
    var
     _k_=caml_new_string("%,"),
     _i_=caml_new_string("really_input"),
     _h_=caml_new_string("input"),
     _g_=caml_new_string("output_substring"),
     _e_=caml_new_string("true"),
     _f_=caml_new_string("false"),
     _a_=[255,1,0,32752],
     _b_=[255,16777215,16777215,32751],
     _c_=[255,0,0,16],
     _l_=caml_new_string("List.init"),
     _n_=caml_new_string("\\\\"),
     _o_=caml_new_string("\\'"),
     _p_=caml_new_string("\\b"),
     _q_=caml_new_string("\\t"),
     _r_=caml_new_string("\\n"),
     _s_=caml_new_string("\\r"),
     _v_=caml_new_string("String.blit / Bytes.blit_string"),
     _u_=caml_new_string("Bytes.blit"),
     _t_=caml_new_string("String.sub / Bytes.sub"),
     _y_=caml_new_string("String.contains_from / Bytes.contains_from"),
     _x_=caml_new_string(""),
     _w_=caml_new_string("String.concat"),
     _z_=caml_new_string("Marshal.from_bytes"),
     _A_=caml_new_string("Marshal.from_bytes"),
     _E_=caml_new_string("Array.map2: arrays must have the same length"),
     _D_=caml_new_string("Array.iter2: arrays must have the same length"),
     _C_=caml_new_string("Array.sub"),
     _B_=caml_new_string("Array.init"),
     _F_=caml_new_string("CamlinternalLazy.Undefined"),
     _I_=caml_new_string("Buffer.add_substring/add_subbytes"),
     _H_=caml_new_string("Buffer.add: cannot grow buffer"),
     _G_=caml_new_string("Buffer.sub"),
     _R_=caml_new_string("%c"),
     _S_=caml_new_string("%s"),
     _T_=caml_new_string("%i"),
     _U_=caml_new_string("%li"),
     _V_=caml_new_string("%ni"),
     _W_=caml_new_string("%Li"),
     _X_=caml_new_string("%f"),
     _Y_=caml_new_string("%B"),
     _Z_=caml_new_string("%{"),
     ___=caml_new_string("%}"),
     _$_=caml_new_string("%("),
     _aa_=caml_new_string("%)"),
     _ab_=caml_new_string("%a"),
     _ac_=caml_new_string("%t"),
     _ad_=caml_new_string("%?"),
     _ae_=caml_new_string("%r"),
     _af_=caml_new_string("%_r"),
     _ag_=[0,caml_new_string("camlinternalFormat.ml"),846,23],
     _ar_=[0,caml_new_string("camlinternalFormat.ml"),810,21],
     _aj_=[0,caml_new_string("camlinternalFormat.ml"),811,21],
     _as_=[0,caml_new_string("camlinternalFormat.ml"),814,21],
     _ak_=[0,caml_new_string("camlinternalFormat.ml"),815,21],
     _at_=[0,caml_new_string("camlinternalFormat.ml"),818,19],
     _al_=[0,caml_new_string("camlinternalFormat.ml"),819,19],
     _au_=[0,caml_new_string("camlinternalFormat.ml"),822,22],
     _am_=[0,caml_new_string("camlinternalFormat.ml"),823,22],
     _av_=[0,caml_new_string("camlinternalFormat.ml"),827,30],
     _an_=[0,caml_new_string("camlinternalFormat.ml"),828,30],
     _ap_=[0,caml_new_string("camlinternalFormat.ml"),832,26],
     _ah_=[0,caml_new_string("camlinternalFormat.ml"),833,26],
     _aq_=[0,caml_new_string("camlinternalFormat.ml"),842,28],
     _ai_=[0,caml_new_string("camlinternalFormat.ml"),843,28],
     _ao_=[0,caml_new_string("camlinternalFormat.ml"),847,23],
     _bs_=caml_new_string("%u"),
     _bq_=[0,caml_new_string("camlinternalFormat.ml"),1525,4],
     _br_=caml_new_string("Printf: bad conversion %["),
     _bt_=[0,caml_new_string("camlinternalFormat.ml"),1593,39],
     _bu_=[0,caml_new_string("camlinternalFormat.ml"),1616,31],
     _bv_=[0,caml_new_string("camlinternalFormat.ml"),1617,31],
     _bw_=caml_new_string("Printf: bad conversion %_"),
     _bx_=[0,caml_new_string("camlinternalFormat.ml"),1797,8],
     _by_=caml_new_string("@{"),
     _bz_=caml_new_string("@["),
     _bA_=caml_new_string("@{"),
     _bB_=caml_new_string("@["),
     _bC_=caml_new_string(""),
     _bD_=[0,0,4],
     _bE_=caml_new_string(""),
     _bF_=caml_new_string("b"),
     _bG_=caml_new_string("h"),
     _bH_=caml_new_string("hov"),
     _bI_=caml_new_string("hv"),
     _bJ_=caml_new_string("v"),
     _bo_=caml_new_string("nan"),
     _bp_=caml_new_string("."),
     _bm_=caml_new_string("neg_infinity"),
     _bn_=caml_new_string("infinity"),
     _bl_=caml_new_string("%.12g"),
     _a__=caml_new_string("%nd"),
     _a$_=caml_new_string("%+nd"),
     _ba_=caml_new_string("% nd"),
     _bb_=caml_new_string("%ni"),
     _bc_=caml_new_string("%+ni"),
     _bd_=caml_new_string("% ni"),
     _be_=caml_new_string("%nx"),
     _bf_=caml_new_string("%#nx"),
     _bg_=caml_new_string("%nX"),
     _bh_=caml_new_string("%#nX"),
     _bi_=caml_new_string("%no"),
     _bj_=caml_new_string("%#no"),
     _bk_=caml_new_string("%nu"),
     _aX_=caml_new_string("%ld"),
     _aY_=caml_new_string("%+ld"),
     _aZ_=caml_new_string("% ld"),
     _a0_=caml_new_string("%li"),
     _a1_=caml_new_string("%+li"),
     _a2_=caml_new_string("% li"),
     _a3_=caml_new_string("%lx"),
     _a4_=caml_new_string("%#lx"),
     _a5_=caml_new_string("%lX"),
     _a6_=caml_new_string("%#lX"),
     _a7_=caml_new_string("%lo"),
     _a8_=caml_new_string("%#lo"),
     _a9_=caml_new_string("%lu"),
     _aK_=caml_new_string("%Ld"),
     _aL_=caml_new_string("%+Ld"),
     _aM_=caml_new_string("% Ld"),
     _aN_=caml_new_string("%Li"),
     _aO_=caml_new_string("%+Li"),
     _aP_=caml_new_string("% Li"),
     _aQ_=caml_new_string("%Lx"),
     _aR_=caml_new_string("%#Lx"),
     _aS_=caml_new_string("%LX"),
     _aT_=caml_new_string("%#LX"),
     _aU_=caml_new_string("%Lo"),
     _aV_=caml_new_string("%#Lo"),
     _aW_=caml_new_string("%Lu"),
     _ax_=caml_new_string("%d"),
     _ay_=caml_new_string("%+d"),
     _az_=caml_new_string("% d"),
     _aA_=caml_new_string("%i"),
     _aB_=caml_new_string("%+i"),
     _aC_=caml_new_string("% i"),
     _aD_=caml_new_string("%x"),
     _aE_=caml_new_string("%#x"),
     _aF_=caml_new_string("%X"),
     _aG_=caml_new_string("%#X"),
     _aH_=caml_new_string("%o"),
     _aI_=caml_new_string("%#o"),
     _aJ_=caml_new_string("%u"),
     _J_=caml_new_string("@]"),
     _K_=caml_new_string("@}"),
     _L_=caml_new_string("@?"),
     _M_=caml_new_string("@\n"),
     _N_=caml_new_string("@."),
     _O_=caml_new_string("@@"),
     _P_=caml_new_string("@%"),
     _Q_=caml_new_string("@"),
     _aw_=caml_new_string("CamlinternalFormat.Type_mismatch"),
     _bL_=caml_new_string("Random.int"),
     _bK_=caml_new_string("x"),
     _pZ_=caml_new_string("OCAMLRUNPARAM"),
     _pX_=caml_new_string("CAMLRUNPARAM"),
     _bM_=caml_new_string(""),
     _bV_=[3,0,3],
     _bW_=caml_new_string("."),
     _bT_=caml_new_string(">"),
     _bU_=caml_new_string("</"),
     _bR_=caml_new_string(">"),
     _bS_=caml_new_string("<"),
     _bQ_=caml_new_string("\n"),
     _bO_=caml_new_string("Format.Empty_queue"),
     _bP_=[0,caml_new_string("")],
     _bX_=caml_new_string("-"),
     _pW_=caml_new_string("TMPDIR"),
     _pV_=caml_new_string("TEMP"),
     _bY_=caml_new_string("Cygwin"),
     _bZ_=caml_new_string("Win32"),
     _b4_=caml_new_string("E2BIG"),
     _b6_=caml_new_string("EACCES"),
     _b7_=caml_new_string("EAGAIN"),
     _b8_=caml_new_string("EBADF"),
     _b9_=caml_new_string("EBUSY"),
     _b__=caml_new_string("ECHILD"),
     _b$_=caml_new_string("EDEADLK"),
     _ca_=caml_new_string("EDOM"),
     _cb_=caml_new_string("EEXIST"),
     _cc_=caml_new_string("EFAULT"),
     _cd_=caml_new_string("EFBIG"),
     _ce_=caml_new_string("EINTR"),
     _cf_=caml_new_string("EINVAL"),
     _cg_=caml_new_string("EIO"),
     _ch_=caml_new_string("EISDIR"),
     _ci_=caml_new_string("EMFILE"),
     _cj_=caml_new_string("EMLINK"),
     _ck_=caml_new_string("ENAMETOOLONG"),
     _cl_=caml_new_string("ENFILE"),
     _cm_=caml_new_string("ENODEV"),
     _cn_=caml_new_string("ENOENT"),
     _co_=caml_new_string("ENOEXEC"),
     _cp_=caml_new_string("ENOLCK"),
     _cq_=caml_new_string("ENOMEM"),
     _cr_=caml_new_string("ENOSPC"),
     _cs_=caml_new_string("ENOSYS"),
     _ct_=caml_new_string("ENOTDIR"),
     _cu_=caml_new_string("ENOTEMPTY"),
     _cv_=caml_new_string("ENOTTY"),
     _cw_=caml_new_string("ENXIO"),
     _cx_=caml_new_string("EPERM"),
     _cy_=caml_new_string("EPIPE"),
     _cz_=caml_new_string("ERANGE"),
     _cA_=caml_new_string("EROFS"),
     _cB_=caml_new_string("ESPIPE"),
     _cC_=caml_new_string("ESRCH"),
     _cD_=caml_new_string("EXDEV"),
     _cE_=caml_new_string("EWOULDBLOCK"),
     _cF_=caml_new_string("EINPROGRESS"),
     _cG_=caml_new_string("EALREADY"),
     _cH_=caml_new_string("ENOTSOCK"),
     _cI_=caml_new_string("EDESTADDRREQ"),
     _cJ_=caml_new_string("EMSGSIZE"),
     _cK_=caml_new_string("EPROTOTYPE"),
     _cL_=caml_new_string("ENOPROTOOPT"),
     _cM_=caml_new_string("EPROTONOSUPPORT"),
     _cN_=caml_new_string("ESOCKTNOSUPPORT"),
     _cO_=caml_new_string("EOPNOTSUPP"),
     _cP_=caml_new_string("EPFNOSUPPORT"),
     _cQ_=caml_new_string("EAFNOSUPPORT"),
     _cR_=caml_new_string("EADDRINUSE"),
     _cS_=caml_new_string("EADDRNOTAVAIL"),
     _cT_=caml_new_string("ENETDOWN"),
     _cU_=caml_new_string("ENETUNREACH"),
     _cV_=caml_new_string("ENETRESET"),
     _cW_=caml_new_string("ECONNABORTED"),
     _cX_=caml_new_string("ECONNRESET"),
     _cY_=caml_new_string("ENOBUFS"),
     _cZ_=caml_new_string("EISCONN"),
     _c0_=caml_new_string("ENOTCONN"),
     _c1_=caml_new_string("ESHUTDOWN"),
     _c2_=caml_new_string("ETOOMANYREFS"),
     _c3_=caml_new_string("ETIMEDOUT"),
     _c4_=caml_new_string("ECONNREFUSED"),
     _c5_=caml_new_string("EHOSTDOWN"),
     _c6_=caml_new_string("EHOSTUNREACH"),
     _c7_=caml_new_string("ELOOP"),
     _c8_=caml_new_string("EOVERFLOW"),
     _c9_=
      [0,
       [11,caml_new_string("EUNKNOWNERR "),[4,0,0,0,0]],
       caml_new_string("EUNKNOWNERR %d")],
     _b5_=
      [0,
       [11,
        caml_new_string("Unix.Unix_error(Unix."),
        [2,
         0,
         [11,
          caml_new_string(", "),
          [3,0,[11,caml_new_string(", "),[3,0,[12,41,0]]]]]]],
       caml_new_string("Unix.Unix_error(Unix.%s, %S, %S)")],
     _b0_=caml_new_string("Unix.Unix_error"),
     _b1_=caml_new_string(""),
     _b2_=caml_new_string(""),
     _b3_=caml_new_string("Unix.Unix_error"),
     _c__=caml_new_string("0.0.0.0"),
     _c$_=caml_new_string("127.0.0.1"),
     _pU_=caml_new_string("::"),
     _pT_=caml_new_string("::1"),
     _da_=caml_new_string("Bigarray.array1_of_genarray"),
     _dc_=[255,1,0,0],
     _db_=[255,0,0,0],
     _dp_=[0,[0,0],caml_new_string("%c")],
     _do_=
      [0,
       [12,
        40,
        [8,
         12,
         0,
         0,
         [11,caml_new_string(", "),[8,12,0,0,[11,caml_new_string("i)"),0]]]]],
       caml_new_string("(%G, %Gi)")],
     _dn_=
      [0,
       [12,
        40,
        [8,
         12,
         0,
         0,
         [11,caml_new_string(", "),[8,12,0,0,[11,caml_new_string("i)"),0]]]]],
       caml_new_string("(%G, %Gi)")],
     _dm_=[0,[6,0,0,0,0],caml_new_string("%nd")],
     _dl_=[0,[4,3,0,0,0],caml_new_string("%i")],
     _dk_=[0,[7,0,0,0,0],caml_new_string("%Ld")],
     _dj_=[0,[5,0,0,0,0],caml_new_string("%ld")],
     _di_=[0,[4,3,0,0,0],caml_new_string("%i")],
     _dh_=[0,[4,3,0,0,0],caml_new_string("%i")],
     _dg_=[0,[4,3,0,0,0],caml_new_string("%i")],
     _df_=[0,[4,3,0,0,0],caml_new_string("%i")],
     _de_=[0,[8,12,0,0,0],caml_new_string("%G")],
     _dd_=[0,[8,12,0,0,0],caml_new_string("%G")],
     _dx_=caml_new_string("owl_utils:eps"),
     _du_=[0,[4,3,[0,2,2],0,[12,115,0]],caml_new_string("%02is")],
     _dv_=
      [0,
       [4,3,[0,2,2],0,[12,109,[4,3,[0,2,2],0,[12,115,0]]]],
       caml_new_string("%02im%02is")],
     _dw_=
      [0,
       [4,3,0,0,[12,104,[4,3,[0,2,2],0,[12,109,0]]]],
       caml_new_string("%ih%02im")],
     _dt_=caml_new_string(""),
     _ds_=caml_new_string(""),
     _dr_=caml_new_string(","),
     _dq_=[0,[2,0,[2,0,[2,0,0]]],caml_new_string("%s%s%s")],
     _dA_=[0,0],
     _hm_=[0,[2,0,0],caml_new_string("%s")],
     _hl_=
      [0,
       [11,
        caml_new_string("digraph CG {\nnode [shape=record];\n"),
        [2,0,[12,125,0]]],
       caml_new_string("digraph CG {\nnode [shape=record];\n%s}")],
     _hi_=caml_new_string("Const"),
     _hj_=
      [0,
       [4,
        3,
        0,
        0,
        [11,
         caml_new_string(' [ label="#'),
         [4,
          3,
          0,
          0,
          [11,
           caml_new_string(" | { "),
           [2,
            0,
            [11,
             caml_new_string(" | "),
             [2,
              0,
              [11,caml_new_string(' }" fillcolor=gray, style=filled ];\n'),0]]]]]]]],
       caml_new_string
        ('%i [ label="#%i | { %s | %s }" fillcolor=gray, style=filled ];\n')],
     _hk_=
      [0,
       [4,
        3,
        0,
        0,
        [11,
         caml_new_string(' [ label="#'),
         [4,
          3,
          0,
          0,
          [11,
           caml_new_string(" | { "),
           [2,
            0,
            [11,
             caml_new_string(" | "),
             [2,0,[11,caml_new_string(' }" ];\n'),0]]]]]]]],
       caml_new_string('%i [ label="#%i | { %s | %s }" ];\n')],
     _hg_=
      [0,
       [12,
        9,
        [4,
         3,
         0,
         0,
         [11,caml_new_string(" -> "),[4,3,0,0,[11,caml_new_string(";\n"),0]]]]],
       caml_new_string("\t%i -> %i;\n")],
     _hf_=caml_new_string(""),
     _he_=caml_new_string(""),
     _hh_=caml_new_string(""),
     _hd_=
      [0,
       [11,
        caml_new_string("{ i:"),
        [4,
         3,
         0,
         0,
         [11,
          caml_new_string(" o:"),
          [2,
           0,
           [11,
            caml_new_string(" t:"),
            [2,
             0,
             [11,
              caml_new_string(" } -> { i:"),
              [4,3,0,0,[11,caml_new_string(" o:"),[2,0,partial]]]]]]]]]],
       caml_new_string("{ i:%i o:%s t:%s } -> { i:%i o:%s t:%s }\n")],
     _hc_=caml_new_string(""),
     _hb_=caml_new_string(""),
     _fK_=[0,[11,caml_new_string("Const"),0],caml_new_string("Const")],
     _fL_=[0,[11,caml_new_string("Const"),0],caml_new_string("Const")],
     _fM_=[0,[11,caml_new_string("DF"),0],caml_new_string("DF")],
     _fN_=[0,caml_new_string("Noop"),0],
     _fO_=caml_new_string("Add_D_D"),
     _fP_=caml_new_string("Add_D_C"),
     _fQ_=caml_new_string("Add_C_D"),
     _fR_=caml_new_string("Sub_D_D"),
     _fS_=caml_new_string("Sub_D_C"),
     _fT_=caml_new_string("Sub_C_D"),
     _fU_=caml_new_string("Mul_D_D"),
     _fV_=caml_new_string("Mul_D_C"),
     _fW_=caml_new_string("Mul_C_D"),
     _fX_=caml_new_string("Div_D_D"),
     _fY_=caml_new_string("Div_D_C"),
     _fZ_=caml_new_string("Div_C_D"),
     _f0_=caml_new_string("Pow_D_D"),
     _f1_=caml_new_string("Pow_D_C"),
     _f2_=caml_new_string("Pow_C_D"),
     _f3_=caml_new_string("Atan2_D_D"),
     _f4_=caml_new_string("Atan2_D_C"),
     _f5_=caml_new_string("Atan2_C_D"),
     _f6_=caml_new_string("Neg_D"),
     _f7_=caml_new_string("Abs_D"),
     _f8_=caml_new_string("Signum_D"),
     _f9_=caml_new_string("Floor_D"),
     _f__=caml_new_string("Ceil_D"),
     _f$_=caml_new_string("Round_D"),
     _ga_=caml_new_string("Sqr_D"),
     _gb_=caml_new_string("Sqrt_D"),
     _gc_=caml_new_string("Log_D"),
     _gd_=caml_new_string("Log2_D"),
     _ge_=caml_new_string("Log10_D"),
     _gf_=caml_new_string("Exp_D"),
     _gg_=caml_new_string("Sin_D"),
     _gh_=caml_new_string("Cos_D"),
     _gi_=caml_new_string("Tan_D"),
     _gj_=caml_new_string("Sinh_D"),
     _gk_=caml_new_string("Cosh_D"),
     _gl_=caml_new_string("Tanh_D"),
     _gm_=caml_new_string("Asin_D"),
     _gn_=caml_new_string("Acos_D"),
     _go_=caml_new_string("Atan_D"),
     _gp_=caml_new_string("Asinh_D"),
     _gq_=caml_new_string("Acosh_D"),
     _gr_=caml_new_string("Atanh_D"),
     _gs_=caml_new_string("Get_Item"),
     _gt_=caml_new_string("SetI_D_D"),
     _gu_=caml_new_string("SetI_D_C"),
     _gv_=caml_new_string("SetI_C_D"),
     _gw_=caml_new_string("AddI_D_D"),
     _gx_=caml_new_string("AddI_D_C"),
     _gy_=caml_new_string("AddI_C_D"),
     _gz_=caml_new_string("Get_Slice_D"),
     _gA_=caml_new_string("Set_Slice_D_D"),
     _gB_=caml_new_string("Set_Slice_D_C"),
     _gC_=caml_new_string("Set_Slice_C_D"),
     _gD_=caml_new_string("Sum_D"),
     _gE_=caml_new_string("Sum__D"),
     _gF_=caml_new_string("Dot_D_D"),
     _gG_=caml_new_string("Dot_D_C"),
     _gH_=caml_new_string("Dot_C_D"),
     _gI_=caml_new_string("Trans_D"),
     _gJ_=caml_new_string("L1Norm_D"),
     _gK_=caml_new_string("L2Norm_D"),
     _gL_=caml_new_string("L2NormS_D"),
     _gM_=caml_new_string("Sigmoid_D"),
     _gN_=caml_new_string("Relu_D"),
     _gO_=caml_new_string("Inv_D"),
     _gP_=caml_new_string("Add_Row_D_D"),
     _gQ_=caml_new_string("Add_Row_D_C"),
     _gR_=caml_new_string("Add_Row_C_D"),
     _gS_=caml_new_string("Get_Row_D"),
     _gT_=caml_new_string("Of_Rows_D"),
     _gU_=caml_new_string("Concat_D_D"),
     _gV_=caml_new_string("Concat_D_C"),
     _gW_=caml_new_string("Concat_C_D"),
     _gX_=caml_new_string("Conv1D_D_D"),
     _gY_=caml_new_string("Conv1D_D_C"),
     _gZ_=caml_new_string("Conv1D_C_D"),
     _g0_=caml_new_string("Conv2D_D_D"),
     _g1_=caml_new_string("Conv2D_D_C"),
     _g2_=caml_new_string("Conv2D_C_D"),
     _g3_=caml_new_string("Conv3D_D_D"),
     _g4_=caml_new_string("Conv3D_D_C"),
     _g5_=caml_new_string("Conv3D_C_D"),
     _g6_=caml_new_string("Reshape_D"),
     _g7_=caml_new_string("Maxpool1D_D"),
     _g8_=caml_new_string("Maxpool2D_D"),
     _g9_=caml_new_string("Maxpool3D_D"),
     _g__=caml_new_string("Avgpool1D_D"),
     _g$_=caml_new_string("Avgpool2D_D"),
     _ha_=caml_new_string("Avgpool3D_D"),
     _fI_=caml_new_string("error: jacobian"),
     _fJ_=caml_new_string("error: jacobian"),
     _fH_=[0,1],
     _fG_=[0,1],
     _fq_=[0,1],
     _fr_=[0,1],
     _fs_=[0,2],
     _ft_=[0,2],
     _fu_=[0,1],
     _fv_=[0,1],
     _fw_=[0,1],
     _fx_=[0,1],
     _fy_=[0,1],
     _fz_=[0,1],
     _fA_=[0,0],
     _fB_=[0,0],
     _fC_=[0,2],
     _fD_=[0,1],
     _fE_=[0,2],
     _fF_=[0,1],
     _dZ_=
      caml_new_string("error: forward and reverse clash at the same level"),
     _d0_=
      caml_new_string("error: forward and reverse clash at the same level"),
     _d1_=caml_new_string("( + )"),
     _d2_=caml_new_string("( - )"),
     _d3_=caml_new_string("( * )"),
     _d4_=caml_new_string("( / )"),
     _d7_=[0,1],
     _d6_=[0,1],
     _d5_=caml_new_string("( ** )"),
     _d8_=caml_new_string("atan2"),
     _d9_=[0,2],
     _d__=[0,2],
     _ea_=[0,0],
     _d$_=caml_new_string("neg"),
     _eb_=caml_new_string("abs"),
     _ec_=caml_new_string("signum"),
     _ed_=caml_new_string("floor"),
     _ee_=caml_new_string("ceil"),
     _ef_=caml_new_string("round"),
     _eh_=[0,2],
     _eg_=caml_new_string("sqr"),
     _ej_=[0,2],
     _ei_=caml_new_string("sqrt"),
     _ek_=caml_new_string("log"),
     _el_=caml_new_string("log2"),
     _em_=caml_new_string("log10"),
     _en_=caml_new_string("exp"),
     _eo_=caml_new_string("sin"),
     _ep_=caml_new_string("cos"),
     _eq_=caml_new_string("tan"),
     _er_=caml_new_string("sinh"),
     _es_=caml_new_string("cosh"),
     _et_=caml_new_string("tanh"),
     _ev_=[0,1],
     _eu_=caml_new_string("asin"),
     _ex_=[0,1],
     _ew_=caml_new_string("acos"),
     _ez_=[0,1],
     _ey_=caml_new_string("atan"),
     _eB_=[0,1],
     _eA_=caml_new_string("asinh"),
     _eD_=[0,1],
     _eC_=caml_new_string("acosh"),
     _eF_=[0,1],
     _eE_=caml_new_string("atanh"),
     _eG_=caml_new_string("get_item"),
     _eH_=[0,0],
     _eJ_=[0,0],
     _eI_=caml_new_string("set_item"),
     _eK_=caml_new_string("add_item"),
     _eL_=caml_new_string("slice"),
     _eM_=caml_new_string("set_slice"),
     _eN_=caml_new_string("sum"),
     _eO_=caml_new_string("sum"),
     _eP_=caml_new_string("( *@ )"),
     _eQ_=caml_new_string("transpose"),
     _eR_=caml_new_string("l1norm'"),
     _eS_=caml_new_string("l2norm'"),
     _eU_=[0,2],
     _eT_=caml_new_string("l2norm_sqr'"),
     _eW_=[0,1],
     _eV_=caml_new_string("sigmoid"),
     _eY_=[0,2],
     _eZ_=[0,1],
     _eX_=caml_new_string("relu"),
     _e0_=caml_new_string("inv"),
     _e1_=[0,1],
     _e2_=[0,1],
     _e3_=caml_new_string("add_row"),
     _e4_=caml_new_string("get_row"),
     _e5_=caml_new_string("of_rows a.(0)"),
     _e9_=caml_new_string("conv1d:df_dab"),
     _e8_=caml_new_string("conv1d:df_db"),
     _e7_=caml_new_string("conv1d:df_da"),
     _e6_=caml_new_string("conv1d"),
     _e__=caml_new_string("conv2d"),
     _e$_=caml_new_string("conv3d"),
     _fa_=caml_new_string("reshape"),
     _fc_=caml_new_string("max_pool1d:df"),
     _fb_=caml_new_string("max_pool1d"),
     _fe_=caml_new_string("max_pool2d:df"),
     _fd_=caml_new_string("max_pool2d"),
     _fg_=caml_new_string("max_pool3d:df"),
     _ff_=caml_new_string("max_pool3d"),
     _fi_=caml_new_string("avg_pool1d:df"),
     _fh_=caml_new_string("avg_pool1d"),
     _fk_=caml_new_string("avg_pool2d:df"),
     _fj_=caml_new_string("avg_pool2d"),
     _fm_=caml_new_string("avg_pool3d:df"),
     _fl_=caml_new_string("avg_pool3d"),
     _fn_=caml_new_string("dropout"),
     _fo_=caml_new_string("concat"),
     _fp_=caml_new_string("split"),
     _dY_=caml_new_string(" : "),
     _dU_=caml_new_string("#0:"),
     _dV_=caml_new_string("#1:"),
     _dW_=caml_new_string(", "),
     _dX_=caml_new_string(" : "),
     _dQ_=[0,[12,91,[2,0,[12,93,0]]],caml_new_string("[%s]")],
     _dR_=[0,[12,91,[2,0,[12,93,0]]],caml_new_string("[%s]")],
     _dS_=
      [0,
       [11,
        caml_new_string("[DF tag:"),
        [4,3,0,0,[11,caml_new_string(" ap:"),[2,0,[12,93,0]]]]],
       caml_new_string("[DF tag:%i ap:%s]")],
     _dT_=
      [0,
       [11,
        caml_new_string("[DR tag:"),
        [4,3,0,0,[11,caml_new_string(" ap:"),[2,0,[12,93,0]]]]],
       caml_new_string("[DR tag:%i ap:%s]")],
     _dN_=
      [0,
       [11,caml_new_string("F("),[8,9,0,0,[12,41,0]]],
       caml_new_string("F(%g)")],
     _dO_=
      [0,
       [11,caml_new_string("Arr("),[2,0,[12,41,0]]],
       caml_new_string("Arr(%s)")],
     _dP_=caml_new_string("you should not have reached here!"),
     _dM_=caml_new_string("error: AD.unpack_flt"),
     _dL_=caml_new_string("error: AD.unpack_arr"),
     _dK_=caml_new_string("error: AD.repeat"),
     _dJ_=caml_new_string("error: AD.tile"),
     _dI_=caml_new_string("error: AD.copy"),
     _dH_=caml_new_string("error: AD.clip_by_l2norm"),
     _dG_=caml_new_string("error: AD.clip_by_value"),
     _dF_=caml_new_string("error: AD.numel"),
     _dE_=caml_new_string("error: AD.shape"),
     _dD_=caml_new_string("error: no adjval for DF"),
     _dC_=caml_new_string("error: no adjref for DF"),
     _dB_=caml_new_string("error: no tangent for DR"),
     _dy_=[0,0],
     _dz_=caml_new_string("error: reset_zero"),
     _hn_=[0,caml_new_string("src/base/stats/owl_base_stats.ml"),9,2],
     _hr_=caml_new_string("_div: unsupported operation"),
     _hq_=caml_new_string("_mul_elt: unsupported operation"),
     _hp_=caml_new_string("_sub_elt: unsupported operation"),
     _ho_=caml_new_string("_add_elt: unsupported operation"),
     _hE_=[0,[2,0,0],caml_new_string("%s")],
     _hB_=caml_new_string("\n"),
     _hD_=caml_new_string(" "),
     _hC_=caml_new_string("\n"),
     _hA_=caml_new_string(""),
     _hz_=caml_new_string("..."),
     _hy_=caml_new_string(""),
     _hx_=[0,[2,0,[4,3,0,0,0]],caml_new_string("%s%i")],
     _hw_=caml_new_string(""),
     _hu_=[0,caml_new_string("]")],
     _hv_=[0,caml_new_string("[")],
     _hs_=caml_new_string(""),
     _ht_=[0,[2,0,[2,0,0]],caml_new_string("%s%s")],
     _i__=caml_new_string("no inverse - the matrix is not square"),
     _i$_=caml_new_string("the matrix does not have an inverse"),
     _i9_=caml_new_string("Argument is not a square matrix"),
     _i8_=caml_new_string("Matrices cannot be multipled"),
     _i7_=caml_new_string("Vector is not a column vector"),
     _i6_=
      caml_new_string
       ("Column vector does not have the same length as the number of rows in the matrix"),
     _i5_=caml_new_string("The given NDarray is not a matrix!"),
     _i4_=[0,1,0],
     _i3_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       2250,
       2],
     _i2_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       2251,
       2],
     _i1_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       2252,
       2],
     _i0_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       2219,
       2],
     _iZ_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       2220,
       2],
     _iY_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       2221,
       2],
     _iX_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       2098,
       2],
     _iW_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       2099,
       2],
     _iV_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       2100,
       2],
     _iU_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       2121,
       2],
     _iT_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       2122,
       2],
     _iS_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1993,
       2],
     _iR_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1994,
       2],
     _iQ_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1995,
       2],
     _iP_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       2012,
       2],
     _iO_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       2013,
       2],
     _iN_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1913,
       2],
     _iM_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1914,
       2],
     _iL_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1915,
       2],
     _iK_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1916,
       2],
     _iJ_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1930,
       2],
     _iI_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1936,
       2],
     _iH_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1937,
       2],
     _iG_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1830,
       2],
     _iF_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1831,
       2],
     _iE_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1832,
       2],
     _iD_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1833,
       2],
     _iC_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1847,
       2],
     _iB_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1853,
       2],
     _iA_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1854,
       2],
     _iz_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1793,
       2],
     _iy_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1794,
       2],
     _ix_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1795,
       2],
     _iw_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1796,
       2],
     _iv_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1808,
       2],
     _iu_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1814,
       2],
     _it_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1815,
       2],
     _is_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1757,
       2],
     _ir_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1758,
       2],
     _iq_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1759,
       2],
     _ip_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1760,
       2],
     _io_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1772,
       2],
     _in_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1778,
       2],
     _im_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1779,
       2],
     _il_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1692,
       2],
     _ik_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1693,
       2],
     _ij_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1694,
       2],
     _ii_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1695,
       2],
     _ih_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1707,
       2],
     _ig_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1712,
       2],
     _if_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1713,
       2],
     _ie_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1623,
       2],
     _id_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1624,
       2],
     _ic_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1625,
       2],
     _ib_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1626,
       2],
     _ia_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1638,
       2],
     _h$_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1643,
       2],
     _h__=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1644,
       2],
     _h9_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1584,
       2],
     _h8_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1585,
       2],
     _h7_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1586,
       2],
     _h6_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1529,
       2],
     _h5_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1530,
       2],
     _h4_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1531,
       2],
     _h3_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1439,
       2],
     _h2_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1440,
       2],
     _h1_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1441,
       2],
     _h0_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1383,
       2],
     _hZ_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1384,
       2],
     _hY_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1385,
       2],
     _hX_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1303,
       4],
     _hW_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1304,
       4],
     _hV_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1305,
       4],
     _hU_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1319,
       4],
     _hT_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1270,
       2],
     _hS_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1271,
       2],
     _hR_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1272,
       2],
     _hQ_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1283,
       2],
     _hP_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1201,
       2],
     _hO_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1202,
       2],
     _hN_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1203,
       2],
     _hM_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       1215,
       2],
     _hL_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       364,
       2],
     _hK_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       304,
       2],
     _hJ_=caml_new_string("incorrect slice definition"),
     _hI_=
      [0,
       caml_new_string("src/base/dense/owl_base_dense_ndarray_generic.ml"),
       121,
       4],
     _hH_=
      caml_new_string
       ("cannot draw that many samples from the given range, without replacement"),
     _hG_=caml_new_string("not broadcasted correctly"),
     _hF_=
      caml_new_string("The arrays cannot be broadcast into the same shape"),
     _je_=[0,[12,10,[10,0]],caml_new_string("\n%!")],
     _jf_=[0,[2,0,0],caml_new_string("%s")],
     _jd_=
      [0,
       [4,
        0,
        [0,2,4],
        0,
        [12,
         45,
         [4,
          0,
          [0,2,2],
          0,
          [12,
           45,
           [4,
            0,
            [0,2,2],
            0,
            [12,32,[4,0,[0,2,2],0,[12,58,[4,0,[0,2,2],0,[12,58,partial$0]]]]]]]]]],
       caml_new_string("%04d-%02d-%02d %02d:%02d:%02d.%03d %s : ")],
     _jc_=caml_new_string("\x1b[0m"),
     _ja_=caml_new_string("\x1b[32m"),
     _nB_=caml_new_string("embedding"),
     _nv_=caml_new_string(""),
     _nw_=
      [0,
       [11,
        caml_new_string("    w         : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    w         : %i x %i\n")],
     _nx_=
      [0,
       [11,caml_new_string("    params    : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    params    : %i\n")],
     _ny_=
      [0,
       [11,caml_new_string("    in_dim    : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    in_dim    : %i\n")],
     _nz_=
      [0,
       [11,caml_new_string("    init      : "),[2,0,[12,10,0]]],
       caml_new_string("    init      : %s\n")],
     _nA_=
      [0,
       [11,
        caml_new_string("    Embedding : matrix in:(*,"),
        [4,
         3,
         0,
         0,
         [11,
          caml_new_string(") out:(*,"),
          [4,3,0,0,[12,44,[4,3,0,0,[11,caml_new_string(") \n"),0]]]]]]],
       caml_new_string("    Embedding : matrix in:(*,%i) out:(*,%i,%i) \n")],
     _nu_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),2230,6],
     _nt_=caml_new_string("alpha_dropout"),
     _nr_=
      [0,
       [11,caml_new_string("    rate         : "),[8,9,0,0,[12,10,0]]],
       caml_new_string("    rate         : %g\n")],
     _ns_=
      [0,
       [11,
        caml_new_string("    AlphaDropout : in:[*,"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    AlphaDropout : in:[*,%s] out:[*,%s]\n")],
     _np_=caml_new_string("owl_neural_neuron:alphadropout:run"),
     _nq_=[0,1],
     _no_=caml_new_string("gaussian_dropout"),
     _nm_=
      [0,
       [11,caml_new_string("    rate            : "),[8,9,0,0,[12,10,0]]],
       caml_new_string("    rate            : %g\n")],
     _nn_=
      [0,
       [11,
        caml_new_string("    GaussianDropout : in:[*,"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    GaussianDropout : in:[*,%s] out:[*,%s]\n")],
     _nk_=caml_new_string("owl_neural_neuron:gaussiandropout:run"),
     _nl_=[0,1],
     _nj_=caml_new_string("gaussian_noise"),
     _nh_=
      [0,
       [11,caml_new_string("    sigma         : "),[8,9,0,0,[12,10,0]]],
       caml_new_string("    sigma         : %g\n")],
     _ni_=
      [0,
       [11,
        caml_new_string("    GaussianNoise : in:[*,"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    GaussianNoise : in:[*,%s] out:[*,%s]\n")],
     _ng_=caml_new_string("owl_neural_neuron:gaussiannoise:run"),
     _nf_=caml_new_string("normalisation"),
     _m__=
      [0,
       [11,
        caml_new_string("    gamma         : ["),
        [2,0,[11,caml_new_string("]\n"),0]]],
       caml_new_string("    gamma         : [%s]\n")],
     _m$_=
      [0,
       [11,
        caml_new_string("    beta          : ["),
        [2,0,[11,caml_new_string("]\n"),0]]],
       caml_new_string("    beta          : [%s]\n")],
     _na_=
      [0,
       [11,caml_new_string("    params        : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    params        : %i\n")],
     _nb_=
      [0,
       [11,caml_new_string("    decay         : "),[8,9,0,0,[12,10,0]]],
       caml_new_string("    decay         : %g\n")],
     _nc_=
      [0,
       [11,caml_new_string("    axis          : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    axis          : %i\n")],
     _nd_=
      [0,
       [11,caml_new_string("    training      : "),[9,0,[12,10,0]]],
       caml_new_string("    training      : %b\n")],
     _ne_=
      [0,
       [11,
        caml_new_string("    Normalisation : in:[*,"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    Normalisation : in:[*,%s] out:[*,%s]\n")],
     _m7_=[0,1],
     _m8_=[0,1],
     _m9_=[0,1e-08],
     _m6_=caml_new_string("concatenate"),
     _m2_=caml_new_string("*"),
     _m3_=caml_new_string(""),
     _m4_=
      [0,
       [11,caml_new_string("    axis : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    axis : %i\n")],
     _m5_=
      [0,
       [11,
        caml_new_string("    Concatenate : in:[*,"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    Concatenate : in:[*,%s] out:[*,%s]\n")],
     _m1_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1961,6],
     _mZ_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1945,36],
     _m0_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1952,6],
     _mY_=caml_new_string("average"),
     _mX_=
      [0,
       [11,
        caml_new_string("    Average : in:[*,"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    Average : in:[*,%s] out:[*,%s]\n")],
     _mW_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1908,6],
     _mV_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1899,27],
     _mU_=caml_new_string("max"),
     _mT_=
      [0,
       [11,
        caml_new_string("    Max : in:[*,"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    Max : in:[*,%s] out:[*,%s]\n")],
     _mS_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1868,6],
     _mR_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1859,27],
     _mQ_=caml_new_string("dot"),
     _mP_=
      [0,
       [11,
        caml_new_string("    Dot : in:[*,"),
        [4,
         3,
         0,
         0,
         [11,
          caml_new_string("] ["),
          [4,
           3,
           0,
           0,
           [12,
            44,
            [4,
             3,
             0,
             0,
             [11,
              caml_new_string("] out:[*,"),
              [4,3,0,0,[11,caml_new_string("]\n"),0]]]]]]]]],
       caml_new_string("    Dot : in:[*,%i] [%i,%i] out:[*,%i]\n")],
     _mO_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1832,6],
     _mN_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1825,6],
     _mM_=caml_new_string("mul"),
     _mL_=
      [0,
       [11,
        caml_new_string("    Multiply : in:[*,"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    Multiply : in:[*,%s] out:[*,%s]\n")],
     _mK_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1791,6],
     _mJ_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1782,27],
     _mI_=caml_new_string("add"),
     _mH_=
      [0,
       [11,
        caml_new_string("    Add : in:[*,"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    Add : in:[*,%s] out:[*,%s]\n")],
     _mG_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1751,6],
     _mF_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1742,27],
     _mE_=caml_new_string("flatten"),
     _mD_=
      [0,
       [11,
        caml_new_string("    Flatten : in:[*,"),
        [2,
         0,
         [11,
          caml_new_string("] out:[*,"),
          [4,3,0,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    Flatten : in:[*,%s] out:[*,%i]\n")],
     _mC_=caml_new_string("reshape"),
     _mB_=
      [0,
       [11,
        caml_new_string("    Reshape : in:[*,"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    Reshape : in:[*,%s] out:[*,%s]\n")],
     _mA_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1677,6],
     _mz_=caml_new_string("dropout"),
     _mx_=
      [0,
       [11,caml_new_string("    rate    : "),[8,9,0,0,[12,10,0]]],
       caml_new_string("    rate    : %g\n")],
     _my_=
      [0,
       [11,
        caml_new_string("    Dropout : in:[*,"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    Dropout : in:[*,%s] out:[*,%s]\n")],
     _mw_=caml_new_string("lambda"),
     _mt_=caml_new_string(""),
     _mu_=
      [0,
       [11,caml_new_string("    customised f : t -> t\n"),0],
       caml_new_string("    customised f : t -> t\n")],
     _mv_=
      [0,
       [11,
        caml_new_string("    Lambda       : in:[*,"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    Lambda       : in:[*,%s] out:[*,%s]\n")],
     _ms_=caml_new_string("global_avgpool2d"),
     _mq_=caml_new_string(""),
     _mr_=
      [0,
       [11,
        caml_new_string("    GlobalAvgPool2D : in:[*,"),
        [4,
         3,
         0,
         0,
         [12,
          44,
          [4,
           3,
           0,
           0,
           [12,
            44,
            [4,
             3,
             0,
             0,
             [11,
              caml_new_string("] out:[*,"),
              [4,3,0,0,[11,caml_new_string("]\n"),0]]]]]]]]],
       caml_new_string("    GlobalAvgPool2D : in:[*,%i,%i,%i] out:[*,%i]\n")],
     _mp_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1524,6],
     _mo_=caml_new_string("global_avgpool1d"),
     _mm_=caml_new_string(""),
     _mn_=
      [0,
       [11,
        caml_new_string("    GlobalAvgPool1D : in:[*,"),
        [4,
         3,
         0,
         0,
         [12,
          44,
          [4,
           3,
           0,
           0,
           [11,
            caml_new_string("] out:[*,"),
            [4,3,0,0,[11,caml_new_string("]\n"),0]]]]]]],
       caml_new_string("    GlobalAvgPool1D : in:[*,%i,%i] out:[*,%i]\n")],
     _ml_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1487,6],
     _mk_=caml_new_string("global_maxpool2d"),
     _mi_=caml_new_string(""),
     _mj_=
      [0,
       [11,
        caml_new_string("    GlobalMaxPool2D : in:[*,"),
        [4,
         3,
         0,
         0,
         [12,
          44,
          [4,
           3,
           0,
           0,
           [12,
            44,
            [4,
             3,
             0,
             0,
             [11,
              caml_new_string("] out:[*,"),
              [4,3,0,0,[11,caml_new_string("]\n"),0]]]]]]]]],
       caml_new_string("    GlobalMaxPool2D : in:[*,%i,%i,%i] out:[*,%i]\n")],
     _mh_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1449,6],
     _mg_=caml_new_string("global_maxpool1d"),
     _me_=caml_new_string(""),
     _mf_=
      [0,
       [11,
        caml_new_string("    GlobalMaxPool1D : in:[*,"),
        [4,
         3,
         0,
         0,
         [12,
          44,
          [4,
           3,
           0,
           0,
           [11,
            caml_new_string("] out:[*,"),
            [4,3,0,0,[11,caml_new_string("]\n"),0]]]]]]],
       caml_new_string("    GlobalMaxPool1D : in:[*,%i,%i] out:[*,%i]\n")],
     _md_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1412,6],
     _mc_=caml_new_string("avgpool2d"),
     _mb_=caml_new_string("VALID"),
     _l7_=caml_new_string("SAME"),
     _l8_=caml_new_string(""),
     _l9_=
      [0,
       [11,
        caml_new_string("    stride    : ["),
        [4,
         3,
         0,
         0,
         [11,caml_new_string("; "),[4,3,0,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    stride    : [%i; %i]\n")],
     _l__=
      [0,
       [11,
        caml_new_string("    kernel    : ["),
        [4,
         3,
         0,
         0,
         [11,caml_new_string("; "),[4,3,0,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    kernel    : [%i; %i]\n")],
     _l$_=
      [0,
       [11,caml_new_string("    padding   : "),[2,0,[12,10,0]]],
       caml_new_string("    padding   : %s\n")],
     _ma_=
      [0,
       [11,
        caml_new_string("    AvgPool2D : tensor in:[*,"),
        [4,
         3,
         0,
         0,
         [12,
          44,
          [4,
           3,
           0,
           0,
           [12,
            44,
            [4,
             3,
             0,
             0,
             [11,
              caml_new_string("] out:[*,"),
              [4,3,0,0,[12,44,[4,3,0,0,partial$1]]]]]]]]]],
       caml_new_string
        ("    AvgPool2D : tensor in:[*,%i,%i,%i] out:[*,%i,%i,%i]\n")],
     _l6_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1367,6],
     _l5_=caml_new_string("avgpool1d"),
     _l4_=caml_new_string("VALID"),
     _lY_=caml_new_string("SAME"),
     _lZ_=caml_new_string(""),
     _l0_=
      [0,
       [11,
        caml_new_string("    stride    : ["),
        [4,3,0,0,[11,caml_new_string("]\n"),0]]],
       caml_new_string("    stride    : [%i]\n")],
     _l1_=
      [0,
       [11,
        caml_new_string("    kernel    : ["),
        [4,3,0,0,[11,caml_new_string("]\n"),0]]],
       caml_new_string("    kernel    : [%i]\n")],
     _l2_=
      [0,
       [11,caml_new_string("    padding   : "),[2,0,[12,10,0]]],
       caml_new_string("    padding   : %s\n")],
     _l3_=
      [0,
       [11,
        caml_new_string("    AvgPool1D : tensor in:[*,"),
        [4,
         3,
         0,
         0,
         [12,
          44,
          [4,
           3,
           0,
           0,
           [11,
            caml_new_string("] out:[*,"),
            [4,3,0,0,[12,44,[4,3,0,0,[11,caml_new_string("]\n"),0]]]]]]]]],
       caml_new_string("    AvgPool1D : tensor in:[*,%i,%i] out:[*,%i,%i]\n")],
     _lX_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1318,6],
     _lW_=caml_new_string("maxpool2d"),
     _lV_=caml_new_string("VALID"),
     _lP_=caml_new_string("SAME"),
     _lQ_=caml_new_string(""),
     _lR_=
      [0,
       [11,
        caml_new_string("    stride    : ["),
        [4,
         3,
         0,
         0,
         [11,caml_new_string("; "),[4,3,0,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    stride    : [%i; %i]\n")],
     _lS_=
      [0,
       [11,
        caml_new_string("    kernel    : ["),
        [4,
         3,
         0,
         0,
         [11,caml_new_string("; "),[4,3,0,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    kernel    : [%i; %i]\n")],
     _lT_=
      [0,
       [11,caml_new_string("    padding   : "),[2,0,[12,10,0]]],
       caml_new_string("    padding   : %s\n")],
     _lU_=
      [0,
       [11,
        caml_new_string("    MaxPool2D : tensor in:[*,"),
        [4,
         3,
         0,
         0,
         [12,
          44,
          [4,
           3,
           0,
           0,
           [12,
            44,
            [4,
             3,
             0,
             0,
             [11,
              caml_new_string("] out:[*,"),
              [4,3,0,0,[12,44,[4,3,0,0,partial$2]]]]]]]]]],
       caml_new_string
        ("    MaxPool2D : tensor in:[*,%i,%i,%i] out:[*,%i,%i,%i]\n")],
     _lO_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1267,6],
     _lN_=caml_new_string("maxpool1d"),
     _lM_=caml_new_string("VALID"),
     _lG_=caml_new_string("SAME"),
     _lH_=caml_new_string(""),
     _lI_=
      [0,
       [11,
        caml_new_string("    stride    : ["),
        [4,3,0,0,[11,caml_new_string("]\n"),0]]],
       caml_new_string("    stride    : [%i]\n")],
     _lJ_=
      [0,
       [11,
        caml_new_string("    kernel    : ["),
        [4,3,0,0,[11,caml_new_string("]\n"),0]]],
       caml_new_string("    kernel    : [%i]\n")],
     _lK_=
      [0,
       [11,caml_new_string("    padding   : "),[2,0,[12,10,0]]],
       caml_new_string("    padding   : %s\n")],
     _lL_=
      [0,
       [11,
        caml_new_string("    MaxPool1D : tensor in:[*,"),
        [4,
         3,
         0,
         0,
         [12,
          44,
          [4,
           3,
           0,
           0,
           [11,
            caml_new_string("] out:[*,"),
            [4,3,0,0,[12,44,[4,3,0,0,[11,caml_new_string("]\n"),0]]]]]]]]],
       caml_new_string("    MaxPool1D : tensor in:[*,%i,%i] out:[*,%i,%i]\n")],
     _lF_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1218,6],
     _lE_=caml_new_string("fullyconnected"),
     _ly_=caml_new_string(""),
     _lz_=
      [0,
       [11,
        caml_new_string("    b              : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    b              : %i x %i\n")],
     _lA_=
      [0,
       [11,
        caml_new_string("    w              : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    w              : %i x %i\n")],
     _lB_=
      [0,
       [11,caml_new_string("    params         : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    params         : %i\n")],
     _lC_=
      [0,
       [11,caml_new_string("    init           : "),[2,0,[12,10,0]]],
       caml_new_string("    init           : %s\n")],
     _lD_=
      [0,
       [11,
        caml_new_string("    FullyConnected : tensor in:[*,"),
        [2,
         0,
         [11,
          caml_new_string("] matrix out:(*,"),
          [4,3,0,0,[11,caml_new_string(")\n"),0]]]]],
       caml_new_string
        ("    FullyConnected : tensor in:[*,%s] matrix out:(*,%i)\n")],
     _lx_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1142,6],
     _lw_=caml_new_string("conv3d"),
     _lp_=caml_new_string(""),
     _lq_=
      [0,
       [11,
        caml_new_string("    stride : ["),
        [4,
         3,
         0,
         0,
         [11,
          caml_new_string("; "),
          [4,
           3,
           0,
           0,
           [11,caml_new_string("; "),[4,3,0,0,[11,caml_new_string("]\n"),0]]]]]]],
       caml_new_string("    stride : [%i; %i; %i]\n")],
     _lr_=
      [0,
       [11,caml_new_string("    b      : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    b      : %i\n")],
     _ls_=
      [0,
       [11,
        caml_new_string("    kernel : "),
        [4,
         3,
         0,
         0,
         [11,
          caml_new_string(" x "),
          [4,
           3,
           0,
           0,
           [11,
            caml_new_string(" x "),
            [4,
             3,
             0,
             0,
             [11,
              caml_new_string(" x "),
              [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,partial$3]]]]]]]]]],
       caml_new_string("    kernel : %i x %i x %i x %i x %i\n")],
     _lt_=
      [0,
       [11,caml_new_string("    params : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    params : %i\n")],
     _lu_=
      [0,
       [11,caml_new_string("    init   : "),[2,0,[12,10,0]]],
       caml_new_string("    init   : %s\n")],
     _lv_=
      [0,
       [11,
        caml_new_string("    Conv3D : tensor in:[*;"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    Conv3D : tensor in:[*;%s] out:[*,%s]\n")],
     _lo_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1055,6],
     _ln_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1056,6],
     _lm_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),1040,20],
     _ll_=caml_new_string("conv2d"),
     _le_=caml_new_string(""),
     _lf_=
      [0,
       [11,
        caml_new_string("    stride : ["),
        [4,
         3,
         0,
         0,
         [11,caml_new_string("; "),[4,3,0,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    stride : [%i; %i]\n")],
     _lg_=
      [0,
       [11,caml_new_string("    b      : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    b      : %i\n")],
     _lh_=
      [0,
       [11,
        caml_new_string("    kernel : "),
        [4,
         3,
         0,
         0,
         [11,
          caml_new_string(" x "),
          [4,
           3,
           0,
           0,
           [11,
            caml_new_string(" x "),
            [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]]]]]],
       caml_new_string("    kernel : %i x %i x %i x %i\n")],
     _li_=
      [0,
       [11,caml_new_string("    params : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    params : %i\n")],
     _lj_=
      [0,
       [11,caml_new_string("    init   : "),[2,0,[12,10,0]]],
       caml_new_string("    init   : %s\n")],
     _lk_=
      [0,
       [11,
        caml_new_string("    Conv2D : tensor in:[*;"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    Conv2D : tensor in:[*;%s] out:[*,%s]\n")],
     _ld_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),964,6],
     _lc_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),965,6],
     _lb_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),949,20],
     _la_=caml_new_string("conv1d"),
     _k5_=caml_new_string(""),
     _k6_=
      [0,
       [11,
        caml_new_string("    stride : ["),
        [4,3,0,0,[11,caml_new_string("]\n"),0]]],
       caml_new_string("    stride : [%i]\n")],
     _k7_=
      [0,
       [11,caml_new_string("    b      : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    b      : %i\n")],
     _k8_=
      [0,
       [11,
        caml_new_string("    kernel : "),
        [4,
         3,
         0,
         0,
         [11,
          caml_new_string(" x "),
          [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]]]],
       caml_new_string("    kernel : %i x %i x %i\n")],
     _k9_=
      [0,
       [11,caml_new_string("    params : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    params : %i\n")],
     _k__=
      [0,
       [11,caml_new_string("    init   : "),[2,0,[12,10,0]]],
       caml_new_string("    init   : %s\n")],
     _k$_=
      [0,
       [11,
        caml_new_string("    Conv1D : tensor in:[*;"),
        [2,
         0,
         [11,caml_new_string("] out:[*,"),[2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    Conv1D : tensor in:[*;%s] out:[*,%s]\n")],
     _k4_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),876,6],
     _k3_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),877,6],
     _k2_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),861,20],
     _k1_=caml_new_string("gru"),
     _kO_=caml_new_string(""),
     _kP_=
      [0,
       [11,
        caml_new_string("    bh     : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    bh     : %i x %i\n")],
     _kQ_=
      [0,
       [11,
        caml_new_string("    br     : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    br     : %i x %i\n")],
     _kR_=
      [0,
       [11,
        caml_new_string("    bz     : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    bz     : %i x %i\n")],
     _kS_=
      [0,
       [11,
        caml_new_string("    whh    : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    whh    : %i x %i\n")],
     _kT_=
      [0,
       [11,
        caml_new_string("    wxh    : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    wxh    : %i x %i\n")],
     _kU_=
      [0,
       [11,
        caml_new_string("    whr    : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    whr    : %i x %i\n")],
     _kV_=
      [0,
       [11,
        caml_new_string("    wxr    : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    wxr    : %i x %i\n")],
     _kW_=
      [0,
       [11,
        caml_new_string("    whz    : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    whz    : %i x %i\n")],
     _kX_=
      [0,
       [11,
        caml_new_string("    wxz    : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    wxz    : %i x %i\n")],
     _kY_=
      [0,
       [11,caml_new_string("    params : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    params : %i\n")],
     _kZ_=
      [0,
       [11,caml_new_string("    init   : "),[2,0,[12,10,0]]],
       caml_new_string("    init   : %s\n")],
     _k0_=
      [0,
       [11,
        caml_new_string("    GRU    : matrix in:(*,"),
        [4,
         3,
         0,
         0,
         [12,
          44,
          [4,
           3,
           0,
           0,
           [11,
            caml_new_string(") out:(*,"),
            [4,3,0,0,[11,caml_new_string(") \n"),0]]]]]]],
       caml_new_string("    GRU    : matrix in:(*,%i,%i) out:(*,%i) \n")],
     _kM_=[0,0,0],
     _kN_=[0,1],
     _kL_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),716,6],
     _kK_=caml_new_string("lstm"),
     _ku_=caml_new_string(""),
     _kv_=
      [0,
       [11,
        caml_new_string("    bo     : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    bo     : %i x %i\n")],
     _kw_=
      [0,
       [11,
        caml_new_string("    bf     : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    bf     : %i x %i\n")],
     _kx_=
      [0,
       [11,
        caml_new_string("    bc     : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    bc     : %i x %i\n")],
     _ky_=
      [0,
       [11,
        caml_new_string("    bi     : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    bi     : %i x %i\n")],
     _kz_=
      [0,
       [11,
        caml_new_string("    who    : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    who    : %i x %i\n")],
     _kA_=
      [0,
       [11,
        caml_new_string("    wxo    : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    wxo    : %i x %i\n")],
     _kB_=
      [0,
       [11,
        caml_new_string("    whf    : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    whf    : %i x %i\n")],
     _kC_=
      [0,
       [11,
        caml_new_string("    wxf    : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    wxf    : %i x %i\n")],
     _kD_=
      [0,
       [11,
        caml_new_string("    whc    : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    whc    : %i x %i\n")],
     _kE_=
      [0,
       [11,
        caml_new_string("    wxc    : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    wxc    : %i x %i\n")],
     _kF_=
      [0,
       [11,
        caml_new_string("    whi    : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    whi    : %i x %i\n")],
     _kG_=
      [0,
       [11,
        caml_new_string("    wxi    : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    wxi    : %i x %i\n")],
     _kH_=
      [0,
       [11,caml_new_string("    params : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    params : %i\n")],
     _kI_=
      [0,
       [11,caml_new_string("    init   : "),[2,0,[12,10,0]]],
       caml_new_string("    init   : %s\n")],
     _kJ_=
      [0,
       [11,
        caml_new_string("    LSTM   : in:(*,"),
        [4,
         3,
         0,
         0,
         [12,
          44,
          [4,
           3,
           0,
           0,
           [11,
            caml_new_string(") out:(*,"),
            [4,3,0,0,[11,caml_new_string(") \n"),0]]]]]]],
       caml_new_string("    LSTM   : in:(*,%i,%i) out:(*,%i) \n")],
     _kt_=[0,0,0],
     _ks_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),522,6],
     _kr_=caml_new_string("recurrent"),
     _ki_=
      [0,
       [11,caml_new_string("    act       : "),[2,0,[12,10,0]]],
       caml_new_string("    act       : %s\n")],
     _kj_=
      [0,
       [11,
        caml_new_string("    by        : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    by        : %i x %i\n")],
     _kk_=
      [0,
       [11,
        caml_new_string("    bh        : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    bh        : %i x %i\n")],
     _kl_=
      [0,
       [11,
        caml_new_string("    why       : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    why       : %i x %i\n")],
     _km_=
      [0,
       [11,
        caml_new_string("    wxh       : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    wxh       : %i x %i\n")],
     _kn_=
      [0,
       [11,
        caml_new_string("    whh       : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    whh       : %i x %i\n")],
     _ko_=
      [0,
       [11,caml_new_string("    params    : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    params    : %i\n")],
     _kp_=
      [0,
       [11,caml_new_string("    init      : "),[2,0,[12,10,0]]],
       caml_new_string("    init      : %s\n")],
     _kq_=
      [0,
       [11,
        caml_new_string("    Recurrent : matrix in:(*,"),
        [4,
         3,
         0,
         0,
         [12,
          44,
          [4,
           3,
           0,
           0,
           [11,
            caml_new_string(") out:(*,"),
            [4,3,0,0,[11,caml_new_string(") \n"),0]]]]]]],
       caml_new_string("    Recurrent : matrix in:(*,%i,%i) out:(*,%i) \n")],
     _kh_=[0,0,0],
     _kg_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),379,6],
     _kf_=caml_new_string("linearnobias"),
     _ka_=caml_new_string(""),
     _kb_=
      [0,
       [11,
        caml_new_string("    w            : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    w            : %i x %i\n")],
     _kc_=
      [0,
       [11,caml_new_string("    params       : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    params       : %i\n")],
     _kd_=
      [0,
       [11,caml_new_string("    init         : "),[2,0,[12,10,0]]],
       caml_new_string("    init         : %s\n")],
     _ke_=
      [0,
       [11,
        caml_new_string("    LinearNoBias : matrix in:(*,"),
        [4,
         3,
         0,
         0,
         [11,
          caml_new_string(") out:(*,"),
          [4,3,0,0,[11,caml_new_string(") \n"),0]]]]],
       caml_new_string("    LinearNoBias : matrix in:(*,%i) out:(*,%i) \n")],
     _j$_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),303,6],
     _j__=caml_new_string("linear"),
     _j4_=caml_new_string(""),
     _j5_=
      [0,
       [11,
        caml_new_string("    b      : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    b      : %i x %i\n")],
     _j6_=
      [0,
       [11,
        caml_new_string("    w      : "),
        [4,3,0,0,[11,caml_new_string(" x "),[4,3,0,0,[12,10,0]]]]],
       caml_new_string("    w      : %i x %i\n")],
     _j7_=
      [0,
       [11,caml_new_string("    params : "),[4,3,0,0,[12,10,0]]],
       caml_new_string("    params : %i\n")],
     _j8_=
      [0,
       [11,caml_new_string("    init   : "),[2,0,[12,10,0]]],
       caml_new_string("    init   : %s\n")],
     _j9_=
      [0,
       [11,
        caml_new_string("    Linear : matrix in:(*,"),
        [4,
         3,
         0,
         0,
         [11,
          caml_new_string(") out:(*,"),
          [4,3,0,0,[11,caml_new_string(") \n"),0]]]]],
       caml_new_string("    Linear : matrix in:(*,%i) out:(*,%i) \n")],
     _j3_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),231,6],
     _j2_=caml_new_string("activation"),
     _j0_=caml_new_string(""),
     _j1_=
      [0,
       [11,
        caml_new_string("    Activation : "),
        [2,
         0,
         [11,
          caml_new_string(" in/out:[*,"),
          [2,0,[11,caml_new_string("]\n"),0]]]]],
       caml_new_string("    Activation : %s in/out:[*,%s]\n")],
     _jA_=caml_new_string("elu"),
     _jB_=[0,[2,0,0],caml_new_string("%s")],
     _jC_=caml_new_string("relu"),
     _jD_=[0,[2,0,0],caml_new_string("%s")],
     _jE_=caml_new_string("sigmoid"),
     _jF_=[0,[2,0,0],caml_new_string("%s")],
     _jG_=caml_new_string("hard_sigmoid"),
     _jH_=[0,[2,0,0],caml_new_string("%s")],
     _jI_=caml_new_string("softmax"),
     _jJ_=[0,[2,0,0],caml_new_string("%s")],
     _jK_=caml_new_string("softplus"),
     _jL_=[0,[2,0,0],caml_new_string("%s")],
     _jM_=caml_new_string("softsign"),
     _jN_=[0,[2,0,0],caml_new_string("%s")],
     _jO_=caml_new_string("tanh"),
     _jP_=[0,[2,0,0],caml_new_string("%s")],
     _jQ_=caml_new_string("relu6"),
     _jR_=[0,[2,0,0],caml_new_string("%s")],
     _jS_=caml_new_string("none"),
     _jT_=[0,[2,0,0],caml_new_string("%s")],
     _jU_=caml_new_string("leaky_relu"),
     _jV_=[0,[2,0,[12,32,[8,9,0,0,0]]],caml_new_string("%s %g")],
     _jW_=caml_new_string("threshold_relu"),
     _jX_=[0,[2,0,[12,32,[8,9,0,0,0]]],caml_new_string("%s %g")],
     _jY_=caml_new_string("customise"),
     _jZ_=[0,[2,0,0],caml_new_string("%s")],
     _ju_=[0,1],
     _jv_=[0,0.5],
     _jw_=[0,0.2],
     _jx_=[0,1],
     _jy_=[0,0],
     _jz_=[0,6],
     _jt_=caml_new_string("input"),
     _js_=
      [0,
       [11,
        caml_new_string("    Input : in/out:[*,"),
        [2,0,[11,caml_new_string("]\n"),0]]],
       caml_new_string("    Input : in/out:[*,%s]\n")],
     _jq_=caml_new_string("Owl_neural:Input:run:check_shape"),
     _jr_=[0,caml_new_string("src/base/neural/owl_neural_neuron.ml"),111,12],
     _jp_=caml_new_string("init"),
     _jh_=[0,[11,caml_new_string("standard"),0],caml_new_string("standard")],
     _ji_=[0,[11,caml_new_string("tanh"),0],caml_new_string("tanh")],
     _jj_=
      [0,
       [11,caml_new_string("glorot_normal"),0],
       caml_new_string("glorot_normal")],
     _jk_=
      [0,
       [11,caml_new_string("glorot_uniform"),0],
       caml_new_string("glorot_uniform")],
     _jl_=
      [0,
       [11,caml_new_string("lecun_normal"),0],
       caml_new_string("lecun_normal")],
     _jm_=
      [0,
       [11,
        caml_new_string("uniform ("),
        [8,9,0,0,[11,caml_new_string(", "),[8,9,0,0,[12,41,0]]]]],
       caml_new_string("uniform (%g, %g)")],
     _jn_=
      [0,
       [11,
        caml_new_string("gaussian ("),
        [8,9,0,0,[11,caml_new_string(", "),[8,9,0,0,[12,41,0]]]]],
       caml_new_string("gaussian (%g, %g)")],
     _jo_=[0,[11,caml_new_string("customise"),0],caml_new_string("customise")],
     _jg_=caml_new_string("Owl_neural:init:run"),
     _pn_=[0,0],
     _po_=[0,0],
     _pp_=[0,0],
     _pl_=[0,0],
     _pm_=[0,0],
     _pk_=[0,0],
     _pj_=[0,0],
     _pg_=[0,0],
     _ph_=[0,0],
     _pi_=[0,0],
     _o3_=caml_new_string("---"),
     _o4_=caml_new_string("true"),
     _pf_=caml_new_string("false"),
     _o5_=
      [0,
       [11,caml_new_string("    verbosity      : "),[2,0,[12,10,0]]],
       caml_new_string("    verbosity      : %s\n")],
     _o6_=
      [0,
       [11,caml_new_string("    checkpoint     : "),[2,0,[12,10,0]]],
       caml_new_string("    checkpoint     : %s\n")],
     _o7_=
      [0,
       [11,caml_new_string("    stopping       : "),[2,0,[12,10,0]]],
       caml_new_string("    stopping       : %s\n")],
     _o8_=
      [0,
       [11,caml_new_string("    clipping       : "),[2,0,[12,10,0]]],
       caml_new_string("    clipping       : %s\n")],
     _o9_=
      [0,
       [11,caml_new_string("    momentum       : "),[2,0,[12,10,0]]],
       caml_new_string("    momentum       : %s\n")],
     _o__=
      [0,
       [11,caml_new_string("    regularisation : "),[2,0,[12,10,0]]],
       caml_new_string("    regularisation : %s\n")],
     _o$_=
      [0,
       [11,caml_new_string("    learning rate  : "),[2,0,[12,10,0]]],
       caml_new_string("    learning rate  : %s\n")],
     _pa_=
      [0,
       [11,caml_new_string("    loss           : "),[2,0,[12,10,0]]],
       caml_new_string("    loss           : %s\n")],
     _pb_=
      [0,
       [11,caml_new_string("    method         : "),[2,0,[12,10,0]]],
       caml_new_string("    method         : %s\n")],
     _pc_=
      [0,
       [11,caml_new_string("    batch          : "),[2,0,[12,10,0]]],
       caml_new_string("    batch          : %s\n")],
     _pd_=
      [0,
       [11,caml_new_string("    epochs         : "),[8,9,0,0,[12,10,0]]],
       caml_new_string("    epochs         : %g\n")],
     _pe_=
      [0,
       [11,caml_new_string("--- Training config\n"),0],
       caml_new_string("--- Training config\n")],
     _o1_=[1,0],
     _o2_=[1,100],
     _oX_=[0,[11,caml_new_string("none"),0],caml_new_string("none")],
     _oY_=
      [0,
       [11,
        caml_new_string("per "),
        [4,3,0,0,[11,caml_new_string(" batches"),0]]],
       caml_new_string("per %i batches")],
     _oZ_=
      [0,
       [11,
        caml_new_string("per "),
        [8,9,0,0,[11,caml_new_string(" epochs"),0]]],
       caml_new_string("per %g epochs")],
     _o0_=
      [0,
       [11,caml_new_string("customised f"),0],
       caml_new_string("customised f")],
     _oW_=
      [0,
       [11,
        caml_new_string("--- Training summary\n    Duration: "),
        [2,0,[12,10,0]]],
       caml_new_string("--- Training summary\n    Duration: %s\n")],
     _oS_=caml_new_string("-"),
     _oU_=caml_new_string("\xe2\x96\xb2"),
     _oV_=caml_new_string("\xe2\x96\xbc"),
     _oT_=
      [0,
       [11,
        caml_new_string("T: "),
        [2,
         0,
         [11,
          caml_new_string(" | E: "),
          [8,
           0,
           0,
           [0,1],
           [12,
            47,
            [8,
             9,
             0,
             0,
             [11,
              caml_new_string(" | B: "),
              [4,3,0,0,[12,47,[4,3,0,0,partial$4]]]]]]]]]],
       caml_new_string("T: %s | E: %.1f/%g | B: %i/%i | L: %.6f[%s]")],
     _oP_=caml_new_string("model"),
     _oQ_=
      [0,[2,0,[12,47,[2,0,[12,46,[4,3,0,0,0]]]]],caml_new_string("%s/%s.%i")],
     _oR_=
      [0,
       [11,caml_new_string("checkpoint => "),[2,0,0]],
       caml_new_string("checkpoint => %s")],
     _oJ_=[0,0],
     _oK_=[0,0],
     _oL_=[0,0],
     _oM_=[0,0],
     _oN_=[0,0],
     _oO_=[0,0],
     _oG_=caml_new_string("none"),
     _oH_=
      [0,
       [11,caml_new_string("const (a = "),[8,9,0,0,[12,41,0]]],
       caml_new_string("const (a = %g)")],
     _oI_=
      [0,
       [11,
        caml_new_string("early (s = "),
        [4,3,0,0,[11,caml_new_string(", o = "),[4,3,0,0,[12,41,0]]]]],
       caml_new_string("early (s = %i, o = %i)")],
     _oE_=[0,1e-06],
     _oF_=[1,750,10],
     _oD_=caml_new_string("not implemented"),
     _oA_=caml_new_string("none"),
     _oB_=
      [0,
       [11,caml_new_string("l2norm (threshold = "),[8,9,0,0,[12,41,0]]],
       caml_new_string("l2norm (threshold = %g)")],
     _oC_=
      [0,
       [11,
        caml_new_string("value (min = "),
        [8,9,0,0,[11,caml_new_string(", max = "),[8,9,0,0,[12,41,0]]]]],
       caml_new_string("value (min = %g, max = %g)")],
     _oy_=[0,1],
     _oz_=[1,0,1],
     _ou_=caml_new_string("none"),
     _ov_=
      [0,
       [11,caml_new_string("l1norm (alpha = "),[8,9,0,0,[12,41,0]]],
       caml_new_string("l1norm (alpha = %g)")],
     _ow_=
      [0,
       [11,caml_new_string("l2norm (alhpa = "),[8,9,0,0,[12,41,0]]],
       caml_new_string("l2norm (alhpa = %g)")],
     _ox_=
      [0,
       [11,
        caml_new_string("elastic net (a = "),
        [8,9,0,0,[11,caml_new_string(", b = "),[8,9,0,0,[12,41,0]]]]],
       caml_new_string("elastic net (a = %g, b = %g)")],
     _ot_=[0,0],
     _oq_=[0,[11,caml_new_string("none"),0],caml_new_string("none")],
     _or_=
      [0,
       [11,caml_new_string("standard "),[8,9,0,0,0]],
       caml_new_string("standard %g")],
     _os_=
      [0,
       [11,caml_new_string("nesterov "),[8,9,0,0,0]],
       caml_new_string("nesterov %g")],
     _oo_=[0,0.9],
     _op_=[1,0.9],
     _on_=[0,1],
     _og_=caml_new_string("gradient descent"),
     _oh_=caml_new_string("conjugate gradient"),
     _oi_=caml_new_string("conjugate descent"),
     _oj_=caml_new_string("nonlinear conjugate gradient"),
     _ok_=caml_new_string("dai & yuan conjugate gradient"),
     _ol_=caml_new_string("newton conjugate gradient"),
     _om_=caml_new_string("newton"),
     _of_=[0,1e-32],
     _n$_=caml_new_string("Hinge"),
     _oa_=caml_new_string("l1norm"),
     _ob_=caml_new_string("l2norm"),
     _oc_=caml_new_string("quadratic"),
     _od_=caml_new_string("cross_entropy"),
     _oe_=caml_new_string("customise"),
     _n9_=[0,1],
     _n__=[0,0],
     _n3_=caml_new_string("full"),
     _n4_=[0,[2,0,0],caml_new_string("%s")],
     _n5_=caml_new_string("stochastic"),
     _n6_=[0,[2,0,0],caml_new_string("%s")],
     _n7_=
      [0,
       [11,caml_new_string("mini of "),[4,3,0,0,0]],
       caml_new_string("mini of %i")],
     _n8_=
      [0,
       [11,caml_new_string("sample of "),[4,3,0,0,0]],
       caml_new_string("sample of %i")],
     _nW_=
      [0,
       [11,caml_new_string("adagrad "),[8,9,0,0,0]],
       caml_new_string("adagrad %g")],
     _nX_=
      [0,
       [11,caml_new_string("constant "),[8,9,0,0,0]],
       caml_new_string("constant %g")],
     _nY_=
      [0,
       [11,
        caml_new_string("decay ("),
        [8,9,0,0,[11,caml_new_string(", "),[8,9,0,0,[12,41,0]]]]],
       caml_new_string("decay (%g, %g)")],
     _nZ_=
      [0,
       [11,
        caml_new_string("exp_decay ("),
        [8,9,0,0,[11,caml_new_string(", "),[8,9,0,0,[12,41,0]]]]],
       caml_new_string("exp_decay (%g, %g)")],
     _n0_=
      [0,
       [11,
        caml_new_string("rmsprop ("),
        [8,9,0,0,[11,caml_new_string(", "),[8,9,0,0,[12,41,0]]]]],
       caml_new_string("rmsprop (%g, %g)")],
     _n1_=
      [0,
       [11,
        caml_new_string("adam ("),
        [8,
         9,
         0,
         0,
         [11,
          caml_new_string(", "),
          [8,9,0,0,[11,caml_new_string(", "),[8,9,0,0,[12,41,0]]]]]]],
       caml_new_string("adam (%g, %g, %g)")],
     _n2_=
      [0,
       [11,caml_new_string("schedule "),[4,3,0,0,0]],
       caml_new_string("schedule %i")],
     _nT_=[0,1],
     _nU_=[0,1],
     _nV_=[0,1],
     _nN_=[0,0.01],
     _nO_=[1,0.001],
     _nP_=[2,0.1,0.1],
     _nQ_=[3,1,0.1],
     _nR_=[4,0.001,0.9],
     _nS_=[5,0.001,0.9,0.999],
     _nJ_=[0,1e-32],
     _nK_=[0,1e-08],
     _nL_=[0,1],
     _nM_=[0,1],
     _nI_=[0,1e-32],
     _nH_=[0,1],
     _nG_=[0,1e-32],
     _nF_=caml_new_string("Owl_optimise.Utils.get_chunk:"),
     _nE_=[0,0],
     _nD_=caml_new_string("Owl_optimise.Utils.draw_samples:"),
     _nC_=caml_new_string("Owl_optimise.Utils.sample_num:"),
     _pF_=[0,[2,0,0],caml_new_string("%s")],
     _pC_=
      [0,
       [11,
        caml_new_string("    prev:["),
        [2,
         0,
         [11,
          caml_new_string("] next:["),
          [2,0,[11,caml_new_string("]\n\n"),0]]]]],
       caml_new_string("    prev:[%s] next:[%s]\n\n")],
     _pD_=[0,[2,0,0],caml_new_string("%s")],
     _pE_=
      [0,
       [11,
        caml_new_string("\x1b[31m[ Node "),
        [2,0,[11,caml_new_string(" ]:\x1b[0m\n"),0]]],
       caml_new_string("\x1b[31m[ Node %s ]:\x1b[0m\n")],
     _pB_=caml_new_string("\n\n"),
     _pA_=[0,1],
     _pz_=[0,1],
     _py_=[0,1],
     _px_=[0,1],
     _pw_=caml_new_string("Owl_neural_graph:model"),
     _pv_=[0,1],
     _pu_=caml_new_string("Owl_neural_graph:collect_output"),
     _pt_=caml_new_string("Owl_neural_graph:get_node"),
     _ps_=caml_new_string("Owl_neural_graph:get_root"),
     _pr_=[0,[2,0,[12,95,[4,3,0,0,0]]],caml_new_string("%s_%i")],
     _pq_=caml_new_string("Graphical network"),
     _pS_=[0,5],
     _pQ_=
      [0,
       [11,
        caml_new_string("Execution time: "),
        [8,0,0,0,[11,caml_new_string(" seconds\n"),0]]],
       caml_new_string("Execution time: %f seconds\n")],
     _pG_=[0,1],
     _pH_=[0,1],
     _pI_=[0,1],
     _pJ_=[0,1],
     _pK_=[0,1],
     _pL_=[0,1],
     _pM_=[0,1],
     _pN_=[0,1],
     _pO_=[0,1],
     _pP_=[0,4];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    caml_fresh_oo_id(0);
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:-x | 0}
    var
     nan=caml_int64_float_of_bits(_a_),
     max_float=caml_int64_float_of_bits(_b_),
     min_float=caml_int64_float_of_bits(_c_),
     max_int=2147483647;
    function _d_(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return s}
    function string_of_bool(b){return b?_e_:_f_}
    function string_of_int(n){return caml_new_string("" + n)}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     oc=caml_ml_open_descriptor_out(2);
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_Wp_)
             {_Wp_ = caml_wrap_exception(_Wp_);
              if(_Wp_[1] !== Sys_error)throw _Wp_}
            var param$0=l;
            continue}
          return 0}}
      return iter(caml_ml_out_channels_list(0))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function _j_(param,_Wn_)
     {var
       str2=_Wn_[2],
       fmt2=_Wn_[1],
       str1=param[2],
       fmt1=param[1],
       _Wo_=_d_(str1,_d_(_k_,str2));
      return [0,concat_fmt(fmt1,fmt2),_Wo_]}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {var g=exit_function[1];
      exit_function[1]
      =
      function(param){caml_call1(f,0);return caml_call1(g,0)};
      return 0}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function rev(l)
     {var l1=l,l2=0;
      for(;;)
       {if(l1){var l1$0=l1[2],a=l1[1],l2$0=[0,a,l2],l1=l1$0,l2=l2$0;continue}
        return l2}}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    function map(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map(f,l)]}
      return 0}
    function _m_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_m_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _m_(0,f,l)}
    function fold_left(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function make(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function sub(s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(!((caml_ml_bytes_length(s) - len | 0) < ofs))
         {var r=caml_create_bytes(len);
          caml_blit_bytes(s,ofs,r,0,len);
          return r}
      return invalid_arg(_t_)}
    function sub_string(b,ofs,len){return sub(b,ofs,len)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(!((caml_ml_bytes_length(s1) - len | 0) < ofs1))
         if(0 <= ofs2)
          if(!((caml_ml_bytes_length(s2) - len | 0) < ofs2))
           return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(_u_)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(!((caml_ml_string_length(s1) - len | 0) < ofs1))
         if(0 <= ofs2)
          if(!((caml_ml_bytes_length(s2) - len | 0) < ofs2))
           return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(_v_)}
    function make$0(n,c){return make(n,c)}
    function sub$0(s,ofs,len){return sub(s,ofs,len)}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function contains_from(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)
       if(!(l < i))
        try
         {index_rec(s,l,i,c);var _Wl_=1;return _Wl_}
        catch(_Wm_)
         {_Wm_ = caml_wrap_exception(_Wm_);
          if(_Wm_ === Not_found)return 0;
          throw _Wm_}
      return invalid_arg(_y_)}
    function contains(s,c){return contains_from(s,0,c)}
    var
     match=caml_sys_get_config(0),
     os_type=match[1],
     max_array_length=caml_sys_const_max_wosize(0),
     max_string_length=(4 * max_array_length | 0) - 1 | 0;
    caml_fresh_oo_id(0);
    function init(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_Wj_=l - 1 | 0,_Wi_=1;
        if(!(_Wj_ < 1))
         {var i=_Wi_;
          for(;;)
           {res[i + 1] = caml_call1(f,i);
            var _Wk_=i + 1 | 0;
            if(_Wj_ !== i){var i=_Wk_;continue}
            break}}
        return res}
      return invalid_arg(_B_)}
    function copy(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$0(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(!((a.length - 1 - len | 0) < ofs))return caml_array_sub(a,ofs,len);
      return invalid_arg(_C_)}
    function iter(f,a)
     {var _Wg_=a.length - 1 - 1 | 0,_Wf_=0;
      if(!(_Wg_ < 0))
       {var i=_Wf_;
        for(;;)
         {caml_call1(f,a[i + 1]);
          var _Wh_=i + 1 | 0;
          if(_Wg_ !== i){var i=_Wh_;continue}
          break}}
      return 0}
    function iter2(f,a,b)
     {if(a.length - 1 !== b.length - 1)return invalid_arg(_D_);
      var _Wd_=a.length - 1 - 1 | 0,_Wc_=0;
      if(!(_Wd_ < 0))
       {var i=_Wc_;
        for(;;)
         {caml_call2(f,a[i + 1],b[i + 1]);
          var _We_=i + 1 | 0;
          if(_Wd_ !== i){var i=_We_;continue}
          break}}
      return 0}
    function map$0(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_Wa_=l - 1 | 0,_V$_=1;
      if(!(_Wa_ < 1))
       {var i=_V$_;
        for(;;)
         {r[i + 1] = caml_call1(f,a[i + 1]);
          var _Wb_=i + 1 | 0;
          if(_Wa_ !== i){var i=_Wb_;continue}
          break}}
      return r}
    function map2(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(_E_);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_V9_=la - 1 | 0,_V8_=1;
      if(!(_V9_ < 1))
       {var i=_V8_;
        for(;;)
         {r[i + 1] = caml_call2(f,a[i + 1],b[i + 1]);
          var _V__=i + 1 | 0;
          if(_V9_ !== i){var i=_V__;continue}
          break}}
      return r}
    function iteri(f,a)
     {var _V6_=a.length - 1 - 1 | 0,_V5_=0;
      if(!(_V6_ < 0))
       {var i=_V5_;
        for(;;)
         {caml_call2(f,i,a[i + 1]);
          var _V7_=i + 1 | 0;
          if(_V6_ !== i){var i=_V7_;continue}
          break}}
      return 0}
    function to_list(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[i + 1],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function of_list(l)
     {if(l)
       {var tl=l[2],hd=l[1],accu=0,param=l;
        for(;;)
         {if(param)
           {var
             param$0=param[2],
             accu$0=accu + 1 | 0,
             accu=accu$0,
             param=param$0;
            continue}
          var a=caml_make_vect(accu,hd),i=1,param$1=tl;
          for(;;)
           {if(param$1)
             {var tl$0=param$1[2],hd$0=param$1[1];
              a[i + 1] = hd$0;
              var i$0=i + 1 | 0,i=i$0,param$1=tl$0;
              continue}
            return a}}}
      return [0]}
    function fold_left$0(f,x,a)
     {var r=[0,x],_V3_=a.length - 1 - 1 | 0,_V2_=0;
      if(!(_V3_ < 0))
       {var i=_V2_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[i + 1]);
          var _V4_=i + 1 | 0;
          if(_V3_ !== i){var i=_V4_;continue}
          break}}
      return r[1]}
    function mem(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[i + 1],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    caml_fresh_oo_id(0);
    var Undefined=[248,_F_,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        blk[1] = result;
        caml_obj_set_tag(blk,250);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function create(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function resize(b,more)
     {var len=b[3],new_len=[0,len];
      for(;;)
       {if(new_len[1] < (b[2] + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((b[2] + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(_H_);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        return 0}}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      blit$0(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    var default_float_precision=-6;
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _V0_=len < min_len?1:0;
      if(_V0_)
       {var
         new_len=max(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _V1_=0}
      else
       var _V1_=_V0_;
      return _V1_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return _J_;
         case 1:return _K_;
         case 2:return _L_;
         case 3:return _M_;
         case 4:return _N_;
         case 5:return _O_;
         default:return _P_}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return _d_(_Q_,make$0(1,c))}}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,_R_);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,_S_);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,_T_);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,_U_);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,_V_);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,_W_);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,_X_);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,_Y_);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,_Z_);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,___);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,_$_);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,_aa_);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,_ab_);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,_ac_);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,_ad_);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,_ae_);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,_af_);
           var fmtty$0=rest$13;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _VC_=function(param){return 0},
         _VD_=function(param){return 0},
         _VE_=function(param){return 0};
        return [0,function(param){return 0},_VE_,_VD_,_VC_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _VF_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_VF_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _VG_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _VG_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _VH_=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _VH_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _VI_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _VI_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _VJ_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _VJ_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _VK_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _VK_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _VL_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _VL_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _VM_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _VM_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _VN_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _VN_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _VO_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _VP_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _VQ_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _VQ_,
                  _VP_,
                  _VO_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _VR_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _VR_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _VS_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _VS_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _VT_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _VT_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _VU_=function(param){caml_call1(de$12,0);return 0},
           _VV_=function(param){caml_call1(ed$12,0);return 0},
           _VW_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _VW_,
                  _VV_,
                  _VU_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _VX_=function(param){caml_call1(de$13,0);return 0},
           _VY_=function(param){caml_call1(ed$13,0);return 0},
           _VZ_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _VZ_,
                  _VY_,
                  _VX_]}}
    function trans(ty1,match)
     {if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:var switch$0=0;break;
          case 11:var switch$0=1;break;
          case 12:var switch$0=2;break;
          case 13:var switch$0=3;break;
          case 14:var switch$0=4;break;
          case 8:var switch$0=5;break;
          case 9:var switch$0=6;break;
          default:throw [0,Assert_failure,_ag_]}
      else
       switch(ty1[0])
        {case 0:
          var _Vj_=ty1[1];
          if(typeof match === "number")
           var switch$1=1;
          else
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_Vj_,rest2)];
             case 8:var switch$0=5,switch$1=0;break;
             case 9:var switch$0=6,switch$1=0;break;
             case 10:var switch$0=0,switch$1=0;break;
             case 11:var switch$0=1,switch$1=0;break;
             case 12:var switch$0=2,switch$1=0;break;
             case 13:var switch$0=3,switch$1=0;break;
             case 14:var switch$0=4,switch$1=0;break;
             default:var switch$1=1}
          if(switch$1)var switch$0=7;
          break;
         case 1:
          var _Vk_=ty1[1];
          if(typeof match === "number")
           var switch$2=1;
          else
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_Vk_,rest2$0)];
             case 8:var switch$0=5,switch$2=0;break;
             case 9:var switch$0=6,switch$2=0;break;
             case 10:var switch$0=0,switch$2=0;break;
             case 11:var switch$0=1,switch$2=0;break;
             case 12:var switch$0=2,switch$2=0;break;
             case 13:var switch$0=3,switch$2=0;break;
             case 14:var switch$0=4,switch$2=0;break;
             default:var switch$2=1}
          if(switch$2)var switch$0=7;
          break;
         case 2:
          var _Vl_=ty1[1];
          if(typeof match === "number")
           var switch$3=1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_Vl_,rest2$1)];
             case 8:var switch$0=5,switch$3=0;break;
             case 9:var switch$0=6,switch$3=0;break;
             case 10:var switch$0=0,switch$3=0;break;
             case 11:var switch$0=1,switch$3=0;break;
             case 12:var switch$0=2,switch$3=0;break;
             case 13:var switch$0=3,switch$3=0;break;
             case 14:var switch$0=4,switch$3=0;break;
             default:var switch$3=1}
          if(switch$3)var switch$0=7;
          break;
         case 3:
          var _Vm_=ty1[1];
          if(typeof match === "number")
           var switch$4=1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_Vm_,rest2$2)];
             case 8:var switch$0=5,switch$4=0;break;
             case 9:var switch$0=6,switch$4=0;break;
             case 10:var switch$0=0,switch$4=0;break;
             case 11:var switch$0=1,switch$4=0;break;
             case 12:var switch$0=2,switch$4=0;break;
             case 13:var switch$0=3,switch$4=0;break;
             case 14:var switch$0=4,switch$4=0;break;
             default:var switch$4=1}
          if(switch$4)var switch$0=7;
          break;
         case 4:
          var _Vn_=ty1[1];
          if(typeof match === "number")
           var switch$5=1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_Vn_,rest2$3)];
             case 8:var switch$0=5,switch$5=0;break;
             case 9:var switch$0=6,switch$5=0;break;
             case 10:var switch$0=0,switch$5=0;break;
             case 11:var switch$0=1,switch$5=0;break;
             case 12:var switch$0=2,switch$5=0;break;
             case 13:var switch$0=3,switch$5=0;break;
             case 14:var switch$0=4,switch$5=0;break;
             default:var switch$5=1}
          if(switch$5)var switch$0=7;
          break;
         case 5:
          var _Vo_=ty1[1];
          if(typeof match === "number")
           var switch$6=1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_Vo_,rest2$4)];
             case 8:var switch$0=5,switch$6=0;break;
             case 9:var switch$0=6,switch$6=0;break;
             case 10:var switch$0=0,switch$6=0;break;
             case 11:var switch$0=1,switch$6=0;break;
             case 12:var switch$0=2,switch$6=0;break;
             case 13:var switch$0=3,switch$6=0;break;
             case 14:var switch$0=4,switch$6=0;break;
             default:var switch$6=1}
          if(switch$6)var switch$0=7;
          break;
         case 6:
          var _Vp_=ty1[1];
          if(typeof match === "number")
           var switch$7=1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_Vp_,rest2$5)];
             case 8:var switch$0=5,switch$7=0;break;
             case 9:var switch$0=6,switch$7=0;break;
             case 10:var switch$0=0,switch$7=0;break;
             case 11:var switch$0=1,switch$7=0;break;
             case 12:var switch$0=2,switch$7=0;break;
             case 13:var switch$0=3,switch$7=0;break;
             case 14:var switch$0=4,switch$7=0;break;
             default:var switch$7=1}
          if(switch$7)var switch$0=7;
          break;
         case 7:
          var _Vq_=ty1[1];
          if(typeof match === "number")
           var switch$8=1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_Vq_,rest2$6)];
             case 8:var switch$0=5,switch$8=0;break;
             case 9:var switch$0=6,switch$8=0;break;
             case 10:var switch$0=0,switch$8=0;break;
             case 11:var switch$0=1,switch$8=0;break;
             case 12:var switch$0=2,switch$8=0;break;
             case 13:var switch$0=3,switch$8=0;break;
             case 14:var switch$0=4,switch$8=0;break;
             default:var switch$8=1}
          if(switch$8)var switch$0=7;
          break;
         case 8:
          var _Vr_=ty1[2],_Vs_=ty1[1];
          if(typeof match === "number")
           var switch$9=1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_Vt_=trans(_Vr_,rest2$7);
              return [8,trans(_Vs_,ty2),_Vt_];
             case 10:var switch$0=0,switch$9=0;break;
             case 11:var switch$0=1,switch$9=0;break;
             case 12:var switch$0=2,switch$9=0;break;
             case 13:var switch$0=3,switch$9=0;break;
             case 14:var switch$0=4,switch$9=0;break;
             default:var switch$9=1}
          if(switch$9)throw [0,Assert_failure,_ap_];
          break;
         case 9:
          var _Vu_=ty1[3],_Vv_=ty1[2],_Vw_=ty1[1];
          if(typeof match === "number")
           var switch$10=1;
          else
           switch(match[0])
            {case 8:var switch$0=5,switch$10=0;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_Vv_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_Vw_,ty22,trans(_Vu_,rest2$8)];
             case 10:var switch$0=0,switch$10=0;break;
             case 11:var switch$0=1,switch$10=0;break;
             case 12:var switch$0=2,switch$10=0;break;
             case 13:var switch$0=3,switch$10=0;break;
             case 14:var switch$0=4,switch$10=0;break;
             default:var switch$10=1}
          if(switch$10)throw [0,Assert_failure,_aq_];
          break;
         case 10:
          var _Vx_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_Vx_,rest2$9)]}
          throw [0,Assert_failure,_ar_];
         case 11:
          var _Vy_=ty1[1];
          if(typeof match === "number")
           var switch$11=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$11=0;break;
             case 11:var rest2$10=match[1];return [11,trans(_Vy_,rest2$10)];
             default:var switch$11=1}
          if(switch$11)throw [0,Assert_failure,_as_];
          break;
         case 12:
          var _Vz_=ty1[1];
          if(typeof match === "number")
           var switch$12=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$12=0;break;
             case 11:var switch$0=1,switch$12=0;break;
             case 12:var rest2$11=match[1];return [12,trans(_Vz_,rest2$11)];
             default:var switch$12=1}
          if(switch$12)throw [0,Assert_failure,_at_];
          break;
         case 13:
          var _VA_=ty1[1];
          if(typeof match === "number")
           var switch$13=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$13=0;break;
             case 11:var switch$0=1,switch$13=0;break;
             case 12:var switch$0=2,switch$13=0;break;
             case 13:var rest2$12=match[1];return [13,trans(_VA_,rest2$12)];
             default:var switch$13=1}
          if(switch$13)throw [0,Assert_failure,_au_];
          break;
         default:
          var _VB_=ty1[1];
          if(typeof match === "number")
           var switch$14=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$14=0;break;
             case 11:var switch$0=1,switch$14=0;break;
             case 12:var switch$0=2,switch$14=0;break;
             case 13:var switch$0=3,switch$14=0;break;
             case 14:var rest2$13=match[1];return [14,trans(_VB_,rest2$13)];
             default:var switch$14=1}
          if(switch$14)throw [0,Assert_failure,_av_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_aj_];
        case 1:throw [0,Assert_failure,_ak_];
        case 2:throw [0,Assert_failure,_al_];
        case 3:throw [0,Assert_failure,_am_];
        case 4:throw [0,Assert_failure,_an_];
        case 5:throw [0,Assert_failure,_ah_];
        case 6:throw [0,Assert_failure,_ai_];
        default:throw [0,Assert_failure,_ao_]}}
    var Type_mismatch=[248,_aw_,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(0 === prec)
         {var rest=match[2],pad$0=match[1];return [0,pad$0,0,rest]}
        var _Vi_=match[2];
        if(typeof _Vi_ !== "number" && 2 === _Vi_[0])
         {var rest$0=_Vi_[1],pad$1=match[1];return [0,pad$1,1,rest$0]}
        throw Type_mismatch}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           _UP_=type_padding(pad,fmtty),
           _UQ_=_UP_[2],
           _UR_=_UP_[1];
          if(typeof _UQ_ !== "number" && 1 === _UQ_[0])
           {var
             fmtty_rest$1=_UQ_[1],
             match$1=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$1[2],
             fmt$2=match$1[1];
            return [0,[2,_UR_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           _US_=type_padding(pad$0,fmtty),
           _UT_=_US_[2],
           _UU_=_US_[1];
          if(typeof _UT_ !== "number" && 1 === _UT_[0])
           {var
             fmtty_rest$2=_UT_[1],
             match$2=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$2[2],
             fmt$3=match$2[1];
            return [0,[3,_UU_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           _UV_=type_padprec(pad$1,prec,fmtty),
           _UW_=_UV_[3],
           _UX_=_UV_[2],
           _UY_=_UV_[1];
          if(typeof _UW_ !== "number" && 2 === _UW_[0])
           {var
             fmtty_rest$3=_UW_[1],
             match$3=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$3[2],
             fmt$4=match$3[1];
            return [0,[4,iconv,_UY_,_UX_,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$0=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           _UZ_=type_padprec(pad$2,prec$0,fmtty),
           _U0_=_UZ_[3],
           _U1_=_UZ_[2],
           _U2_=_UZ_[1];
          if(typeof _U0_ !== "number" && 3 === _U0_[0])
           {var
             fmtty_rest$4=_U0_[1],
             match$4=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$4[2],
             fmt$5=match$4[1];
            return [0,[5,iconv$0,_U2_,_U1_,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$1=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           _U3_=type_padprec(pad$3,prec$1,fmtty),
           _U4_=_U3_[3],
           _U5_=_U3_[2],
           _U6_=_U3_[1];
          if(typeof _U4_ !== "number" && 4 === _U4_[0])
           {var
             fmtty_rest$5=_U4_[1],
             match$5=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$5[2],
             fmt$6=match$5[1];
            return [0,[6,iconv$1,_U6_,_U5_,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$2=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           _U7_=type_padprec(pad$4,prec$2,fmtty),
           _U8_=_U7_[3],
           _U9_=_U7_[2],
           _U__=_U7_[1];
          if(typeof _U8_ !== "number" && 5 === _U8_[0])
           {var
             fmtty_rest$6=_U8_[1],
             match$6=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$6[2],
             fmt$7=match$6[1];
            return [0,[7,iconv$2,_U__,_U9_,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$3=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           _U$_=type_padprec(pad$5,prec$3,fmtty),
           _Va_=_U$_[3],
           _Vb_=_U$_[2],
           _Vc_=_U$_[1];
          if(typeof _Va_ !== "number" && 6 === _Va_[0])
           {var
             fmtty_rest$7=_Va_[1],
             match$7=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$7[2],
             fmt$8=match$7[1];
            return [0,[8,fconv,_Vc_,_Vb_,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           _Vd_=type_padding(pad$6,fmtty),
           _Ve_=_Vd_[2],
           _Vf_=_Vd_[1];
          if(typeof _Ve_ !== "number" && 7 === _Ve_[0])
           {var
             fmtty_rest$8=_Ve_[1],
             match$8=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$8[2],
             fmt$9=match$8[1];
            return [0,[9,_Vf_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$9=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$9[2],
           fmt$10=match$9[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$10=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$10[2],
           fmt$11=match$10[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$11=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$11[2],
           fmt$12=match$11[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$12=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$12[2],
             fmt$13=match$12[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _Vg_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_Vg_))
             throw Type_mismatch;
            var
             match$13=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$13[2],
             fmt$14=match$13[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$14=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$14[2],
             fmt$15=match$14[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$15=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$15[2],
             fmt$16=match$15[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$16=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$16[2],
           fmt$17=match$16[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$20=formatting_gen[1],
             str$0=match$20[2],
             fmt1=match$20[1],
             match$21=type_format_gen(fmt1,fmtty),
             fmtty2=match$21[2],
             fmt2=match$21[1],
             match$22=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$22[2],
             fmt3=match$22[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$23=formatting_gen[1],
           str$1=match$23[2],
           fmt1$0=match$23[1],
           match$24=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$24[2],
           fmt2$0=match$24[1],
           match$25=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$25[2],
           fmt3$0=match$25[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$17=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$17[2],
             fmt$18=match$17[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$18=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$18[2],
             fmt$19=match$18[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$19=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$19[2],
             fmt$20=match$19[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$26=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$26[2],
                 fmt$21=match$26[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _Vh_=type_ignored_format_substitution(sub_fmtty$3,rest,fmtty),
               match$27=_Vh_[2],
               fmtty$22=match$27[2],
               fmt$22=match$27[1],
               sub_fmtty$4=_Vh_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_format_substitution(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substitution(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substitution
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substitution
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substitution
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substitution
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substitution
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substitution
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substitution
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substitution
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _UN_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_UN_))
             throw Type_mismatch;
            var _UO_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_UO_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substitution
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substitution
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substitution
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substitution
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substitution
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function recast(fmt$0,fmtty)
     {var fmtty$0=erase_rel(symm(fmtty)),_UM_=type_format_gen(fmt$0,fmtty$0);
      if(typeof _UM_[2] === "number"){var fmt=_UM_[1];return fmt}
      throw Type_mismatch}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _UL_=2 === padty$0?48:32,res=make(width$0,_UL_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         if(0 < len)
          {if(43 === caml_string_get(str,0))
            var switch$1=1;
           else
            if(45 === caml_string_get(str,0))
             var switch$1=1;
            else
             if(32 === caml_string_get(str,0))
              var switch$1=1;
             else
              var switch$0=0,switch$1=0;
           if(switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0);
             var switch$0=1}}
         else
          var switch$0=0;
         if(!switch$0)
          {if(1 < len)
            if(48 === caml_string_get(str,0))
             {if(120 === caml_string_get(str,1))
               var switch$3=1;
              else
               if(88 === caml_string_get(str,1))
                var switch$3=1;
               else
                var switch$2=0,switch$3=0;
              if(switch$3)
               {caml_bytes_set(res,1,caml_string_get(str,1));
                blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0);
                var switch$2=1}}
            else
             var switch$2=0;
           else
            var switch$2=0;
           if(!switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return res}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0);
      if(58 <= c)
       var switch$0=71 <= c?5 < (c - 97 | 0) >>> 0?1:0:65 <= c?0:1;
      else
       {if(32 === c)
         var switch$1=1;
        else
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0))
               if(1 < len)
                {var
                  switch$2=
                   120 === caml_string_get(str,1)
                    ?0
                    :88 === caml_string_get(str,1)?0:1;
                 if(!switch$2)
                  {var res$1=make(prec$0 + 2 | 0,48);
                   caml_bytes_set(res$1,1,caml_string_get(str,1));
                   blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                   return res$1}}
              var switch$0=0,switch$1=0;
              break;
             case 0:
             case 2:var switch$1=1;break;
             case 1:
             case 3:
             case 4:var switch$0=1,switch$1=0;break;
             default:var switch$0=0,switch$1=0}}
         else
          var switch$0=1,switch$1=0;
        if(switch$1)
         {if(len < (prec$0 + 1 | 0))
           {var res$0=make(prec$0 + 1 | 0,48);
            caml_bytes_set(res$0,0,c);
            blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
            return res$0}
          var switch$0=1}}
      if(!switch$0)
       if(len < prec$0)
        {var res=make(prec$0,48);
         blit$0(str,0,res,prec$0 - len | 0,len);
         return res}
      return str}
    function string_to_caml_string(str)
     {var i$1=0;
      for(;;)
       {if(caml_ml_string_length(str) <= i$1)
         var _UK_=0;
        else
         {var match$0=caml_string_unsafe_get(str,i$1);
          if(32 <= match$0)
           {var _UJ_=match$0 - 34 | 0;
            if(58 < _UJ_ >>> 0)
             if(93 <= _UJ_)var switch$0=0,switch$1=0;else var switch$1=1;
            else
             if(56 < (_UJ_ - 1 | 0) >>> 0)
              var switch$0=1,switch$1=0;
             else
              var switch$1=1;
            if(switch$1){var i$2=i$1 + 1 | 0,i$1=i$2;continue}}
          else
           var switch$0=11 <= match$0?13 === match$0?1:0:8 <= match$0?1:0;
          var _UK_=switch$0?1:1}
        if(_UK_)
         {var n=[0,0],_UC_=caml_ml_bytes_length(str) - 1 | 0,_UB_=0;
          if(!(_UC_ < 0))
           {var i$0=_UB_;
            for(;;)
             {var match=caml_string_unsafe_get(str,i$0);
              if(32 <= match)
               {var _UG_=match - 34 | 0;
                if(58 < _UG_ >>> 0)
                 if(93 <= _UG_)var switch$2=0,switch$3=0;else var switch$3=1;
                else
                 if(56 < (_UG_ - 1 | 0) >>> 0)
                  var switch$2=1,switch$3=0;
                 else
                  var switch$3=1;
                if(switch$3)var _UH_=1,switch$2=2}
              else
               var switch$2=11 <= match?13 === match?1:0:8 <= match?1:0;
              switch(switch$2)
               {case 0:var _UH_=4;break;case 1:var _UH_=2;break}
              n[1] = n[1] + _UH_ | 0;
              var _UI_=i$0 + 1 | 0;
              if(_UC_ !== i$0){var i$0=_UI_;continue}
              break}}
          if(n[1] === caml_ml_bytes_length(str))
           {var len=caml_ml_bytes_length(str),r=caml_create_bytes(len);
            caml_blit_bytes(str,0,r,0,len);
            var str$0=r}
          else
           {var s=caml_create_bytes(n[1]);
            n[1] = 0;
            var _UE_=caml_ml_bytes_length(str) - 1 | 0,_UD_=0;
            if(!(_UE_ < 0))
             {var i=_UD_;
              for(;;)
               {var c=caml_string_unsafe_get(str,i);
                if(35 <= c)
                 var switch$4=92 === c?1:127 <= c?0:2;
                else
                 if(32 <= c)
                  var switch$4=34 <= c?1:2;
                 else
                  if(14 <= c)
                   var switch$4=0;
                  else
                   switch(c)
                    {case 8:
                      caml_string_unsafe_set(s,n[1],92);
                      n[1]++;
                      caml_string_unsafe_set(s,n[1],98);
                      var switch$4=3;
                      break;
                     case 9:
                      caml_string_unsafe_set(s,n[1],92);
                      n[1]++;
                      caml_string_unsafe_set(s,n[1],116);
                      var switch$4=3;
                      break;
                     case 10:
                      caml_string_unsafe_set(s,n[1],92);
                      n[1]++;
                      caml_string_unsafe_set(s,n[1],110);
                      var switch$4=3;
                      break;
                     case 13:
                      caml_string_unsafe_set(s,n[1],92);
                      n[1]++;
                      caml_string_unsafe_set(s,n[1],114);
                      var switch$4=3;
                      break;
                     default:var switch$4=0}
                switch(switch$4)
                 {case 0:
                   caml_string_unsafe_set(s,n[1],92);
                   n[1]++;
                   caml_string_unsafe_set(s,n[1],48 + (c / 100 | 0) | 0);
                   n[1]++;
                   caml_string_unsafe_set
                    (s,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
                   n[1]++;
                   caml_string_unsafe_set(s,n[1],48 + (c % 10 | 0) | 0);
                   break;
                  case 1:
                   caml_string_unsafe_set(s,n[1],92);
                   n[1]++;
                   caml_string_unsafe_set(s,n[1],c);
                   break;
                  case 2:caml_string_unsafe_set(s,n[1],c);break
                  }
                n[1]++;
                var _UF_=i + 1 | 0;
                if(_UE_ !== i){var i=_UF_;continue}
                break}}
            var str$0=s}}
        else
         var str$0=str;
        var l=caml_ml_string_length(str$0),res=make(l + 2 | 0,34);
        caml_blit_string(str$0,0,res,1,l);
        return res}}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 0:var _UA_=_ax_;break;
        case 1:var _UA_=_ay_;break;
        case 2:var _UA_=_az_;break;
        case 3:var _UA_=_aA_;break;
        case 4:var _UA_=_aB_;break;
        case 5:var _UA_=_aC_;break;
        case 6:var _UA_=_aD_;break;
        case 7:var _UA_=_aE_;break;
        case 8:var _UA_=_aF_;break;
        case 9:var _UA_=_aG_;break;
        case 10:var _UA_=_aH_;break;
        case 11:var _UA_=_aI_;break;
        default:var _UA_=_aJ_}
      return caml_format_int(_UA_,n)}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 0:var _Uz_=_aX_;break;
        case 1:var _Uz_=_aY_;break;
        case 2:var _Uz_=_aZ_;break;
        case 3:var _Uz_=_a0_;break;
        case 4:var _Uz_=_a1_;break;
        case 5:var _Uz_=_a2_;break;
        case 6:var _Uz_=_a3_;break;
        case 7:var _Uz_=_a4_;break;
        case 8:var _Uz_=_a5_;break;
        case 9:var _Uz_=_a6_;break;
        case 10:var _Uz_=_a7_;break;
        case 11:var _Uz_=_a8_;break;
        default:var _Uz_=_a9_}
      return caml_format_int(_Uz_,n)}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 0:var _Uy_=_a__;break;
        case 1:var _Uy_=_a$_;break;
        case 2:var _Uy_=_ba_;break;
        case 3:var _Uy_=_bb_;break;
        case 4:var _Uy_=_bc_;break;
        case 5:var _Uy_=_bd_;break;
        case 6:var _Uy_=_be_;break;
        case 7:var _Uy_=_bf_;break;
        case 8:var _Uy_=_bg_;break;
        case 9:var _Uy_=_bh_;break;
        case 10:var _Uy_=_bi_;break;
        case 11:var _Uy_=_bj_;break;
        default:var _Uy_=_bk_}
      return caml_format_int(_Uy_,n)}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 0:var _Ux_=_aK_;break;
        case 1:var _Ux_=_aL_;break;
        case 2:var _Ux_=_aM_;break;
        case 3:var _Ux_=_aN_;break;
        case 4:var _Ux_=_aO_;break;
        case 5:var _Ux_=_aP_;break;
        case 6:var _Ux_=_aQ_;break;
        case 7:var _Ux_=_aR_;break;
        case 8:var _Ux_=_aS_;break;
        case 9:var _Ux_=_aT_;break;
        case 10:var _Ux_=_aU_;break;
        case 11:var _Ux_=_aV_;break;
        default:var _Ux_=_aW_}
      return caml_int64_format(_Ux_,n)}
    function convert_float(fconv,prec$0,x)
     {if(16 <= fconv)
       {if(17 <= fconv)
         switch(fconv - 17 | 0)
          {case 2:var switch$0=0;break;
           case 0:
           case 3:var sign=43,switch$0=1;break;
           default:var sign=32,switch$0=1}
        else
         var switch$0=0;
        if(!switch$0)var sign=45;
        var s=caml_hexstring_of_float(x,prec$0,sign);
        if(19 <= fconv)
         {var l=caml_ml_bytes_length(s);
          if(0 === l)return s;
          var r=caml_create_bytes(l),_Ur_=l - 1 | 0,_Uq_=0;
          if(!(_Ur_ < 0))
           {var i=_Uq_;
            for(;;)
             {var c=caml_string_unsafe_get(s,i);
              if(97 <= c)
               if(122 < c)var switch$1=0;else var _Us_=c - 32 | 0,switch$1=1;
              else
               var switch$1=0;
              if(!switch$1)var _Us_=c;
              caml_string_unsafe_set(r,i,_Us_);
              var _Ut_=i + 1 | 0;
              if(_Ur_ !== i){var i=_Ut_;continue}
              break}}
          return r}
        return s}
      if(15 === fconv)
       var _Uu_=_bl_;
      else
       {var prec=abs(prec$0);
        switch(fconv)
         {case 15:var symb=70;break;
          case 0:
          case 1:
          case 2:var symb=102;break;
          case 3:
          case 4:
          case 5:var symb=101;break;
          case 6:
          case 7:
          case 8:var symb=69;break;
          case 9:
          case 10:
          case 11:var symb=103;break;
          case 12:
          case 13:
          case 14:var symb=71;break;
          case 16:
          case 17:
          case 18:var symb=104;break;
          default:var symb=72}
        var buf=buffer_create(16);
        buffer_add_char(buf,37);
        switch(fconv)
         {case 1:
          case 4:
          case 7:
          case 10:
          case 13:
          case 17:
          case 20:buffer_add_char(buf,43);break;
          case 2:
          case 5:
          case 8:
          case 11:
          case 14:
          case 18:
          case 21:buffer_add_char(buf,32);break
          }
        buffer_add_char(buf,46);
        buffer_add_string(buf,caml_new_string("" + prec));
        buffer_add_char(buf,symb);
        var _Uu_=buffer_contents(buf)}
      var str=caml_format_float(_Uu_,x);
      if(15 === fconv)
       {var len=caml_ml_string_length(str),match$0=caml_classify_float(x);
        if(3 === match$0)return x < 0?_bm_:_bn_;
        if(4 <= match$0)return _bo_;
        var i$0=0;
        for(;;)
         {if(i$0 === len)
           var _Uw_=0;
          else
           {var
             match=caml_string_get(str,i$0),
             _Uv_=match - 46 | 0,
             switch$2=
              23 < _Uv_ >>> 0?55 === _Uv_?1:0:21 < (_Uv_ - 1 | 0) >>> 0?1:0;
            if(!switch$2){var i$1=i$0 + 1 | 0,i$0=i$1;continue}
            var _Uw_=1}
          return _Uw_?str:_d_(str,_bp_)}}
      return str}
    function make_int_padding_precision(k,o,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return 0 === match
                 ?function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,o,[4,acc,str],fmt)}
                 :function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,o,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,o,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _Un_=pad[2],_Uo_=pad[1];
          if(typeof match === "number")
           return 0 === match
                   ?function(x)
                     {var str=fix_padding(_Uo_,_Un_,caml_call2(trans,iconv,x));
                      return make_printf(k,o,[4,acc,str],fmt)}
                   :function(p,x)
                     {var
                       str=
                        fix_padding
                         (_Uo_,_Un_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,o,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_Uo_,_Un_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,o,[4,acc,str],fmt)}}
        var _Up_=pad[1];
        if(typeof match === "number")
         return 0 === match
                 ?function(w,x)
                   {var str=fix_padding(_Up_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,o,[4,acc,str],fmt)}
                 :function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_Up_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,o,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_Up_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,o,[4,acc,str],fmt)}}}
    function make_padding(k,o,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,o,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,o,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,o,new_acc,fmt)}}}
    function make_printf$0(counter,k,o,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call2(k$0,o,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,o,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {if(40 <= c)
              if(92 === c)
               var str=_n_,switch$0=2;
              else
               var switch$0=127 <= c?0:1;
             else
              if(32 <= c)
               if(39 <= c)var str=_o_,switch$0=2;else var switch$0=1;
              else
               if(14 <= c)
                var switch$0=0;
               else
                switch(c)
                 {case 8:var str=_p_,switch$0=2;break;
                  case 9:var str=_q_,switch$0=2;break;
                  case 10:var str=_r_,switch$0=2;break;
                  case 13:var str=_s_,switch$0=2;break;
                  default:var switch$0=0}
             switch(switch$0)
              {case 0:
                var s=caml_create_bytes(4);
                caml_string_unsafe_set(s,0,92);
                caml_string_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
                caml_string_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
                caml_string_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
                var str=s;
                break;
               case 1:
                var s$0=caml_create_bytes(1);
                caml_string_unsafe_set(s$0,0,c);
                var str=s$0;
                break
               }
             var l=caml_ml_string_length(str),res=make(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,res];
             return make_printf(k$0,o,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding
                   (k$0,o,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,o,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(x)
                        {var str=convert_float(fconv,default_float_precision,x);
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)}
                      :function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _Uk_=pad$5[2],_Ul_=pad$5[1];
               if(typeof prec$3 === "number")
                return 0 === prec$3
                        ?function(x)
                          {var
                            str=convert_float(fconv,default_float_precision,x),
                            str$0=fix_padding(_Ul_,_Uk_,str);
                           return make_printf(k$0,o,[4,acc$0,str$0],rest$7)}
                        :function(p,x)
                          {var str=fix_padding(_Ul_,_Uk_,convert_float(fconv,p,x));
                           return make_printf(k$0,o,[4,acc$0,str],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_Ul_,_Uk_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
             var _Um_=pad$5[1];
             if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision,x),
                          str$0=fix_padding(_Um_,w,str);
                         return make_printf(k$0,o,[4,acc$0,str$0],rest$7)}
                      :function(w,p,x)
                        {var str=fix_padding(_Um_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_Um_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,o,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var rest$9=fmt$0[3],sub_fmtty=fmt$0[2],buf=buffer_create(16);
           bprint_fmtty(buf,sub_fmtty);
           var ty=buffer_contents(buf);
           return function(str)
            {return make_printf(k$0,o,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,o,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      o,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,o,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _Ui_=fmt$0[1];
           if(0 === _Ui_[0])
            {var
              rest$13=fmt$0[2],
              match=_Ui_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(koc,kacc)
                  {return make_printf(k,koc,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_Ui_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(koc,kacc)
                {return make_printf(k,koc,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_bq_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,_br_];
           return function(param){return make_printf(k$0,o,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(_bs_,n)];
             return make_printf(k$0,o,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];
             return make_printf(k$0,o,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,o,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,o,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _Uj_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,o,acc$0,rest$19,arity,_Uj_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,o,acc$0,rest$19,arity,_Uj_])}}
    function make_ignored_param$0(counter,k,o,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 2:throw [0,Assert_failure,_bt_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,o,acc,fmtty,fmt)}
          return caml_trampoline_return
                  (make_from_fmtty$0,[0,k,o,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}}
    function make_from_fmtty$0(counter,k,o,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,o,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,o,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,o,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_Uh_)
           {return make_from_fmtty(k,o,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_bu_];
         default:throw [0,Assert_failure,_bv_]}}
    function make_invalid_arg(counter,k,o,acc,fmt)
     {var _Ug_=[8,acc,_bw_];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,o,_Ug_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,o,_Ug_,fmt])}
    function make_custom$0(counter,k,o,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,o,acc,rest,arity$0,caml_call1(f,x))}}
      var _Uf_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,o,_Uf_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,o,_Uf_,rest])}
    function make_printf(k,o,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,o,acc,fmt))}
    function make_ignored_param(k,o,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,o,acc,ign,fmt))}
    function make_from_fmtty(k,o,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,o,acc,fmtty,fmt))}
    function make_custom(k,o,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,o,acc,rest,arity,f))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {var _TN_=make_iprintf(k,o,fmt);return function(_T5_){return _TN_}}
          var _TO_=make_iprintf(k,o,fmt),_TP_=function(_T4_){return _TO_};
          return function(_T3_){return _TP_}}
        var _TQ_=make_iprintf(k,o,fmt);
        return function(_T2_){return _TQ_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(0 === prec)
             {var _TR_=make_iprintf(k,o,fmt);
              return function(_Ue_){return _TR_}}
            var _TS_=make_iprintf(k,o,fmt),_TT_=function(_Ud_){return _TS_};
            return function(_Uc_){return _TT_}}
          var _TU_=make_iprintf(k,o,fmt);
          return function(_Ub_){return _TU_}}
        if(typeof prec === "number")
         {if(0 === prec)
           {var _TV_=make_iprintf(k,o,fmt),_TW_=function(_Ua_){return _TV_};
            return function(_T$_){return _TW_}}
          var
           _TX_=make_iprintf(k,o,fmt),
           _TY_=function(_T__){return _TX_},
           _TZ_=function(_T9_){return _TY_};
          return function(_T8_){return _TZ_}}
        var _T0_=make_iprintf(k,o,fmt),_T1_=function(_T7_){return _T0_};
        return function(_T6_){return _T1_}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_S4_=make_iprintf(k$0,o,rest);
           return function(_TM_){return _S4_};
          case 1:
           var rest$0=fmt$0[1],_S5_=make_iprintf(k$0,o,rest$0);
           return function(_TL_){return _S5_};
          case 2:
           var _S6_=fmt$0[1];
           if(typeof _S6_ === "number")
            {var rest$1=fmt$0[2],_S7_=make_iprintf(k$0,o,rest$1);
             return function(_TH_){return _S7_}}
           else
            {if(0 === _S6_[0])
              {var rest$2=fmt$0[2],_S8_=make_iprintf(k$0,o,rest$2);
               return function(_TK_){return _S8_}}
             var
              rest$3=fmt$0[2],
              _S9_=make_iprintf(k$0,o,rest$3),
              _S__=function(_TJ_){return _S9_};
             return function(_TI_){return _S__}}
          case 3:
           var _S$_=fmt$0[1];
           if(typeof _S$_ === "number")
            {var rest$4=fmt$0[2],_Ta_=make_iprintf(k$0,o,rest$4);
             return function(_TD_){return _Ta_}}
           else
            {if(0 === _S$_[0])
              {var rest$5=fmt$0[2],_Tb_=make_iprintf(k$0,o,rest$5);
               return function(_TG_){return _Tb_}}
             var
              rest$6=fmt$0[2],
              _Tc_=make_iprintf(k$0,o,rest$6),
              _Td_=function(_TF_){return _Tc_};
             return function(_TE_){return _Td_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _Te_=fmt$0[1];
           if(typeof _Te_ === "number")
            {var rest$12=fmt$0[2],_Tf_=make_iprintf(k$0,o,rest$12);
             return function(_Tz_){return _Tf_}}
           else
            {if(0 === _Te_[0])
              {var rest$13=fmt$0[2],_Tg_=make_iprintf(k$0,o,rest$13);
               return function(_TC_){return _Tg_}}
             var
              rest$14=fmt$0[2],
              _Th_=make_iprintf(k$0,o,rest$14),
              _Ti_=function(_TB_){return _Th_};
             return function(_TA_){return _Ti_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_Tj_=make_iprintf(k$0,o,rest$15);
           return function(_Ty_){return _Tj_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _Tk_=make_iprintf(k$0,o,rest$17),
            _Tl_=function(_Tx_){return _Tk_};
           return function(_Tw_){return _Tl_};
          case 16:
           var rest$18=fmt$0[1],_Tm_=make_iprintf(k$0,o,rest$18);
           return function(_Tv_){return _Tm_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _Tn_=fmt$0[1];
           if(0 === _Tn_[0])
            {var
              rest$19=fmt$0[2],
              match=_Tn_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_Tn_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_bx_];
          case 20:
           var rest$21=fmt$0[3],_To_=make_iprintf(k$0,o,rest$21);
           return function(_Tu_){return _To_};
          case 21:
           var rest$22=fmt$0[2],_Tp_=make_iprintf(k$0,o,rest$22);
           return function(_Tt_){return _Tp_};
          case 22:
           var rest$23=fmt$0[1],_Tq_=make_iprintf(k$0,o,rest$23);
           return function(_Ts_){return _Tq_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_Tr_=0;
           return make_ignored_param
                   (function(x,param){return caml_call1(k$0,x)},
                    o,
                    _Tr_,
                    ign,
                    rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_S2_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_S3_){return _S2_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _S0_=acc$0[2],_S1_=acc$0[1];
           if(0 === _S0_[0])
            {var acc$1=_S0_[1];
             output_acc(o,_S1_);
             output_string(o,_by_);
             var acc$0=acc$1;
             continue}
           var acc$2=_S0_[1];
           output_acc(o,_S1_);
           output_string(o,_bz_);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _SY_=acc$0[2],_SZ_=acc$0[1];
           if(0 === _SY_[0])
            {var acc$1=_SY_[1];
             strput_acc(b,_SZ_);
             add_string(b,_bA_);
             var acc$0=acc$1;
             continue}
           var acc$2=_SY_[1];
           strput_acc(b,_SZ_);
           add_string(b,_bB_);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           strput_acc(b,p$1);
           var pos=b[2];
           if(b[3] <= pos)resize(b,1);
           caml_string_unsafe_set(b[1],pos,c);
           b[2] = pos + 1 | 0;
           return 0}}
    function open_box_of_string(str)
     {if(caml_string_equal(str,_bC_))return _bD_;
      var len=caml_ml_string_length(str);
      function invalid_box(param$0)
       {var fmt=param[1],buf=create(256);
        function k(param,acc)
         {strput_acc(buf,acc);return failwith(contents(buf))}
        return caml_call1(make_printf(k,0,0,fmt),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match)if(32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var
           match=caml_string_get(str,j$0),
           switch$0=48 <= match?58 <= match?0:1:45 === match?1:0;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _SW_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_SW_}
       catch(_SX_)
        {_SX_ = caml_wrap_exception(_SX_);
         if(_SX_[1] !== Failure)throw _SX_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      if(caml_string_notequal(box_name,_bE_))
       if(caml_string_notequal(box_name,_bF_))
        if(caml_string_notequal(box_name,_bG_))
         if(caml_string_notequal(box_name,_bH_))
          if(caml_string_notequal(box_name,_bI_))
           if(caml_string_notequal(box_name,_bJ_))
            var box_type=invalid_box(0),switch$0=1;
           else
            var box_type=1,switch$0=1;
          else
           var box_type=2,switch$0=1;
         else
          var box_type=3,switch$0=1;
        else
         var box_type=0,switch$0=1;
       else
        var switch$0=0;
      else
       var switch$0=0;
      if(!switch$0)var box_type=4;
      return [0,indent,box_type]}
    function fprintf(oc,fmt$0)
     {var fmt=fmt$0[1],_SV_=0;
      return make_printf
              (function(o,acc){output_acc(o,acc);return 0},oc,_SV_,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function sprintf(fmt$0)
     {var fmt=fmt$0[1];
      function k(param,acc)
       {var buf=create(64);strput_acc(buf,acc);return contents(buf)}
      return make_printf(k,0,0,fmt)}
    var printers=[0,0];
    function register_printer(fn){printers[1] = [0,fn,printers[1]];return 0}
    function make_self_init(param)
     {var
       seed$0=caml_sys_random_seed(0),
       result=[0,caml_make_vect(55,0),0],
       seed=0 === seed$0.length - 1?[0,0]:seed$0,
       l=seed.length - 1,
       i$0=0;
      for(;;)
       {caml_check_bound(result[1],i$0)[i$0 + 1] = i$0;
        var _SU_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_SU_;continue}
        var accu=[0,_bK_],_SQ_=54 + max(55,l) | 0,_SP_=0;
        if(!(_SQ_ < 0))
         {var i=_SP_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed,k)[k + 1],
             str=_d_(accu[1],caml_new_string("" + x));
            accu[1] = caml_md5_string(str,0,caml_ml_string_length(str));
            var
             _SR_=accu[1],
             _SL_=caml_string_get(_SR_,3) << 24,
             _SM_=caml_string_get(_SR_,2) << 16,
             _SN_=caml_string_get(_SR_,1) << 8,
             _SO_=((caml_string_get(_SR_,0) + _SN_ | 0) + _SM_ | 0) + _SL_ | 0,
             _SS_=(caml_check_bound(result[1],j)[j + 1] ^ _SO_) & 1073741823;
            caml_check_bound(result[1],j)[j + 1] = _SS_;
            var _ST_=i + 1 | 0;
            if(_SQ_ !== i){var i=_ST_;continue}
            break}}
        result[2] = 0;
        return result}}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _SI_=s[2],
       curval=caml_check_bound(s[1],_SI_)[_SI_ + 1],
       _SJ_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_SJ_)[_SJ_ + 1]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _SK_=s[2];
      caml_check_bound(s[1],_SK_)[_SK_ + 1] = newval30;
      return newval30}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824 + r2) / 1073741824 * bound}
    function ongoing_traversal(h)
     {var _SG_=h.length - 1 < 4?1:0,_SH_=_SG_ || (h[4] < 0?1:0);return _SH_}
    function flip_ongoing_traversal(h){h[4] = -h[4] | 0;return 0}
    try
     {var _p0_=caml_sys_getenv(_pZ_),params=_p0_}
    catch(_SE_)
     {_SE_ = caml_wrap_exception(_SE_);
      if(_SE_ !== Not_found)throw _SE_;
      try
       {var _pY_=caml_sys_getenv(_pX_),_bN_=_pY_}
      catch(_SF_)
       {_SF_ = caml_wrap_exception(_SF_);
        if(_SF_ !== Not_found)throw _SF_;
        var _bN_=_bM_}
      var params=_bN_}
    var
     randomized_default=contains(params,82),
     prng=[246,function(_SD_){return make_self_init(0)}];
    function create$0(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized_default;
      var x=16;
      for(;;)
       {if(!(initial_size <= x))
         if(!(max_array_length < (x * 2 | 0)))
          {var x$0=x * 2 | 0,x=x$0;continue}
        if(random)
         var
          _SB_=caml_obj_tag(prng),
          _SC_=250 === _SB_?prng[1]:246 === _SB_?force_lazy_block(prng):prng,
          seed=bits(_SC_);
        else
         var seed=0;
        return [0,0,caml_make_vect(x,0),seed,x]}}
    function indexfun(h,key)
     {return 3 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :caml_mod(caml_hash_univ_param(10,100,key),h[2].length - 1)}
    function add(h,key$0,data$0)
     {var
       i$1=indexfun(h,key$0),
       bucket=[0,key$0,data$0,caml_check_bound(h[2],i$1)[i$1 + 1]];
      caml_check_bound(h[2],i$1)[i$1 + 1] = bucket;
      h[1] = h[1] + 1 | 0;
      var _SA_=h[2].length - 1 << 1 < h[1]?1:0;
      if(_SA_)
       {var
         odata=h[2],
         osize=odata.length - 1,
         nsize=osize * 2 | 0,
         _Sr_=nsize < max_array_length?1:0;
        if(_Sr_)
         {var
           ndata=caml_make_vect(nsize,0),
           ndata_tail=caml_make_vect(nsize,0),
           inplace=1 - ongoing_traversal(h);
          h[2] = ndata;
          var _St_=osize - 1 | 0,_Ss_=0;
          if(!(_St_ < 0))
           {var i$0=_Ss_;
            a:
            for(;;)
             {var cell$1=caml_check_bound(odata,i$0)[i$0 + 1],cell=cell$1;
              for(;;)
               {if(cell)
                 {var
                   key=cell[1],
                   data=cell[2],
                   next=cell[3],
                   cell$0=inplace?cell:[0,key,data,0],
                   nidx=indexfun(h,key),
                   match=caml_check_bound(ndata_tail,nidx)[nidx + 1];
                  if(match)
                   match[3] = cell$0;
                  else
                   caml_check_bound(ndata,nidx)[nidx + 1] = cell$0;
                  caml_check_bound(ndata_tail,nidx)[nidx + 1] = cell$0;
                  var cell=next;
                  continue}
                var _Sz_=i$0 + 1 | 0;
                if(_St_ !== i$0){var i$0=_Sz_;continue a}
                break}
              break}}
          if(inplace)
           {var _Sv_=nsize - 1 | 0,_Su_=0;
            if(!(_Sv_ < 0))
             {var i=_Su_;
              for(;;)
               {var match$0=caml_check_bound(ndata_tail,i)[i + 1];
                if(match$0)match$0[3] = 0;
                var _Sy_=i + 1 | 0;
                if(_Sv_ !== i){var i=_Sy_;continue}
                break}}
            var _Sw_=0}
          else
           var _Sw_=inplace;
          var _Sx_=_Sw_}
        else
         var _Sx_=_Sr_;
        return _Sx_}
      return _SA_}
    function find(h,key)
     {var _Sq_=indexfun(h,key),match=caml_check_bound(h[2],_Sq_)[_Sq_ + 1];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function fold(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_Sm_=d.length - 1 - 1 | 0,_Sl_=0;
        if(!(_Sm_ < 0))
         {var i=_Sl_;
          for(;;)
           {var _So_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[i + 1],_So_);
            var _Sp_=i + 1 | 0;
            if(_Sm_ !== i){var i=_Sp_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _Sn_=accu[1];
        return _Sn_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function add_queue(x,q)
     {var c=[0,x,0],_Sk_=q[1];
      return _Sk_?(q[1] = c,_Sk_[2] = c,0):(q[1] = c,q[2] = c,0)}
    var Empty_queue=[248,_bO_,caml_fresh_oo_id(0)];
    function take_queue(q)
     {var _Sj_=q[2];
      if(_Sj_)
       {var x=_Sj_[1],tl=_Sj_[2];q[2] = tl;if(0 === tl)q[1] = 0;return x}
      throw Empty_queue}
    function pp_enqueue(state,token)
     {var len=token[3];
      state[13] = state[13] + len | 0;
      return add_queue(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function break_new_line(state,offset,width)
     {pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      return caml_call1(state[21],state[10])}
    function break_line(state,width){return break_new_line(state,0,width)}
    function break_same_line(state,width)
     {state[9] = state[9] - width | 0;return caml_call1(state[20],width)}
    function pp_force_break_line(state)
     {var _Sg_=state[2];
      if(_Sg_)
       {var
         match=_Sg_[1],
         width=match[2],
         bl_ty=match[1],
         _Sh_=state[9] < width?1:0;
        if(_Sh_)
         {if(0 !== bl_ty)return 5 <= bl_ty?0:break_line(state,width);
          var _Si_=0}
        else
         var _Si_=_Sh_;
        return _Si_}
      return pp_output_newline(state)}
    function pp_skip_token(state)
     {var match=take_queue(state[28]),size=match[1],len=match[3];
      state[12] = state[12] - len | 0;
      state[9] = state[9] + size | 0;
      return 0}
    function format_pp_token(state,size,param)
     {if(typeof param === "number")
       switch(param)
        {case 0:
          var _R7_=state[3];
          if(_R7_)
           {var
             match=_R7_[1],
             tabs=match[1],
             add_tab=
              function(n,ls)
               {if(ls)
                 {var l=ls[2],x=ls[1];
                  return caml_lessthan(n,x)?[0,n,ls]:[0,x,add_tab(n,l)]}
                return [0,n,0]};
            tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1]);
            return 0}
          return 0;
         case 1:
          var _R8_=state[2];
          if(_R8_){var ls=_R8_[2];state[2] = ls;return 0}
          return 0;
         case 2:
          var _R9_=state[3];
          if(_R9_){var ls$0=_R9_[2];state[3] = ls$0;return 0}
          return 0;
         case 3:
          var _R__=state[2];
          if(_R__)
           {var match$0=_R__[1],width=match$0[2];
            return break_line(state,width)}
          return pp_output_newline(state);
         case 4:
          var _R$_=state[10] !== (state[6] - state[9] | 0)?1:0;
          return _R$_?pp_skip_token(state):_R$_;
         default:
          var _Sa_=state[5];
          if(_Sa_)
           {var
             tags=_Sa_[2],
             tag_name=_Sa_[1],
             marker=caml_call1(state[25],tag_name);
            pp_output_string(state,marker);
            state[5] = tags;
            return 0}
          return 0}
      else
       switch(param[0])
        {case 0:
          var s=param[1];
          state[9] = state[9] - size | 0;
          pp_output_string(state,s);
          state[11] = 0;
          return 0;
         case 1:
          var off=param[2],n=param[1],_Sb_=state[2];
          if(_Sb_)
           {var match$1=_Sb_[1],width$0=match$1[2],ty=match$1[1];
            switch(ty)
             {case 0:return break_same_line(state,n);
              case 1:return break_new_line(state,off,width$0);
              case 2:return break_new_line(state,off,width$0);
              case 3:
               return state[9] < size
                       ?break_new_line(state,off,width$0)
                       :break_same_line(state,n);
              case 4:
               return state[11]
                       ?break_same_line(state,n)
                       :state[9] < size
                         ?break_new_line(state,off,width$0)
                         :((state[6] - width$0 | 0) + off | 0) < state[10]
                           ?break_new_line(state,off,width$0)
                           :break_same_line(state,n);
              default:return break_same_line(state,n)}}
          return 0;
         case 2:
          var
           off$0=param[2],
           n$0=param[1],
           insertion_point=state[6] - state[9] | 0,
           _Sc_=state[3];
          if(_Sc_)
           {var
             match$2=_Sc_[1],
             tabs$0=match$2[1],
             find=
              function(n,param)
               {var param$0=param;
                for(;;)
                 {if(param$0)
                   {var l=param$0[2],x=param$0[1];
                    if(caml_greaterequal(x,n))return x;
                    var param$0=l;
                    continue}
                  throw Not_found}},
             _Sd_=tabs$0[1];
            if(_Sd_)
             {var x=_Sd_[1];
              try
               {var _Se_=find(insertion_point,tabs$0[1]),x$0=_Se_}
              catch(_Sf_)
               {_Sf_ = caml_wrap_exception(_Sf_);
                if(_Sf_ !== Not_found)throw _Sf_;
                var x$0=x}
              var tab=x$0}
            else
             var tab=insertion_point;
            var offset=tab - insertion_point | 0;
            return 0 <= offset
                    ?break_same_line(state,offset + n$0 | 0)
                    :break_new_line(state,tab + off$0 | 0,state[6])}
          return 0;
         case 3:
          var
           ty$0=param[2],
           off$1=param[1],
           insertion_point$0=state[6] - state[9] | 0;
          if(state[8] < insertion_point$0)pp_force_break_line(state);
          var
           offset$0=state[9] - off$1 | 0,
           bl_type=1 === ty$0?1:state[9] < size?ty$0:5;
          state[2] = [0,[0,bl_type,offset$0],state[2]];
          return 0;
         case 4:var tbox=param[1];state[3] = [0,tbox,state[3]];return 0;
         default:
          var tag_name$0=param[1],marker$0=caml_call1(state[24],tag_name$0);
          pp_output_string(state,marker$0);
          state[5] = [0,tag_name$0,state[5]];
          return 0}}
    function advance_loop(state)
     {for(;;)
       {var _R3_=state[28][2];
        if(_R3_)
         {var
           x=_R3_[1],
           size=x[1],
           len=x[3],
           tok=x[2],
           _R4_=size < 0?1:0,
           _R5_=_R4_?(state[13] - state[12] | 0) < state[9]?1:0:_R4_,
           _R6_=1 - _R5_;
          if(_R6_)
           {take_queue(state[28]);
            var size$0=0 <= size?size:pp_infinity;
            format_pp_token(state,size$0,tok);
            state[12] = len + state[12] | 0;
            continue}
          return _R6_}
        throw Empty_queue}}
    function advance_left(state)
     {try
       {var _R1_=advance_loop(state);return _R1_}
      catch(_R2_)
       {_R2_ = caml_wrap_exception(_R2_);
        if(_R2_ === Empty_queue)return 0;
        throw _R2_}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    var q_elem=[0,-1,_bP_,0],scan_stack_bottom=[0,[0,-1,q_elem],0];
    function clear_scan_stack(state){state[1] = scan_stack_bottom;return 0}
    function set_size(state,ty)
     {var _RX_=state[1];
      if(_RX_)
       {var
         match=_RX_[1],
         queue_elem=match[2],
         left_tot=match[1],
         size=queue_elem[1],
         t=_RX_[2],
         tok=queue_elem[2];
        if(left_tot < state[12])return clear_scan_stack(state);
        if(typeof tok !== "number")
         switch(tok[0])
          {case 3:
            var
             _RZ_=1 - ty,
             _R0_=
              _RZ_?(queue_elem[1] = state[13] + size | 0,state[1] = t,0):_RZ_;
            return _R0_;
           case 1:
           case 2:
            var
             _RY_=
              ty?(queue_elem[1] = state[13] + size | 0,state[1] = t,0):ty;
            return _RY_
           }
        return 0}
      return 0}
    function scan_push(state,b,tok)
     {pp_enqueue(state,tok);
      if(b)set_size(state,1);
      state[1] = [0,[0,state[13],tok],state[1]];
      return 0}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var elem=[0,-state[13] | 0,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _RV_=state[14] === state[15]?1:0;
      if(_RV_)
       {var _RW_=state[16],len=caml_ml_string_length(_RW_);
        return enqueue_string_as(state,len,_RW_)}
      return _RV_}
    function pp_close_box(state,param)
     {var _RT_=1 < state[14]?1:0;
      if(_RT_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,0,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _RU_=0}
      else
       var _RU_=_RT_;
      return _RU_}
    function pp_close_tag(state,param)
     {if(state[23])pp_enqueue(state,[0,0,5,0]);
      var _RQ_=state[22];
      if(_RQ_)
       {var _RR_=state[4];
        if(_RR_)
         {var tags=_RR_[2],tag_name=_RR_[1];
          caml_call1(state[27],tag_name);
          state[4] = tags;
          return 0}
        var _RS_=0}
      else
       var _RS_=_RQ_;
      return _RS_}
    function pp_flush_queue(state,b)
     {var param=state[4];
      for(;;)
       {if(param){var l=param[2];pp_close_tag(state,0);var param=l;continue}
        for(;;)
         {if(1 < state[14]){pp_close_box(state,0);continue}
          state[13] = pp_infinity;
          advance_left(state);
          if(b)pp_output_newline(state);
          state[12] = 1;
          state[13] = 1;
          var _RP_=state[28];
          _RP_[1] = 0;
          _RP_[2] = 0;
          clear_scan_stack(state);
          state[2] = 0;
          state[3] = 0;
          state[4] = 0;
          state[5] = 0;
          state[10] = 0;
          state[14] = 0;
          state[9] = state[6];
          return pp_open_box_gen(state,0,3)}}}
    function pp_print_as_size(state,size,s)
     {var _RO_=state[14] < state[15]?1:0;
      return _RO_?enqueue_string_as(state,size,s):_RO_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_char(state,c){return pp_print_as(state,1,make$0(1,c))}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    var blank_line=make$0(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _RN_=0 < n$0?1:0;
        if(_RN_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _RN_}}
    function default_pp_mark_open_tag(s){return _d_(_bS_,_d_(s,_bR_))}
    function default_pp_mark_close_tag(s){return _d_(_bU_,_d_(s,_bT_))}
    function default_pp_print_open_tag(_RM_){return 0}
    function default_pp_print_close_tag(_RL_){return 0}
    function make_formatter(output,flush)
     {function j(_RK_){return 0}
      function i(_RJ_){return 0}
      function h(_RI_){return 0}
      var pp_queue=[0,0,0],sys_tok=[0,-1,_bV_,0];
      add_queue(sys_tok,pp_queue);
      var
       sys_scan_stack=[0,[0,1,sys_tok],scan_stack_bottom],
       ppf=
        [0,
         sys_scan_stack,
         0,
         0,
         0,
         0,
         78,
         10,
         68,
         78,
         0,
         1,
         1,
         1,
         1,
         max_int,
         _bW_,
         output,
         flush,
         h,
         i,
         j,
         0,
         0,
         default_pp_mark_open_tag,
         default_pp_mark_close_tag,
         default_pp_print_open_tag,
         default_pp_print_close_tag,
         pp_queue];
      ppf[19] = function(_RH_){return caml_call3(ppf[17],_bQ_,0,1)};
      ppf[20] = function(_RG_){return display_indent(ppf,_RG_)};
      ppf[21] = function(_RF_){return display_indent(ppf,_RF_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _RE_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(s,ofs,len)
                {if(0 <= ofs)
                  if(0 <= len)
                   if(!((caml_ml_string_length(s) - len | 0) < ofs))
                    return caml_ml_output(oc,s,ofs,len);
                 return invalid_arg(_g_)},
               _RE_)}
    function formatter_of_buffer(b)
     {function _Rz_(_RD_){return 0}
      return make_formatter
              (function(s,offset,len)
                {var _RA_=offset < 0?1:0;
                 if(_RA_)
                  var _RB_=_RA_;
                 else
                  var
                   _RC_=len < 0?1:0,
                   _RB_=
                    _RC_
                    ||
                    ((caml_ml_string_length(s) - len | 0) < offset?1:0);
                 if(_RB_)invalid_arg(_I_);
                 var new_position=b[2] + len | 0;
                 if(b[3] < new_position)resize(b,len);
                 blit$0(s,offset,b[1],b[2],len);
                 b[2] = new_position;
                 return 0},
               _Rz_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create(pp_buffer_size)}
    var stdbuf=pp_make_buffer(0),formatter=formatter_of_out_channel(stdout);
    formatter_of_out_channel(oc);
    formatter_of_buffer(stdbuf);
    function open_box(indent){return pp_open_box_gen(formatter,indent,4)}
    function close_box(_Ry_){return pp_close_box(formatter,_Ry_)}
    function print_flush(_Rx_){return pp_print_flush(formatter,_Rx_)}
    function compute_tag(output,tag_acc)
     {var b=create(16),ppf=formatter_of_buffer(b);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=b[2];
      if(2 <= len)
       {var len$0=len - 2 | 0,ofs=1;
        if(0 <= len$0)
         if(!((b[2] - len$0 | 0) < 1))return sub_string(b[1],ofs,len$0);
        return invalid_arg(_G_)}
      return contents(b)}
    function output_acc$0(ppf,acc)
     {if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          if(typeof f === "number")
           switch(f)
            {case 0:return pp_close_box(ppf,0);
             case 1:return pp_close_tag(ppf,0);
             case 2:return pp_print_flush(ppf,0);
             case 3:
              var _Rl_=ppf[14] < ppf[15]?1:0;
              return _Rl_?enqueue_advance(ppf,[0,0,3,0]):_Rl_;
             case 4:pp_flush_queue(ppf,1);return caml_call1(ppf[18],0);
             case 5:return pp_print_char(ppf,64);
             default:return pp_print_char(ppf,37)}
          else
           switch(f[0])
            {case 0:
              var offset=f[3],width=f[2],_Rm_=ppf[14] < ppf[15]?1:0;
              if(_Rm_)
               {var elem=[0,-ppf[13] | 0,[1,width,offset],width];
                return scan_push(ppf,1,elem)}
              return _Rm_;
             case 1:return 0;
             default:
              var c=f[1];pp_print_char(ppf,64);return pp_print_char(ppf,c)}
         case 1:
          var _Rn_=acc[2],_Ro_=acc[1];
          if(0 === _Rn_[0])
           {var acc$0=_Rn_[1];
            output_acc$0(ppf,_Ro_);
            var tag_name=compute_tag(output_acc$0,acc$0);
            if(ppf[22])
             {ppf[4] = [0,tag_name,ppf[4]];caml_call1(ppf[26],tag_name)}
            var _Rk_=ppf[23];
            return _Rk_?pp_enqueue(ppf,[0,0,[5,tag_name],0]):_Rk_}
          var acc$1=_Rn_[1];
          output_acc$0(ppf,_Ro_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _Rp_=acc[1];
          if(typeof _Rp_ === "number")
           var switch$1=1;
          else
           if(0 === _Rp_[0])
            {var _Rq_=_Rp_[2];
             if(typeof _Rq_ === "number")
              var switch$2=1;
             else
              if(1 === _Rq_[0])
               var
                s$0=acc[2],
                size=_Rq_[2],
                p$1=_Rp_[1],
                switch$0=0,
                switch$1=0,
                switch$2=0;
              else
               var switch$2=1;
             if(switch$2)var switch$1=1}
           else
            var switch$1=1;
          if(switch$1)var s=acc[2],p$0=_Rp_,switch$0=2;
          break;
         case 3:
          var _Rr_=acc[1];
          if(typeof _Rr_ === "number")
           var switch$3=1;
          else
           if(0 === _Rr_[0])
            {var _Rs_=_Rr_[2];
             if(typeof _Rs_ === "number")
              var switch$4=1;
             else
              if(1 === _Rs_[0])
               var
                c$1=acc[2],
                size$0=_Rs_[2],
                p$3=_Rr_[1],
                switch$0=1,
                switch$3=0,
                switch$4=0;
              else
               var switch$4=1;
             if(switch$4)var switch$3=1}
           else
            var switch$3=1;
          if(switch$3)var c$0=acc[2],p$2=_Rr_,switch$0=3;
          break;
         case 4:
          var _Rt_=acc[1];
          if(typeof _Rt_ === "number")
           var switch$5=1;
          else
           if(0 === _Rt_[0])
            {var _Ru_=_Rt_[2];
             if(typeof _Ru_ === "number")
              var switch$6=1;
             else
              if(1 === _Ru_[0])
               var
                s$0=acc[2],
                size=_Ru_[2],
                p$1=_Rt_[1],
                switch$0=0,
                switch$5=0,
                switch$6=0;
              else
               var switch$6=1;
             if(switch$6)var switch$5=1}
           else
            var switch$5=1;
          if(switch$5)var s=acc[2],p$0=_Rt_,switch$0=2;
          break;
         case 5:
          var _Rv_=acc[1];
          if(typeof _Rv_ === "number")
           var switch$7=1;
          else
           if(0 === _Rv_[0])
            {var _Rw_=_Rv_[2];
             if(typeof _Rw_ === "number")
              var switch$8=1;
             else
              if(1 === _Rw_[0])
               var
                c$1=acc[2],
                size$0=_Rw_[2],
                p$3=_Rv_[1],
                switch$0=1,
                switch$7=0,
                switch$8=0;
              else
               var switch$8=1;
             if(switch$8)var switch$7=1}
           else
            var switch$7=1;
          if(switch$7)var c$0=acc[2],p$2=_Rv_,switch$0=3;
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$1));
        case 2:
         output_acc$0(ppf,p$0);
         return pp_print_as(ppf,caml_ml_string_length(s),s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c$0)}}
    function fprintf$0(ppf)
     {return function(param)
       {var fmt=param[1],_Rj_=0;
        return make_printf
                (function(ppf,acc){output_acc$0(ppf,acc);return 0},
                 ppf,
                 _Rj_,
                 fmt)}}
    at_exit(print_flush);
    var null_char=0,default_token_buffer_size=1024;
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var s=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(s,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        var
         _Ri_=
          (caml_ml_bytes_length(s) - 1024 | 0) < 0
           ?invalid_arg(_h_)
           :caml_ml_input(ic,s,0,1024);
        lim[1] = _Ri_;
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(s,0))}
      return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create(default_token_buffer_size),
              iname]}
    from_ic(scan_raise_at_end,[1,_bX_,stdin],stdin);
    caml_fresh_oo_id(0);
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    try
     {caml_sys_getenv(_pW_)}
    catch(_Rh_)
     {_Rh_ = caml_wrap_exception(_Rh_);if(_Rh_ !== Not_found)throw _Rh_}
    try
     {caml_sys_getenv(_pV_)}
    catch(_Rg_)
     {_Rg_ = caml_wrap_exception(_Rg_);if(_Rg_ !== Not_found)throw _Rg_}
    var
     switch$0=
      caml_string_notequal(os_type,_bY_)
       ?caml_string_notequal(os_type,_bZ_)?1:0
       :0;
    function add$0(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$2(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    var Unix_error=[248,_b0_,caml_fresh_oo_id(0)];
    register_exception(_b3_,[0,Unix_error,0,_b2_,_b1_]);
    register_printer
     (function(param)
       {if(param[1] === Unix_error)
         {var s=param[4],s$0=param[3],e=param[2];
          if(typeof e === "number")
           {var _Rf_=e;
            if(34 <= _Rf_)
             switch(_Rf_)
              {case 34:var msg=_cB_;break;
               case 35:var msg=_cC_;break;
               case 36:var msg=_cD_;break;
               case 37:var msg=_cE_;break;
               case 38:var msg=_cF_;break;
               case 39:var msg=_cG_;break;
               case 40:var msg=_cH_;break;
               case 41:var msg=_cI_;break;
               case 42:var msg=_cJ_;break;
               case 43:var msg=_cK_;break;
               case 44:var msg=_cL_;break;
               case 45:var msg=_cM_;break;
               case 46:var msg=_cN_;break;
               case 47:var msg=_cO_;break;
               case 48:var msg=_cP_;break;
               case 49:var msg=_cQ_;break;
               case 50:var msg=_cR_;break;
               case 51:var msg=_cS_;break;
               case 52:var msg=_cT_;break;
               case 53:var msg=_cU_;break;
               case 54:var msg=_cV_;break;
               case 55:var msg=_cW_;break;
               case 56:var msg=_cX_;break;
               case 57:var msg=_cY_;break;
               case 58:var msg=_cZ_;break;
               case 59:var msg=_c0_;break;
               case 60:var msg=_c1_;break;
               case 61:var msg=_c2_;break;
               case 62:var msg=_c3_;break;
               case 63:var msg=_c4_;break;
               case 64:var msg=_c5_;break;
               case 65:var msg=_c6_;break;
               case 66:var msg=_c7_;break;
               default:var msg=_c8_}
            else
             switch(_Rf_)
              {case 0:var msg=_b4_;break;
               case 1:var msg=_b6_;break;
               case 2:var msg=_b7_;break;
               case 3:var msg=_b8_;break;
               case 4:var msg=_b9_;break;
               case 5:var msg=_b__;break;
               case 6:var msg=_b$_;break;
               case 7:var msg=_ca_;break;
               case 8:var msg=_cb_;break;
               case 9:var msg=_cc_;break;
               case 10:var msg=_cd_;break;
               case 11:var msg=_ce_;break;
               case 12:var msg=_cf_;break;
               case 13:var msg=_cg_;break;
               case 14:var msg=_ch_;break;
               case 15:var msg=_ci_;break;
               case 16:var msg=_cj_;break;
               case 17:var msg=_ck_;break;
               case 18:var msg=_cl_;break;
               case 19:var msg=_cm_;break;
               case 20:var msg=_cn_;break;
               case 21:var msg=_co_;break;
               case 22:var msg=_cp_;break;
               case 23:var msg=_cq_;break;
               case 24:var msg=_cr_;break;
               case 25:var msg=_cs_;break;
               case 26:var msg=_ct_;break;
               case 27:var msg=_cu_;break;
               case 28:var msg=_cv_;break;
               case 29:var msg=_cw_;break;
               case 30:var msg=_cx_;break;
               case 31:var msg=_cy_;break;
               case 32:var msg=_cz_;break;
               default:var msg=_cA_}}
          else
           var x=e[1],msg=caml_call1(sprintf(_c9_),x);
          return [0,caml_call3(sprintf(_b5_),msg,s$0,s)]}
        return 0});
    unix_inet_addr_of_string(_c__);
    unix_inet_addr_of_string(_c$_);
    try
     {unix_inet_addr_of_string(_pU_)}
    catch(_Re_)
     {_Re_ = caml_wrap_exception(_Re_);if(_Re_[1] !== Failure)throw _Re_}
    try
     {unix_inet_addr_of_string(_pT_)}
    catch(_Rd_)
     {_Rd_ = caml_wrap_exception(_Rd_);if(_Rd_[1] !== Failure)throw _Rd_}
    create$0(0,7);
    function dims(a)
     {var n=caml_ba_num_dims(a),d=caml_make_vect(n,0),_Ra_=n - 1 | 0,_Q$_=0;
      if(!(_Ra_ < 0))
       {var i=_Q$_;
        for(;;)
         {var _Rb_=caml_ba_dim(a,i);
          caml_check_bound(d,i)[i + 1] = _Rb_;
          var _Rc_=i + 1 | 0;
          if(_Ra_ !== i){var i=_Rc_;continue}
          break}}
      return d}
    function array1_of_genarray(a)
     {return 1 === caml_ba_num_dims(a)?a:invalid_arg(_da_)}
    var log2e=1.44269504088896339,log10e=0.434294481903251817;
    function zero$0(param)
     {switch(param)
       {case 0:return 0;
        case 1:return 0;
        case 2:return 0;
        case 3:return 0;
        case 4:return 0;
        case 5:return 0;
        case 6:return 0;
        case 7:return _db_;
        case 8:return 0;
        case 9:return 0;
        case 10:return zero;
        case 11:return zero;
        default:return 0}}
    function one$0(param)
     {switch(param)
       {case 0:return 1;
        case 1:return 1;
        case 2:return 1;
        case 3:return 1;
        case 4:return 1;
        case 5:return 1;
        case 6:return 1;
        case 7:return _dc_;
        case 8:return 1;
        case 9:return 1;
        case 10:return one;
        case 11:return one;
        default:return 1}}
    caml_fresh_oo_id(0);
    caml_fresh_oo_id(0);
    caml_fresh_oo_id(0);
    caml_fresh_oo_id(0);
    caml_fresh_oo_id(0);
    caml_fresh_oo_id(0);
    caml_fresh_oo_id(0);
    caml_fresh_oo_id(0);
    caml_fresh_oo_id(0);
    caml_fresh_oo_id(0);
    caml_fresh_oo_id(0);
    caml_fresh_oo_id(0);
    caml_fresh_oo_id(0);
    function make$1(param){return [0,0,0,[0]]}
    function push(s,x)
     {if(0 === s[2])s[3] = [0,x];
      if(s[1] === s[2])
       {var _Q9_=s[3];s[3] = append$0(_Q9_,copy(_Q9_));s[2] = s[3].length - 1}
      var _Q__=s[1];
      caml_check_bound(s[3],_Q__)[_Q__ + 1] = x;
      s[1] = s[1] + 1 | 0;
      return 0}
    function to_array(s){return sub$1(s[3],0,s[1])}
    function filter(f,x)
     {if(0 === x.length - 1)return [0];
      var r=make$1(0);
      iteri
       (function(i,y){var _Q8_=caml_call1(f,y);return _Q8_?push(r,y):_Q8_},x);
      return to_array(r)}
    function map$1(f,x)
     {var n=x.length - 1;
      if(0 === n)return [0];
      var r=make$1(0);
      iteri(function(i,y){return push(r,caml_call1(f,y))},x);
      return to_array(r)}
    function calc_conv2d_output_shape
     (padding,
      input_cols,
      input_rows,
      kernel_cols,
      kernel_rows,
      row_stride,
      col_stride)
     {var
       output_cols=
        0 === padding
         ?Math.ceil(input_cols / col_stride) | 0
         :Math.ceil((input_cols - kernel_cols + 1) / col_stride) | 0,
       output_rows=
        0 === padding
         ?Math.ceil(input_rows / row_stride) | 0
         :Math.ceil((input_rows - kernel_rows + 1) / row_stride) | 0;
      return [0,output_cols,output_rows]}
    function calc_conv2d_padding
     (input_cols,
      input_rows,
      kernel_cols,
      kernel_rows,
      output_cols,
      output_rows,
      row_stride,
      col_stride)
     {var
       pad_along_height=
        max
         ((caml_mul(output_rows - 1 | 0,row_stride) + kernel_rows | 0)
          -
          input_rows
          |
          0,
          0),
       pad_along_width=
        max
         ((caml_mul(output_cols - 1 | 0,col_stride) + kernel_cols | 0)
          -
          input_cols
          |
          0,
          0),
       pad_top=pad_along_height / 2 | 0,
       pad_bottom=pad_along_height - pad_top | 0,
       pad_left=pad_along_width / 2 | 0,
       pad_right=pad_along_width - pad_left | 0;
      return [0,pad_top,pad_left,pad_bottom,pad_right]}
    function calc_conv1d_output_shape
     (padding,input_cols,kernel_cols,col_stride)
     {return calc_conv2d_output_shape
               (padding,input_cols,1,kernel_cols,1,1,col_stride)
              [1]}
    function calc_conv3d_output_shape
     (padding,
      input_cols,
      input_rows,
      input_dpts,
      kernel_cols,
      kernel_rows,
      kernel_dpts,
      row_stride,
      col_stride,
      dpt_stride)
     {var
       output_cols=
        0 === padding
         ?Math.ceil(input_cols / col_stride) | 0
         :Math.ceil((input_cols - kernel_cols + 1) / col_stride) | 0,
       output_rows=
        0 === padding
         ?Math.ceil(input_rows / row_stride) | 0
         :Math.ceil((input_rows - kernel_rows + 1) / row_stride) | 0,
       output_dpts=
        0 === padding
         ?Math.ceil(input_dpts / dpt_stride) | 0
         :Math.ceil((input_dpts - kernel_dpts + 1) / dpt_stride) | 0;
      return [0,output_cols,output_rows,output_dpts]}
    function calc_conv3d_padding
     (input_cols,
      input_rows,
      input_depth,
      kernel_cols,
      kernel_rows,
      kernel_depth,
      output_cols,
      output_rows,
      output_depth,
      row_stride,
      col_stride,
      depth_stride)
     {var
       pad_along_height=
        max
         ((caml_mul(output_rows - 1 | 0,row_stride) + kernel_rows | 0)
          -
          input_rows
          |
          0,
          0),
       pad_along_width=
        max
         ((caml_mul(output_cols - 1 | 0,col_stride) + kernel_cols | 0)
          -
          input_cols
          |
          0,
          0),
       pad_along_depth=
        max
         ((caml_mul(output_depth - 1 | 0,depth_stride) + kernel_depth | 0)
          -
          input_depth
          |
          0,
          0),
       pad_top=pad_along_height / 2 | 0,
       pad_bottom=pad_along_height - pad_top | 0,
       pad_left=pad_along_width / 2 | 0,
       pad_right=pad_along_width - pad_left | 0,
       pad_shallow=pad_along_depth / 2 | 0,
       pad_deep=pad_along_depth - pad_shallow | 0;
      return [0,pad_top,pad_left,pad_shallow,pad_bottom,pad_right,pad_deep]}
    function calc_stride(s)
     {var d=s.length - 1,r=caml_make_vect(d,1),_Q1_=d - 1 | 0,_Q0_=1;
      if(!(_Q1_ < 1))
       {var i=_Q0_;
        for(;;)
         {var
           _Q2_=d - i | 0,
           _Q4_=d - i | 0,
           _Q3_=caml_check_bound(r,_Q2_)[_Q2_ + 1],
           _Q6_=(d - i | 0) - 1 | 0,
           _Q5_=caml_mul(caml_check_bound(s,_Q4_)[_Q4_ + 1],_Q3_);
          caml_check_bound(r,_Q6_)[_Q6_ + 1] = _Q5_;
          var _Q7_=i + 1 | 0;
          if(_Q1_ !== i){var i=_Q7_;continue}
          break}}
      return r}
    function marshal_to_file(x,f)
     {var
       s=caml_output_value_to_string(x,0),
       h=caml_ml_open_descriptor_out(caml_sys_open(f,mode,438));
      caml_ml_set_channel_name(h,f);
      output_string(h,s);
      caml_ml_flush(h);
      return caml_ml_close_channel(h)}
    function marshal_from_file(f)
     {var h=caml_ml_open_descriptor_in(caml_sys_open(f,mode$0,0));
      caml_ml_set_channel_name(h,f);
      var len$2=caml_ml_channel_size(h),s=caml_create_bytes(len$2),ofs$1=0;
      if(0 <= len$2)
       if((caml_ml_bytes_length(s) - len$2 | 0) < 0)
        var switch$0=0;
       else
        {var ofs=ofs$1,len=len$2;
         for(;;)
          {if(0 < len)
            {var r=caml_ml_input(h,s,ofs,len);
             if(0 === r)throw End_of_file;
             var len$0=len - r | 0,ofs$0=ofs + r | 0,ofs=ofs$0,len=len$0;
             continue}
           var switch$0=1;
           break}}
      else
       var switch$0=0;
      if(!switch$0)invalid_arg(_i_);
      if((caml_ml_bytes_length(s) - 20 | 0) < 0)return invalid_arg(_z_);
      var len$1=caml_marshal_data_size(s,0);
      return (caml_ml_bytes_length(s) - (20 + len$1 | 0) | 0) < 0
              ?invalid_arg(_A_)
              :caml_input_value_from_string(s,0)}
    function string_of_array(opt,_QZ_,_QY_,string_of_x,x$0)
     {if(opt)var sth=opt[1],prefix=sth;else var prefix=_dt_;
      if(_QZ_)var sth$0=_QZ_[1],suffix=sth$0;else var suffix=_ds_;
      if(_QY_)var sth$1=_QY_[1],sep=sth$1;else var sep=_dr_;
      var l=map(string_of_x,to_list(x$0));
      if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _QT_=param[2],_QU_=param[1];
            if(_QT_)
             {var
               x=(caml_ml_string_length(_QU_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(_w_),
               acc=acc$0,
               param=_QT_;
              continue}
            var _QX_=caml_ml_string_length(_QU_) + acc | 0}
          else
           var _QX_=acc;
          var dst=caml_create_bytes(_QX_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _QV_=param$0[2],_QW_=param$0[1];
              if(_QV_)
               {caml_blit_string(_QW_,0,dst,pos,caml_ml_string_length(_QW_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_QW_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_QW_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_QV_;
                continue}
              caml_blit_string(_QW_,0,dst,pos,caml_ml_string_length(_QW_));
              var s=dst}
            else
             var s=dst;
            break}
          break}}
      else
       var s=_x_;
      return caml_call3(sprintf(_dq_),prefix,s,suffix)}
    function aarr_map(f,x)
     {return map$1(function(_QS_){return map$1(f,_QS_)},x)}
    function aarr_map2(f,x,y)
     {return map2(function(_QQ_,_QR_){return map2(f,_QQ_,_QR_)},x,y)}
    function format_time(t)
     {if(t < 60)return caml_call1(sprintf(_du_),t | 0);
      if(60 <= t)
       if(t < 3600)
        {var m=t / 60 | 0,s=(t | 0) % 60 | 0;
         return caml_call2(sprintf(_dv_),m,s)}
      var h=t / 3600 | 0,m$0=(t / 60 | 0) % 60 | 0;
      return caml_call2(sprintf(_dw_),h,m$0)}
    function eps(param)
     {switch(param)
       {case 0:return 1.1920928955078125e-07;
        case 1:return 2.22044604925031308e-16;
        case 10:return 1.1920928955078125e-07;
        case 11:return 2.22044604925031308e-16;
        default:return failwith(_dx_)}}
    function Make(A)
     {var global_tag=[0,0];
      function tag(param)
       {global_tag[1] = global_tag[1] + 1 | 0;return global_tag[1]}
      function cmp_tag(ai,bi)
       {return caml_greaterthan(ai,bi)?1:caml_lessthan(ai,bi)?-1:0}
      function reset_zero(param)
       {switch(param[0])
         {case 0:return _dy_;
          case 1:var ap=param[1];caml_call1(A[17],ap);return [1,ap];
          default:return failwith(_dz_)}}
      function primal(ap)
       {switch(ap[0])
         {case 2:var ap$0=ap[1];return ap$0;
          case 3:var ap$1=ap[1];return ap$1;
          default:return ap}}
      function primal$0(ap)
       {var ap$0=ap;
        for(;;)
         switch(ap$0[0])
          {case 2:var ap$1=ap$0[1],ap$0=ap$1;continue;
           case 3:var ap$2=ap$0[1],ap$0=ap$2;continue;
           default:return ap$0}}
      function zero(param)
       {var param$0=param;
        for(;;)
         switch(param$0[0])
          {case 0:return _dA_;
           case 1:
            var ap=param$0[1],_QP_=caml_call1(A[10],ap);
            return [1,caml_call1(A[2],_QP_)];
           case 2:
            var ap$0=param$0[1],param$1=primal$0(ap$0),param$0=param$1;
            continue;
           default:
            var ap$1=param$0[1],param$2=primal$0(ap$1),param$0=param$2;
            continue}}
      function tangent(ap)
       {switch(ap[0])
         {case 2:var at=ap[2];return at;
          case 3:return failwith(_dB_);
          default:return zero(ap)}}
      function adjref(ap)
       {switch(ap[0])
         {case 2:return failwith(_dC_);
          case 3:var at=ap[2];return at;
          default:return [0,zero(ap)]}}
      function adjval(ap)
       {switch(ap[0])
         {case 2:return failwith(_dD_);
          case 3:var at=ap[2];return at[1];
          default:return zero(ap)}}
      function shape(x)
       {var match=primal$0(x);
        if(1 === match[0]){var ap=match[1];return caml_call1(A[10],ap)}
        return failwith(_dE_)}
      function row_num(x){return caml_check_bound(shape(x),0)[1]}
      function col_num(x){return caml_check_bound(shape(x),1)[2]}
      function numel(x)
       {var match=primal$0(x);
        if(1 === match[0]){var x$0=match[1];return caml_call1(A[11],x$0)}
        return failwith(_dF_)}
      function clip_by_value(amin,amax,x)
       {var match=primal$0(x);
        if(1 === match[0])
         {var x$0=match[1];return [1,caml_call3(A[63],[0,amin],[0,amax],x$0)]}
        return failwith(_dG_)}
      function clip_by_l2norm(a,x)
       {var match=primal$0(x);
        if(1 === match[0])
         {var x$0=match[1];return [1,caml_call2(A[64],a,x$0)]}
        return failwith(_dH_)}
      function copy_primal(x)
       {var match=primal$0(x);
        if(1 === match[0]){var ap=match[1];return [1,caml_call1(A[16],ap)]}
        return failwith(_dI_)}
      function tile(x,reps)
       {var match=primal$0(x);
        if(1 === match[0])
         {var x$0=match[1];return [1,caml_call2(A[20],x$0,reps)]}
        return failwith(_dJ_)}
      function repeat(axis,x,reps)
       {var match=primal$0(x);
        if(1 === match[0])
         {var x$0=match[1];return [1,caml_call3(A[21],axis,x$0,reps)]}
        return failwith(_dK_)}
      function pack_arr(x){return [1,x]}
      function unpack_arr(x)
       {var match=primal(x);
        if(1 === match[0]){var x$0=match[1];return x$0}
        return failwith(_dL_)}
      function pack_flt(x){return [0,x]}
      function unpack_flt(x)
       {var match=primal(x);
        if(0 === match[0]){var x$0=match[1];return x$0}
        return failwith(_dM_)}
      function deep_info(x)
       {var match=primal$0(x);
        switch(match[0])
         {case 0:var a=match[1];return caml_call1(sprintf(_dN_),a);
          case 1:
           var
            a$0=match[1],
            _QO_=string_of_array(0,0,0,string_of_int,caml_call1(A[10],a$0));
           return caml_call1(sprintf(_dO_),_QO_);
          default:return _dP_}}
      function type_info(x)
       {switch(x[0])
         {case 0:var _QK_=deep_info(x);return caml_call1(sprintf(_dQ_),_QK_);
          case 1:var _QL_=deep_info(x);return caml_call1(sprintf(_dR_),_QL_);
          case 2:
           var ai=x[3],ap=x[1],_QM_=deep_info(ap);
           return caml_call2(sprintf(_dS_),ai,_QM_);
          default:
           var ai$0=x[5],ap$0=x[1],_QN_=deep_info(ap$0);
           return caml_call2(sprintf(_dT_),ai$0,_QN_)}}
      function error_binop(op,a,b)
       {var s0=_d_(_dU_,type_info(a)),s1=_d_(_dV_,type_info(b));
        return failwith(_d_(op,_d_(_dX_,_d_(s0,_d_(_dW_,s1)))))}
      function error_uniop(op,a)
       {var s=type_info(a);return failwith(_d_(op,_d_(_dY_,s)))}
      function noop(param){return 0}
      function op_d_d(a,ff,fd,df,r)
       {switch(a[0])
         {case 2:
           var ai=a[3],at=a[2],ap=a[1],cp=caml_call1(fd,ap);
           return [2,cp,caml_call3(df,cp,ap,at),ai];
          case 3:
           var
            ai$0=a[5],
            ap$0=a[1],
            cp$0=caml_call1(fd,ap$0),
            _QJ_=caml_call1(r,a);
           return [3,cp$0,[0,zero(cp$0)],_QJ_,[0,0],ai$0];
          default:return caml_call1(ff,a)}}
      function op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)
       {switch(a[0])
         {case 0:
           switch(b[0])
            {case 2:
              var bi=b[3],bt=b[2],bp=b[1],cp=caml_call2(fd,a,bp);
              return [2,cp,caml_call3(df_db,cp,bp,bt),bi];
             case 3:
              var
               bi$0=b[5],
               bp$0=b[1],
               cp$0=caml_call2(fd,a,bp$0),
               _Qv_=caml_call2(r_c_d,a,b);
              return [3,cp$0,[0,zero(cp$0)],_Qv_,[0,0],bi$0]
             }
           break;
          case 1:
           switch(b[0])
            {case 2:
              var bi$1=b[3],bt$0=b[2],bp$1=b[1],cp$1=caml_call2(fd,a,bp$1);
              return [2,cp$1,caml_call3(df_db,cp$1,bp$1,bt$0),bi$1];
             case 3:
              var
               bi$2=b[5],
               bp$2=b[1],
               cp$2=caml_call2(fd,a,bp$2),
               _Qw_=caml_call2(r_c_d,a,b);
              return [3,cp$2,[0,zero(cp$2)],_Qw_,[0,0],bi$2]
             }
           break;
          case 2:
           var _Qx_=a[3],_Qy_=a[2],_Qz_=a[1];
           switch(b[0])
            {case 0:
              var cp$3=caml_call2(fd,_Qz_,b);
              return [2,cp$3,caml_call3(df_da,cp$3,_Qz_,_Qy_),_Qx_];
             case 1:
              var cp$4=caml_call2(fd,_Qz_,b);
              return [2,cp$4,caml_call3(df_da,cp$4,_Qz_,_Qy_),_Qx_];
             case 2:
              var bi$3=b[3],bt$1=b[2],bp$3=b[1],match=cmp_tag(_Qx_,bi$3);
              if(0 === match)
               {var cp$5=caml_call2(fd,_Qz_,bp$3);
                return [2,
                        cp$5,
                        caml_call5(df_dab,cp$5,_Qz_,_Qy_,bp$3,bt$1),
                        _Qx_]}
              if(1 === match)
               {var cp$6=caml_call2(fd,_Qz_,b);
                return [2,cp$6,caml_call3(df_da,cp$6,_Qz_,_Qy_),_Qx_]}
              var cp$7=caml_call2(fd,a,bp$3);
              return [2,cp$7,caml_call3(df_db,cp$7,bp$3,bt$1),bi$3];
             default:
              var
               bi$4=b[5],
               bp$4=b[1],
               match$0=cmp_tag(_Qx_,bi$4),
               switcher=match$0 + 1 | 0;
              if(!(2 < switcher >>> 0))
               switch(switcher)
                {case 0:
                  var cp$8=caml_call2(fd,a,bp$4),_QA_=caml_call2(r_c_d,a,b);
                  return [3,cp$8,[0,zero(cp$8)],_QA_,[0,0],bi$4];
                 case 1:break;
                 default:
                  var cp$9=caml_call2(fd,_Qz_,b);
                  return [2,cp$9,caml_call3(df_da,cp$9,_Qz_,_Qy_),_Qx_]}
              return failwith(_dZ_)}
          default:
           var _QB_=a[5],_QC_=a[1];
           switch(b[0])
            {case 0:
              var cp$10=caml_call2(fd,_QC_,b),_QD_=caml_call2(r_d_c,a,b);
              return [3,cp$10,[0,zero(cp$10)],_QD_,[0,0],_QB_];
             case 1:
              var cp$11=caml_call2(fd,_QC_,b),_QE_=caml_call2(r_d_c,a,b);
              return [3,cp$11,[0,zero(cp$11)],_QE_,[0,0],_QB_];
             case 2:
              var
               bi$5=b[3],
               bt$2=b[2],
               bp$5=b[1],
               match$1=cmp_tag(_QB_,bi$5),
               switcher$0=match$1 + 1 | 0;
              if(!(2 < switcher$0 >>> 0))
               switch(switcher$0)
                {case 0:
                  var cp$12=caml_call2(fd,a,bp$5);
                  return [2,cp$12,caml_call3(df_db,cp$12,bp$5,bt$2),bi$5];
                 case 1:break;
                 default:
                  var cp$13=caml_call2(fd,_QC_,b),_QF_=caml_call2(r_d_c,a,b);
                  return [3,cp$13,[0,zero(cp$13)],_QF_,[0,0],_QB_]}
              return failwith(_d0_);
             default:
              var bi$6=b[5],bp$6=b[1],match$2=cmp_tag(_QB_,bi$6);
              if(0 === match$2)
               {var cp$14=caml_call2(fd,_QC_,bp$6),_QG_=caml_call2(r_d_d,a,b);
                return [3,cp$14,[0,zero(cp$14)],_QG_,[0,0],_QB_]}
              if(1 === match$2)
               {var cp$15=caml_call2(fd,_QC_,b),_QH_=caml_call2(r_d_c,a,b);
                return [3,cp$15,[0,zero(cp$15)],_QH_,[0,0],_QB_]}
              var cp$16=caml_call2(fd,a,bp$6),_QI_=caml_call2(r_c_d,a,b);
              return [3,cp$16,[0,zero(cp$16)],_QI_,[0,0],bi$6]}}
        return caml_call2(ff,a,b)}
      function add$0(a,b)
       {function ff(a,b)
         {switch(a[0])
           {case 0:
             var _Qt_=a[1];
             switch(b[0])
              {case 0:var b$0=b[1];return [0,caml_call2(A[145][1],_Qt_,b$0)];
               case 1:var b$1=b[1];return [1,caml_call2(A[79],_Qt_,b$1)]
               }
             break;
            case 1:
             var _Qu_=a[1];
             switch(b[0])
              {case 0:var b$2=b[1];return [1,caml_call2(A[75],_Qu_,b$2)];
               case 1:var b$3=b[1];return [1,caml_call2(A[71],_Qu_,b$3)]
               }
             break
            }
          return error_binop(_d1_,a,b)}
        function fd(a,b){return _Mv_(a,b)}
        function df_da(cp,ap,at){return at}
        function df_db(cp,bp,bt){return bt}
        function df_dab(cp,ap,at,bp,bt){return _Mv_(at,bt)}
        function r_d_d(a,b){return [0,a,b]}
        function r_d_c(a,b){return [1,a,b]}
        function r_c_d(a,b){return [2,a,b]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function _Mv_(a,b){return add$0(a,b)}
      function sub(a,b)
       {function ff(a,b)
         {switch(a[0])
           {case 0:
             var _Qr_=a[1];
             switch(b[0])
              {case 0:var b$0=b[1];return [0,caml_call2(A[145][2],_Qr_,b$0)];
               case 1:var b$1=b[1];return [1,caml_call2(A[80],_Qr_,b$1)]
               }
             break;
            case 1:
             var _Qs_=a[1];
             switch(b[0])
              {case 0:var b$2=b[1];return [1,caml_call2(A[76],_Qs_,b$2)];
               case 1:var b$3=b[1];return [1,caml_call2(A[72],_Qs_,b$3)]
               }
             break
            }
          return error_binop(_d2_,a,b)}
        function fd(a,b){return _Mw_(a,b)}
        function df_da(cp,ap,at){return at}
        function df_db(cp,bp,bt){return neg(bt)}
        function df_dab(cp,ap,at,bp,bt){return _Mw_(at,bt)}
        function r_d_d(a,b){return [3,a,b]}
        function r_d_c(a,b){return [4,a,b]}
        function r_c_d(a,b){return [5,a,b]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function _Mw_(a,b){return sub(a,b)}
      function mul(a,b)
       {function ff(a,b)
         {switch(a[0])
           {case 0:
             var _Qp_=a[1];
             switch(b[0])
              {case 0:var b$0=b[1];return [0,caml_call2(A[145][3],_Qp_,b$0)];
               case 1:var b$1=b[1];return [1,caml_call2(A[81],_Qp_,b$1)]
               }
             break;
            case 1:
             var _Qq_=a[1];
             switch(b[0])
              {case 0:var b$2=b[1];return [1,caml_call2(A[77],_Qq_,b$2)];
               case 1:var b$3=b[1];return [1,caml_call2(A[73],_Qq_,b$3)]
               }
             break
            }
          return error_binop(_d3_,a,b)}
        function fd(a,b){return _Mx_(a,b)}
        function df_da(cp,ap,at){return _Mx_(at,b)}
        function df_db(cp,bp,bt){return _Mx_(a,bt)}
        function df_dab(cp,ap,at,bp,bt)
         {var _Qo_=_Mx_(at,bp);return _Mv_(_Mx_(ap,bt),_Qo_)}
        function r_d_d(a,b){return [6,a,b]}
        function r_d_c(a,b){return [7,a,b]}
        function r_c_d(a,b){return [8,a,b]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function _Mx_(a,b){return mul(a,b)}
      function div(a,b)
       {function ff(a,b)
         {switch(a[0])
           {case 0:
             var _Qm_=a[1];
             switch(b[0])
              {case 0:var b$0=b[1];return [0,caml_call2(A[145][4],_Qm_,b$0)];
               case 1:var b$1=b[1];return [1,caml_call2(A[82],_Qm_,b$1)]
               }
             break;
            case 1:
             var _Qn_=a[1];
             switch(b[0])
              {case 0:var b$2=b[1];return [1,caml_call2(A[78],_Qn_,b$2)];
               case 1:var b$3=b[1];return [1,caml_call2(A[74],_Qn_,b$3)]
               }
             break
            }
          return error_binop(_d4_,a,b)}
        function fd(a,b){return _My_(a,b)}
        function df_da(cp,ap,at){return _My_(at,b)}
        function df_db(cp,bp,bt){return _My_(_Mx_(neg(bt),cp),bp)}
        function df_dab(cp,ap,at,bp,bt){return _My_(_Mw_(at,_Mx_(bt,cp)),bp)}
        function r_d_d(a,b){return [9,a,b]}
        function r_d_c(a,b){return [10,a,b]}
        function r_c_d(a,b){return [11,a,b]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function _My_(a,b){return div(a,b)}
      function pow(a,b)
       {function ff(a,b)
         {switch(a[0])
           {case 0:
             var _Qk_=a[1];
             switch(b[0])
              {case 0:var b$0=b[1];return [0,caml_call2(A[145][5],_Qk_,b$0)];
               case 1:var b$1=b[1];return [1,caml_call2(A[66],_Qk_,b$1)]
               }
             break;
            case 1:
             var _Ql_=a[1];
             switch(b[0])
              {case 0:var b$2=b[1];return [1,caml_call2(A[67],_Ql_,b$2)];
               case 1:var b$3=b[1];return [1,caml_call2(A[65],_Ql_,b$3)]
               }
             break
            }
          return error_binop(_d5_,a,b)}
        function fd(a,b){return _Mz_(a,b)}
        function df_da(cp,ap,at)
         {return _Mx_(_Mx_(at,_Mz_(ap,_Mw_(b,_d6_))),b)}
        function df_db(cp,bp,bt)
         {var _Qj_=log(a);return _Mx_(_Mx_(bt,cp),_Qj_)}
        function df_dab(cp,ap,at,bp,bt)
         {var
           _Qg_=log(ap),
           _Qh_=_Mx_(_Mx_(ap,bt),_Qg_),
           _Qi_=_Mv_(_Mx_(at,bp),_Qh_);
          return _Mx_(_Mz_(ap,_Mw_(bp,_d7_)),_Qi_)}
        function r_d_d(a,b){return [12,a,b]}
        function r_d_c(a,b){return [13,a,b]}
        function r_c_d(a,b){return [14,a,b]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function _Mz_(a,b){return pow(a,b)}
      function atan2(a,b)
       {function ff(a,b)
         {switch(a[0])
           {case 0:
             var _Qe_=a[1];
             switch(b[0])
              {case 0:var b$0=b[1];return [0,caml_call2(A[145][6],_Qe_,b$0)];
               case 1:var b$1=b[1];return [1,caml_call2(A[69],_Qe_,b$1)]
               }
             break;
            case 1:
             var _Qf_=a[1];
             switch(b[0])
              {case 0:var b$2=b[1];return [1,caml_call2(A[70],_Qf_,b$2)];
               case 1:var b$3=b[1];return [1,caml_call2(A[68],_Qf_,b$3)]
               }
             break
            }
          return error_binop(_d8_,a,b)}
        function fd(a,b){return atan2(a,b)}
        function df_da(cp,ap,at)
         {var _Qc_=sqr(b),_Qd_=_Mv_(sqr(ap),_Qc_);
          return _My_(_Mx_(at,b),_Qd_)}
        function df_db(cp,bp,bt)
         {var _Qa_=sqr(bp),_Qb_=_Mv_(sqr(a),_Qa_);
          return _My_(_Mx_(neg(bt),a),_Qb_)}
        function df_dab(cp,ap,at,bp,bt)
         {var _P9_=sqr(bp),_P__=_Mv_(sqr(ap),_P9_),_P$_=_Mx_(bt,ap);
          return _My_(_Mw_(_Mx_(at,bp),_P$_),_P__)}
        function r_d_d(a,b){return [15,a,b]}
        function r_d_c(a,b){return [16,a,b]}
        function r_c_d(a,b){return [17,a,b]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function min2(a,b)
       {var _P8_=abs(_Mw_(a,b));return _My_(_Mw_(_Mv_(a,b),_P8_),_d9_)}
      function max2(a,b)
       {var _P7_=abs(_Mw_(b,a));return _My_(_Mv_(_Mv_(a,b),_P7_),_d__)}
      function neg(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][8],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[30],a$1)];
            default:return error_uniop(_d$_,a)}}
        function fd(a){return neg(a)}
        function df(cp,ap,at){return _Mw_(_ea_,at)}
        function r(a){return [18,a]}
        return op_d_d(a,ff,fd,df,r)}
      function abs(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][7],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[29],a$1)];
            default:return error_uniop(_eb_,a)}}
        function fd(a){return abs(a)}
        function df(cp,ap,at){return _Mx_(at,signum(ap))}
        function r(a){return [19,a]}
        return op_d_d(a,ff,fd,df,r)}
      function signum(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][15],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[54],a$1)];
            default:return error_uniop(_ec_,a)}}
        function fd(a){return signum(a)}
        function df(cp,ap,at){return zero(ap)}
        function r(a){return [20,a]}
        return op_d_d(a,ff,fd,df,r)}
      function floor(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][16],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[31],a$1)];
            default:return error_uniop(_ed_,a)}}
        function fd(a){return floor(a)}
        function df(cp,ap,at){return zero(ap)}
        function r(a){return [21,a]}
        return op_d_d(a,ff,fd,df,r)}
      function ceil(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][17],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[32],a$1)];
            default:return error_uniop(_ee_,a)}}
        function fd(a){return ceil(a)}
        function df(cp,ap,at){return zero(ap)}
        function r(a){return [22,a]}
        return op_d_d(a,ff,fd,df,r)}
      function round(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][18],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[33],a$1)];
            default:return error_uniop(_ef_,a)}}
        function fd(a){return round(a)}
        function df(cp,ap,at){return zero(ap)}
        function r(a){return [23,a]}
        return op_d_d(a,ff,fd,df,r)}
      function sqr(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][9],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[34],a$1)];
            default:return error_uniop(_eg_,a)}}
        function fd(a){return sqr(a)}
        function df(cp,ap,at){return _Mx_(_Mx_(_eh_,at),ap)}
        function r(a){return [24,a]}
        return op_d_d(a,ff,fd,df,r)}
      function sqrt(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][10],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[35],a$1)];
            default:return error_uniop(_ei_,a)}}
        function fd(a){return sqrt(a)}
        function df(cp,ap,at){return _My_(at,_Mx_(_ej_,cp))}
        function r(a){return [25,a]}
        return op_d_d(a,ff,fd,df,r)}
      function log(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][12],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[36],a$1)];
            default:return error_uniop(_ek_,a)}}
        function fd(a){return log(a)}
        function df(cp,ap,at){return _My_(at,ap)}
        function r(a){return [26,a]}
        return op_d_d(a,ff,fd,df,r)}
      function log2(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][13],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[37],a$1)];
            default:return error_uniop(_el_,a)}}
        function fd(a){return log2(a)}
        function df(cp,ap,at){return _My_(at,_Mx_(ap,[0,log2e]))}
        function r(a){return [27,a]}
        return op_d_d(a,ff,fd,df,r)}
      function log10(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][14],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[38],a$1)];
            default:return error_uniop(_em_,a)}}
        function fd(a){return log10(a)}
        function df(cp,ap,at){return _My_(at,_Mx_(ap,[0,log10e]))}
        function r(a){return [28,a]}
        return op_d_d(a,ff,fd,df,r)}
      function exp(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][11],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[39],a$1)];
            default:return error_uniop(_en_,a)}}
        function fd(a){return exp(a)}
        function df(cp,ap,at){return _Mx_(at,cp)}
        function r(a){return [29,a]}
        return op_d_d(a,ff,fd,df,r)}
      function sin(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][19],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[40],a$1)];
            default:return error_uniop(_eo_,a)}}
        function fd(a){return sin(a)}
        function df(cp,ap,at){return _Mx_(at,cos(ap))}
        function r(a){return [30,a]}
        return op_d_d(a,ff,fd,df,r)}
      function cos(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][20],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[41],a$1)];
            default:return error_uniop(_ep_,a)}}
        function fd(a){return cos(a)}
        function df(cp,ap,at){return neg(_Mx_(at,sin(ap)))}
        function r(a){return [31,a]}
        return op_d_d(a,ff,fd,df,r)}
      function tan(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][21],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[42],a$1)];
            default:return error_uniop(_eq_,a)}}
        function fd(a){return tan(a)}
        function df(cp,ap,at){return _My_(at,sqr(cos(ap)))}
        function r(a){return [32,a]}
        return op_d_d(a,ff,fd,df,r)}
      function sinh(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][22],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[43],a$1)];
            default:return error_uniop(_er_,a)}}
        function fd(a){return sinh(a)}
        function df(cp,ap,at){return _Mx_(at,cosh(ap))}
        function r(a){return [33,a]}
        return op_d_d(a,ff,fd,df,r)}
      function cosh(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][23],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[44],a$1)];
            default:return error_uniop(_es_,a)}}
        function fd(a){return cosh(a)}
        function df(cp,ap,at){return _Mx_(at,sinh(ap))}
        function r(a){return [34,a]}
        return op_d_d(a,ff,fd,df,r)}
      function tanh(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][24],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[45],a$1)];
            default:return error_uniop(_et_,a)}}
        function fd(a){return tanh(a)}
        function df(cp,ap,at){return _My_(at,sqr(cosh(ap)))}
        function r(a){return [35,a]}
        return op_d_d(a,ff,fd,df,r)}
      function asin(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][25],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[46],a$1)];
            default:return error_uniop(_eu_,a)}}
        function fd(a){return asin(a)}
        function df(cp,ap,at){return _My_(at,sqrt(_Mw_(_ev_,sqr(ap))))}
        function r(a){return [36,a]}
        return op_d_d(a,ff,fd,df,r)}
      function acos(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][26],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[47],a$1)];
            default:return error_uniop(_ew_,a)}}
        function fd(a){return acos(a)}
        function df(cp,ap,at)
         {var _P6_=sqrt(_Mw_(_ex_,sqr(ap)));return _My_(neg(at),_P6_)}
        function r(a){return [37,a]}
        return op_d_d(a,ff,fd,df,r)}
      function atan(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][27],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[48],a$1)];
            default:return error_uniop(_ey_,a)}}
        function fd(a){return atan(a)}
        function df(cp,ap,at){return _My_(at,_Mv_(_ez_,sqr(ap)))}
        function r(a){return [38,a]}
        return op_d_d(a,ff,fd,df,r)}
      function asinh(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][28],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[49],a$1)];
            default:return error_uniop(_eA_,a)}}
        function fd(a){return asinh(a)}
        function df(cp,ap,at){return _My_(at,sqrt(_Mv_(sqr(ap),_eB_)))}
        function r(a){return [39,a]}
        return op_d_d(a,ff,fd,df,r)}
      function acosh(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][29],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[50],a$1)];
            default:return error_uniop(_eC_,a)}}
        function fd(a){return acosh(a)}
        function df(cp,ap,at){return _My_(at,sqrt(_Mw_(sqr(ap),_eD_)))}
        function r(a){return [40,a]}
        return op_d_d(a,ff,fd,df,r)}
      function atanh(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][30],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[51],a$1)];
            default:return error_uniop(_eE_,a)}}
        function fd(a){return atanh(a)}
        function df(cp,ap,at){return _My_(at,_Mw_(_eF_,sqr(ap)))}
        function r(a){return [41,a]}
        return op_d_d(a,ff,fd,df,r)}
      function get_item(a,i,j)
       {switch(a[0])
         {case 0:return error_uniop(_eG_,a);
          case 1:var ap=a[1];return [0,caml_call2(A[12],ap,[0,i,j])];
          case 2:
           var ai=a[3],at=a[2],ap$0=a[1],_P5_=get_item(at,i,j);
           return [2,get_item(ap$0,i,j),_P5_,ai];
          default:
           var ai$0=a[5],ap$1=a[1];
           return [3,get_item(ap$1,i,j),[0,_eH_],[42,a,i,j],[0,0],ai$0]}}
      function set_item(a,i,j,b)
       {function ff(a,match)
         {if(1 === a[0])
           if(0 === match[0])
            {var b=match[1],a$0=a[1],aa=caml_call1(A[16],a$0);
             caml_call3(A[13],aa,[0,i,j],b);
             return [1,aa]}
          return error_uniop(_eI_,a)}
        function fd(a,b){return set_item(a,i,j,b)}
        function df_da(cp,ap,at){return set_item(at,i,j,_eJ_)}
        function df_db(cp,bp,bt){return add_item(zero(a),i,j,bt)}
        function df_dab(cp,ap,at,bp,bt){return set_item(at,i,j,bt)}
        function r_d_d(a,b){return [43,a,i,j,b]}
        function r_d_c(a,b){return [44,a,i,j,b]}
        function r_c_d(a,b){return [45,a,i,j,b]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function add_item(a,i,j,b)
       {function ff(a,match)
         {if(1 === a[0])
           if(0 === match[0])
            {var
              b=match[1],
              a$0=a[1],
              aa=caml_call1(A[16],a$0),
              _P3_=caml_call2(A[12],aa,[0,i,j]),
              _P4_=caml_call2(A[145][1],_P3_,b);
             caml_call3(A[13],aa,[0,i,j],_P4_);
             return [1,aa]}
          return error_binop(_eK_,a,match)}
        function fd(a,b){return add_item(a,i,j,b)}
        function df_da(cp,ap,at){return at}
        function df_db(cp,bp,bt){return add_item(zero(a),i,j,bt)}
        function df_dab(cp,ap,at,bp,bt){return add_item(at,i,j,bt)}
        function r_d_d(a,b){return [46,a,i,j,b]}
        function r_d_c(a,b){return [47,a,i,j,b]}
        function r_c_d(a,b){return [48,a,i,j,b]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function get_slice(i,a)
       {function ff(param)
         {if(1 === param[0])
           {var a$0=param[1];return [1,caml_call2(A[14],i,a$0)]}
          return error_uniop(_eL_,a)}
        function fd(a){return get_slice(i,a)}
        function df(cp,ap,at){return get_slice(i,at)}
        function r(a){return [49,a,i]}
        return op_d_d(a,ff,fd,df,r)}
      function set_slice(i,a,b)
       {function ff(a,match)
         {if(1 === a[0])
           if(1 === match[0])
            {var b=match[1],a$0=a[1],a$1=caml_call1(A[16],a$0);
             caml_call3(A[15],i,a$1,b);
             return [1,a$1]}
          return error_binop(_eM_,a,match)}
        function fd(a,b){return set_slice(i,a,b)}
        function df_da(cp,ap,at){return set_slice(i,at,zero(b))}
        function df_db(cp,bp,bt){return set_slice(i,zero(a),bt)}
        function df_dab(cp,ap,at,bp,bt){return set_slice(i,at,bt)}
        function r_d_d(a,b){return [50,a,b,i]}
        function r_d_c(a,b){return [51,a,b,i]}
        function r_c_d(a,b){return [52,a,b,i]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function sum(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,a$0];
            case 1:var a$1=param[1];return [0,caml_call1(A[59],a$1)];
            default:return error_uniop(_eN_,a)}}
        function fd(a){return sum(a)}
        function df(cp,ap,at){return sum(at)}
        function r(a){return [53,a]}
        return op_d_d(a,ff,fd,df,r)}
      function sum$0(opt,a)
       {if(opt)var sth=opt[1],axis=sth;else var axis=0;
        function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,a$0];
            case 1:var a$1=param[1];return [1,caml_call2(A[52],[0,axis],a$1)];
            default:return error_uniop(_eO_,a)}}
        function fd(a){return sum$0([0,axis],a)}
        function df(cp,ap,at){return sum$0([0,axis],at)}
        function r(a){return [54,a,axis]}
        return op_d_d(a,ff,fd,df,r)}
      function mean(a){var _P2_=[0,numel(a)];return _My_(sum(a),_P2_)}
      function dot(a,b)
       {function ff(a,match)
         {if(1 === a[0])
           if(1 === match[0])
            {var b=match[1],a$0=a[1];return [1,caml_call2(A[110],a$0,b)]}
          return error_binop(_eP_,a,match)}
        function fd(a,b){return _MA_(a,b)}
        function df_da(cp,ap,at){return _MA_(at,b)}
        function df_db(cp,bp,bt){return _MA_(a,bt)}
        function df_dab(cp,ap,at,bp,bt)
         {var _P1_=_MA_(at,bp);return _Mv_(_MA_(ap,bt),_P1_)}
        function r_d_d(a,b){return [55,a,b]}
        function r_d_c(a,b){return [56,a,b]}
        function r_c_d(a,b){return [57,a,b]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function _MA_(a,b){return dot(a,b)}
      function transpose(a)
       {function ff(param)
         {if(1 === param[0])
           {var a$0=param[1];return [1,caml_call2(A[113],0,a$0)]}
          return error_uniop(_eQ_,a)}
        function fd(a){return transpose(a)}
        function df(cp,ap,at){return transpose(at)}
        function r(a){return [58,a]}
        return op_d_d(a,ff,fd,df,r)}
      function l1norm(a)
       {function ff(param)
         {if(1 === param[0])
           {var a$0=param[1];return [0,caml_call1(A[60],a$0)]}
          return error_uniop(_eR_,a)}
        function fd(a){return l1norm(a)}
        function df(cp,ap,at){return _Mx_(at,signum(ap))}
        function r(a){return [59,a]}
        return op_d_d(a,ff,fd,df,r)}
      function l2norm(a)
       {function ff(param)
         {if(1 === param[0])
           {var a$0=param[1];return [0,caml_call1(A[61],a$0)]}
          return error_uniop(_eS_,a)}
        function fd(a){return l2norm(a)}
        function df(cp,ap,at){return _My_(_Mx_(ap,at),cp)}
        function r(a){return [60,a]}
        return op_d_d(a,ff,fd,df,r)}
      function l2norm_sqr(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][9],a$0)];
            case 1:var a$1=param[1];return [0,caml_call1(A[62],a$1)];
            default:return error_uniop(_eT_,a)}}
        function fd(a){return l2norm_sqr(a)}
        function df(cp,ap,at){return _Mx_(_eU_,_Mx_(ap,at))}
        function r(a){return [61,a]}
        return op_d_d(a,ff,fd,df,r)}
      function sigmoid(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][32],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[55],a$1)];
            default:return error_uniop(_eV_,a)}}
        function fd(a){return sigmoid(a)}
        function df(cp,ap,at)
         {var _P0_=_Mw_(_eW_,cp);return _Mx_(_Mx_(at,cp),_P0_)}
        function r(a){return [62,a]}
        return op_d_d(a,ff,fd,df,r)}
      function relu(a)
       {function ff(param)
         {switch(param[0])
           {case 0:var a$0=param[1];return [0,caml_call1(A[145][31],a$0)];
            case 1:var a$1=param[1];return [1,caml_call1(A[56],a$1)];
            default:return error_uniop(_eX_,a)}}
        function fd(a){return relu(a)}
        function df(cp,ap,at)
         {return _My_(_Mx_(at,_Mv_(_eZ_,signum(ap))),_eY_)}
        function r(a){return [63,a]}
        return op_d_d(a,ff,fd,df,r)}
      function inv(a)
       {function ff(param)
         {if(1 === param[0])
           {var a$0=param[1];return [1,caml_call1(A[111],a$0)]}
          return error_uniop(_e0_,a)}
        function fd(a){return inv(a)}
        function df(cp,ap,at){return _Mx_(_Mx_(neg(cp),at),cp)}
        function r(a){return [64,a]}
        return op_d_d(a,ff,fd,df,r)}
      function softplus(x){return log(_Mv_(_e1_,exp(x)))}
      function softsign(x){return _My_(x,_Mv_(_e2_,abs(x)))}
      function softmax(x)
       {var
         _PZ_=unpack_arr(x),
         c=[0,caml_call1(A[58],_PZ_)],
         y=exp(_Mw_(x,c)),
         a=sum(y);
        return _My_(y,a)}
      function cross_entropy(x,y){return neg(sum(_Mx_(x,log(y))))}
      function add_row(a,b,i)
       {function ff(a,match)
         {if(1 === a[0])
           if(1 === match[0])
            {var
              b=match[1],
              a$0=a[1],
              _PX_=caml_call2(A[106],a$0,i),
              _PY_=caml_call2(A[71],_PX_,b);
             caml_call3(A[108],_PY_,a$0,i);
             return [1,a$0]}
          return error_binop(_e3_,a,match)}
        function fd(a,b){return add_row(a,b,i)}
        function df_da(cp,ap,at){return at}
        function df_db(cp,bp,bt){return add_row(zero(a),bt,i)}
        function df_dab(cp,ap,at,bp,bt){return add_row(at,bt,i)}
        function r_d_d(a,b){return [65,a,b,i]}
        function r_d_c(a,b){return [66,a,b,i]}
        function r_c_d(a,b){return [67,a,b,i]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function get_row(a,i)
       {function ff(param)
         {if(1 === param[0])
           {var a$0=param[1],_PW_=caml_call2(A[106],a$0,i);
            return [1,caml_call1(A[16],_PW_)]}
          return error_uniop(_e4_,a)}
        function fd(a){return get_row(a,i)}
        function df(cp,ap,at){return get_row(at,i)}
        function r(a){return [68,a,i]}
        return op_d_d(a,ff,fd,df,r)}
      function to_rows(a)
       {function _PV_(i){return get_row(a,i)}return init(row_num(a),_PV_)}
      function of_rows(a)
       {var match=caml_check_bound(a,0)[1];
        switch(match[0])
         {case 0:return error_uniop(_e5_,caml_check_bound(a,0)[1]);
          case 1:
           var _PR_=map$0(unpack_arr,a);return [1,caml_call1(A[115],_PR_)];
          case 2:
           var
            ai=match[3],
            _PS_=map$0(function(x){return unpack_arr(primal(x))},a),
            ap=[1,caml_call1(A[115],_PS_)],
            _PT_=map$0(function(x){return unpack_arr(adjval(x))},a),
            at=[1,caml_call1(A[115],_PT_)];
           return [2,ap,at,ai];
          default:
           var
            ai$0=match[5],
            ap$0=map$0(function(x){return primal(x)},a),
            _PU_=map$0(function(x){return unpack_arr(x)},ap$0),
            cp=[1,caml_call1(A[115],_PU_)];
           return [3,cp,[0,zero(cp)],[69,a],[0,0],ai$0]}}
      function conv1d(padding,a,b,s)
       {function ff(a,match)
         {if(1 === a[0])
           if(1 === match[0])
            {var b=match[1],a$0=a[1];
             return [1,caml_call4(A[83],padding,a$0,b,s)]}
          return error_binop(_e6_,a,match)}
        function fd(a,b){return conv1d(padding,a,b,s)}
        function df_da(cp,ap,at){return failwith(_e7_)}
        function df_db(cp,bp,bt){return failwith(_e8_)}
        function df_dab(cp,ap,at,bp,bt){return failwith(_e9_)}
        function r_d_d(a,b){return [73,a,b,s]}
        function r_d_c(a,b){return [74,a,b,s]}
        function r_c_d(a,b){return [75,a,b,s]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function conv1d_backward_input(a,b,s,o)
       {var a$0=unpack_arr(a),b$0=unpack_arr(b),o$0=unpack_arr(o);
        return [1,caml_call4(A[92],a$0,b$0,s,o$0)]}
      function conv1d_backward_kernel(a,b,s,o)
       {var a$0=unpack_arr(a),b$0=unpack_arr(b),o$0=unpack_arr(o);
        return [1,caml_call4(A[93],a$0,b$0,s,o$0)]}
      function conv2d(padding,a,b,s)
       {function ff(a,match)
         {if(1 === a[0])
           if(1 === match[0])
            {var b=match[1],a$0=a[1];
             return [1,caml_call4(A[84],padding,a$0,b,s)]}
          return error_binop(_e__,a,match)}
        function fd(a,b){return conv2d(padding,a,b,s)}
        function df_da(cp,ap,at){return at}
        function df_db(cp,bp,bt){return bt}
        function df_dab(cp,ap,at,bp,bt){return _Mv_(at,bt)}
        function r_d_d(a,b){return [76,a,b,s]}
        function r_d_c(a,b){return [77,a,b,s]}
        function r_c_d(a,b){return [78,a,b,s]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function conv2d_backward_input(a,b,s,o)
       {var a$0=unpack_arr(a),b$0=unpack_arr(b),o$0=unpack_arr(o);
        return [1,caml_call4(A[94],a$0,b$0,s,o$0)]}
      function conv2d_backward_kernel(a,b,s,o)
       {var a$0=unpack_arr(a),b$0=unpack_arr(b),o$0=unpack_arr(o);
        return [1,caml_call4(A[95],a$0,b$0,s,o$0)]}
      function conv3d(padding,a,b,s)
       {function ff(a,match)
         {if(1 === a[0])
           if(1 === match[0])
            {var b=match[1],a$0=a[1];
             return [1,caml_call4(A[85],padding,a$0,b,s)]}
          return error_binop(_e$_,a,match)}
        function fd(a,b){return conv3d(padding,a,b,s)}
        function df_da(cp,ap,at){return at}
        function df_db(cp,bp,bt){return bt}
        function df_dab(cp,ap,at,bp,bt){return _Mv_(at,bt)}
        function r_d_d(a,b){return [79,a,b,s]}
        function r_d_c(a,b){return [80,a,b,s]}
        function r_c_d(a,b){return [81,a,b,s]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function conv3d_backward_input(a,b,s,o)
       {var a$0=unpack_arr(a),b$0=unpack_arr(b),o$0=unpack_arr(o);
        return [1,caml_call4(A[96],a$0,b$0,s,o$0)]}
      function conv3d_backward_kernel(a,b,s,o)
       {var a$0=unpack_arr(a),b$0=unpack_arr(b),o$0=unpack_arr(o);
        return [1,caml_call4(A[97],a$0,b$0,s,o$0)]}
      function reshape(a,s)
       {function ff(param)
         {if(1 === param[0])
           {var a$0=param[1];return [1,caml_call2(A[18],a$0,s)]}
          return error_uniop(_fa_,a)}
        function fd(a){return reshape(a,s)}
        function df(cp,ap,at){return reshape(at,s)}
        function r(a){return [82,a]}
        return op_d_d(a,ff,fd,df,r)}
      function flatten(a){return reshape(a,[0,1,numel(a)])}
      function max_pool1d(padding,a,b,s)
       {function ff(param)
         {if(1 === param[0])
           {var a$0=param[1];return [1,caml_call4(A[86],[0,padding],a$0,b,s)]}
          return error_uniop(_fb_,a)}
        function fd(a){return max_pool1d(padding,a,b,s)}
        function df(cp,ap,at){return failwith(_fc_)}
        function r(a){return [83,a,padding,b,s]}
        return op_d_d(a,ff,fd,df,r)}
      function max_pool1d_backward(p,a,b,s,o)
       {var a$0=unpack_arr(a),o$0=unpack_arr(o);
        return [1,caml_call5(A[98],p,a$0,b,s,o$0)]}
      function max_pool2d(padding,a,b,s)
       {function ff(param)
         {if(1 === param[0])
           {var a$0=param[1];return [1,caml_call4(A[87],[0,padding],a$0,b,s)]}
          return error_uniop(_fd_,a)}
        function fd(a){return max_pool2d(padding,a,b,s)}
        function df(cp,ap,at){return failwith(_fe_)}
        function r(a){return [84,a,padding,b,s]}
        return op_d_d(a,ff,fd,df,r)}
      function max_pool2d_backward(p,a,b,s,o)
       {var a$0=unpack_arr(a),o$0=unpack_arr(o);
        return [1,caml_call5(A[99],p,a$0,b,s,o$0)]}
      function max_pool3d(padding,a,b,s)
       {function ff(param)
         {if(1 === param[0])
           {var a$0=param[1];return [1,caml_call4(A[88],[0,padding],a$0,b,s)]}
          return error_uniop(_ff_,a)}
        function fd(a){return max_pool3d(padding,a,b,s)}
        function df(cp,ap,at){return failwith(_fg_)}
        function r(a){return [85,a,padding,b,s]}
        return op_d_d(a,ff,fd,df,r)}
      function max_pool3d_backward(p,a,b,s,o)
       {var a$0=unpack_arr(a),o$0=unpack_arr(o);
        return [1,caml_call5(A[100],p,a$0,b,s,o$0)]}
      function avg_pool1d(padding,a,b,s)
       {function ff(param)
         {if(1 === param[0])
           {var a$0=param[1];return [1,caml_call4(A[89],[0,padding],a$0,b,s)]}
          return error_uniop(_fh_,a)}
        function fd(a){return avg_pool1d(padding,a,b,s)}
        function df(cp,ap,at){return failwith(_fi_)}
        function r(a){return [86,a,padding,b,s]}
        return op_d_d(a,ff,fd,df,r)}
      function avg_pool1d_backward(p,a,b,s,o)
       {var a$0=unpack_arr(a),o$0=unpack_arr(o);
        return [1,caml_call5(A[101],p,a$0,b,s,o$0)]}
      function avg_pool2d(padding,a,b,s)
       {function ff(param)
         {if(1 === param[0])
           {var a$0=param[1];return [1,caml_call4(A[90],[0,padding],a$0,b,s)]}
          return error_uniop(_fj_,a)}
        function fd(a){return avg_pool2d(padding,a,b,s)}
        function df(cp,ap,at){return failwith(_fk_)}
        function r(a){return [87,a,padding,b,s]}
        return op_d_d(a,ff,fd,df,r)}
      function avg_pool2d_backward(p,a,b,s,o)
       {var a$0=unpack_arr(a),o$0=unpack_arr(o);
        return [1,caml_call5(A[102],p,a$0,b,s,o$0)]}
      function avg_pool3d(padding,a,b,s)
       {function ff(param)
         {if(1 === param[0])
           {var a$0=param[1];return [1,caml_call4(A[91],[0,padding],a$0,b,s)]}
          return error_uniop(_fl_,a)}
        function fd(a){return avg_pool3d(padding,a,b,s)}
        function df(cp,ap,at){return failwith(_fm_)}
        function r(a){return [88,a,padding,b,s]}
        return op_d_d(a,ff,fd,df,r)}
      function avg_pool3d_backward(p,a,b,s,o)
       {var a$0=unpack_arr(a),o$0=unpack_arr(o);
        return [1,caml_call5(A[103],p,a$0,b,s,o$0)]}
      function dropout(opt,a)
       {if(opt)var sth=opt[1],rate=sth;else var rate=0.5;
        var match=primal$0(a);
        if(1 === match[0])
         var
          a$0=match[1],
          _PQ_=caml_call1(A[10],a$0),
          b=[1,caml_call2(A[8],[0,1 - rate],_PQ_)];
        else
         var b=error_uniop(_fn_,a);
        return _Mx_(a,b)}
      function concat(axis,a,b)
       {function ff(a,match)
         {if(1 === a[0])
           if(1 === match[0])
            {var b=match[1],a$0=a[1];
             return [1,caml_call2(A[22],[0,axis],[0,a$0,b])]}
          return error_binop(_fo_,a,match)}
        function fd(a,b){return concat(axis,a,b)}
        function df_da(cp,ap,at){return concat(axis,at,zero(b))}
        function df_db(cp,bp,bt){return concat(axis,zero(a),bt)}
        function df_dab(cp,ap,at,bp,bt){return concat(axis,at,bt)}
        function r_d_d(a,b){return [70,a,b,axis]}
        function r_d_c(a,b){return [71,a,b,axis]}
        function r_c_d(a,b){return [72,a,b,axis]}
        return op_d_d_d(a,b,ff,fd,df_da,df_db,df_dab,r_d_d,r_d_c,r_c_d)}
      function split(axis,parts,a)
       {if(1 === a[0])
         {var a$0=a[1],_PP_=caml_call3(A[23],[0,axis],parts,a$0);
          return map$0(function(x){return [1,x]},_PP_)}
        return error_uniop(_fp_,a)}
      var
       Maths=
        [0,
         noop,
         op_d_d,
         op_d_d_d,
         _Mv_,
         add$0,
         _Mw_,
         sub,
         _Mx_,
         mul,
         _My_,
         div,
         _Mz_,
         pow,
         atan2,
         min2,
         max2,
         neg,
         abs,
         signum,
         floor,
         ceil,
         round,
         sqr,
         sqrt,
         log,
         log2,
         log10,
         exp,
         sin,
         cos,
         tan,
         sinh,
         cosh,
         tanh,
         asin,
         acos,
         atan,
         asinh,
         acosh,
         atanh,
         get_item,
         set_item,
         add_item,
         get_slice,
         set_slice,
         sum,
         sum$0,
         mean,
         _MA_,
         dot,
         transpose,
         l1norm,
         l2norm,
         l2norm_sqr,
         sigmoid,
         relu,
         inv,
         softplus,
         softsign,
         softmax,
         cross_entropy,
         add_row,
         get_row,
         to_rows,
         of_rows,
         conv1d,
         conv1d_backward_input,
         conv1d_backward_kernel,
         conv2d,
         conv2d_backward_input,
         conv2d_backward_kernel,
         conv3d,
         conv3d_backward_input,
         conv3d_backward_kernel,
         reshape,
         flatten,
         max_pool1d,
         max_pool1d_backward,
         max_pool2d,
         max_pool2d_backward,
         max_pool3d,
         max_pool3d_backward,
         avg_pool1d,
         avg_pool1d_backward,
         avg_pool2d,
         avg_pool2d_backward,
         avg_pool3d,
         avg_pool3d_backward,
         dropout,
         concat,
         split];
      function reverse_reset(x)
       {var xs$89=[0,x,0],xs=xs$89;
        for(;;)
         {if(xs)
           {var t=xs[2],x$0=xs[1];
            if(3 === x$0[0])
             {var af=x$0[4],ao=x$0[3],aa=x$0[2];
              aa[1] = reset_zero(aa[1]);
              af[1] = af[1] + 1 | 0;
              if(1 === af[1])
               if(typeof ao === "number")
                {var xs=t;continue}
               else
                {var _PO_=ao[0];
                 if(45 <= _PO_)
                  switch(_PO_)
                   {case 45:var b$12=ao[4],xs$45=[0,b$12,t],xs=xs$45;continue;
                    case 46:
                     var
                      b$13=ao[4],
                      a$38=ao[1],
                      xs$46=[0,a$38,[0,b$13,t]],
                      xs=xs$46;
                     continue;
                    case 47:var a$39=ao[1],xs$47=[0,a$39,t],xs=xs$47;continue;
                    case 48:var b$14=ao[4],xs$48=[0,b$14,t],xs=xs$48;continue;
                    case 49:var a$40=ao[1],xs$49=[0,a$40,t],xs=xs$49;continue;
                    case 50:
                     var
                      b$15=ao[2],
                      a$41=ao[1],
                      xs$50=[0,a$41,[0,b$15,t]],
                      xs=xs$50;
                     continue;
                    case 51:var a$42=ao[1],xs$51=[0,a$42,t],xs=xs$51;continue;
                    case 52:var b$16=ao[2],xs$52=[0,b$16,t],xs=xs$52;continue;
                    case 53:var a$43=ao[1],xs$53=[0,a$43,t],xs=xs$53;continue;
                    case 54:var a$44=ao[1],xs$54=[0,a$44,t],xs=xs$54;continue;
                    case 55:
                     var
                      b$17=ao[2],
                      a$45=ao[1],
                      xs$55=[0,a$45,[0,b$17,t]],
                      xs=xs$55;
                     continue;
                    case 56:var a$46=ao[1],xs$56=[0,a$46,t],xs=xs$56;continue;
                    case 57:var b$18=ao[2],xs$57=[0,b$18,t],xs=xs$57;continue;
                    case 58:var a$47=ao[1],xs$58=[0,a$47,t],xs=xs$58;continue;
                    case 59:var a$48=ao[1],xs$59=[0,a$48,t],xs=xs$59;continue;
                    case 60:var a$49=ao[1],xs$60=[0,a$49,t],xs=xs$60;continue;
                    case 61:var a$50=ao[1],xs$61=[0,a$50,t],xs=xs$61;continue;
                    case 62:var a$51=ao[1],xs$62=[0,a$51,t],xs=xs$62;continue;
                    case 63:var a$52=ao[1],xs$63=[0,a$52,t],xs=xs$63;continue;
                    case 64:var a$53=ao[1],xs$64=[0,a$53,t],xs=xs$64;continue;
                    case 65:
                     var
                      b$19=ao[2],
                      a$54=ao[1],
                      xs$65=[0,a$54,[0,b$19,t]],
                      xs=xs$65;
                     continue;
                    case 66:var a$55=ao[1],xs$66=[0,a$55,t],xs=xs$66;continue;
                    case 67:var b$20=ao[2],xs$67=[0,b$20,t],xs=xs$67;continue;
                    case 68:var a$56=ao[1],xs$68=[0,a$56,t],xs=xs$68;continue;
                    case 69:
                     var a$57=ao[1],xs$69=append(to_list(a$57),t),xs=xs$69;
                     continue;
                    case 70:
                     var
                      b$21=ao[2],
                      a$58=ao[1],
                      xs$70=[0,a$58,[0,b$21,t]],
                      xs=xs$70;
                     continue;
                    case 71:var a$59=ao[1],xs$71=[0,a$59,t],xs=xs$71;continue;
                    case 72:var b$22=ao[2],xs$72=[0,b$22,t],xs=xs$72;continue;
                    case 73:
                     var
                      b$23=ao[2],
                      a$60=ao[1],
                      xs$73=[0,a$60,[0,b$23,t]],
                      xs=xs$73;
                     continue;
                    case 74:var a$61=ao[1],xs$74=[0,a$61,t],xs=xs$74;continue;
                    case 75:var b$24=ao[2],xs$75=[0,b$24,t],xs=xs$75;continue;
                    case 76:
                     var
                      b$25=ao[2],
                      a$62=ao[1],
                      xs$76=[0,a$62,[0,b$25,t]],
                      xs=xs$76;
                     continue;
                    case 77:var a$63=ao[1],xs$77=[0,a$63,t],xs=xs$77;continue;
                    case 78:var b$26=ao[2],xs$78=[0,b$26,t],xs=xs$78;continue;
                    case 79:
                     var
                      b$27=ao[2],
                      a$64=ao[1],
                      xs$79=[0,a$64,[0,b$27,t]],
                      xs=xs$79;
                     continue;
                    case 80:var a$65=ao[1],xs$80=[0,a$65,t],xs=xs$80;continue;
                    case 81:var b$28=ao[2],xs$81=[0,b$28,t],xs=xs$81;continue;
                    case 82:var a$66=ao[1],xs$82=[0,a$66,t],xs=xs$82;continue;
                    case 83:var a$67=ao[1],xs$83=[0,a$67,t],xs=xs$83;continue;
                    case 84:var a$68=ao[1],xs$84=[0,a$68,t],xs=xs$84;continue;
                    case 85:var a$69=ao[1],xs$85=[0,a$69,t],xs=xs$85;continue;
                    case 86:var a$70=ao[1],xs$86=[0,a$70,t],xs=xs$86;continue;
                    case 87:var a$71=ao[1],xs$87=[0,a$71,t],xs=xs$87;continue;
                    default:var a$72=ao[1],xs$88=[0,a$72,t],xs=xs$88;continue}
                 switch(_PO_)
                  {case 0:
                    var b=ao[2],a=ao[1],xs$0=[0,a,[0,b,t]],xs=xs$0;continue;
                   case 1:var a$0=ao[1],xs$1=[0,a$0,t],xs=xs$1;continue;
                   case 2:var b$0=ao[2],xs$2=[0,b$0,t],xs=xs$2;continue;
                   case 3:
                    var b$1=ao[2],a$1=ao[1],xs$3=[0,a$1,[0,b$1,t]],xs=xs$3;
                    continue;
                   case 4:var a$2=ao[1],xs$4=[0,a$2,t],xs=xs$4;continue;
                   case 5:var b$2=ao[2],xs$5=[0,b$2,t],xs=xs$5;continue;
                   case 6:
                    var b$3=ao[2],a$3=ao[1],xs$6=[0,a$3,[0,b$3,t]],xs=xs$6;
                    continue;
                   case 7:var a$4=ao[1],xs$7=[0,a$4,t],xs=xs$7;continue;
                   case 8:var b$4=ao[2],xs$8=[0,b$4,t],xs=xs$8;continue;
                   case 9:
                    var b$5=ao[2],a$5=ao[1],xs$9=[0,a$5,[0,b$5,t]],xs=xs$9;
                    continue;
                   case 10:var a$6=ao[1],xs$10=[0,a$6,t],xs=xs$10;continue;
                   case 11:var b$6=ao[2],xs$11=[0,b$6,t],xs=xs$11;continue;
                   case 12:
                    var b$7=ao[2],a$7=ao[1],xs$12=[0,a$7,[0,b$7,t]],xs=xs$12;
                    continue;
                   case 13:var a$8=ao[1],xs$13=[0,a$8,t],xs=xs$13;continue;
                   case 14:var b$8=ao[2],xs$14=[0,b$8,t],xs=xs$14;continue;
                   case 15:
                    var b$9=ao[2],a$9=ao[1],xs$15=[0,a$9,[0,b$9,t]],xs=xs$15;
                    continue;
                   case 16:var a$10=ao[1],xs$16=[0,a$10,t],xs=xs$16;continue;
                   case 17:var b$10=ao[2],xs$17=[0,b$10,t],xs=xs$17;continue;
                   case 18:var a$11=ao[1],xs$18=[0,a$11,t],xs=xs$18;continue;
                   case 19:var a$12=ao[1],xs$19=[0,a$12,t],xs=xs$19;continue;
                   case 20:var a$13=ao[1],xs$20=[0,a$13,t],xs=xs$20;continue;
                   case 21:var a$14=ao[1],xs$21=[0,a$14,t],xs=xs$21;continue;
                   case 22:var a$15=ao[1],xs$22=[0,a$15,t],xs=xs$22;continue;
                   case 23:var a$16=ao[1],xs$23=[0,a$16,t],xs=xs$23;continue;
                   case 24:var a$17=ao[1],xs$24=[0,a$17,t],xs=xs$24;continue;
                   case 25:var a$18=ao[1],xs$25=[0,a$18,t],xs=xs$25;continue;
                   case 26:var a$19=ao[1],xs$26=[0,a$19,t],xs=xs$26;continue;
                   case 27:var a$20=ao[1],xs$27=[0,a$20,t],xs=xs$27;continue;
                   case 28:var a$21=ao[1],xs$28=[0,a$21,t],xs=xs$28;continue;
                   case 29:var a$22=ao[1],xs$29=[0,a$22,t],xs=xs$29;continue;
                   case 30:var a$23=ao[1],xs$30=[0,a$23,t],xs=xs$30;continue;
                   case 31:var a$24=ao[1],xs$31=[0,a$24,t],xs=xs$31;continue;
                   case 32:var a$25=ao[1],xs$32=[0,a$25,t],xs=xs$32;continue;
                   case 33:var a$26=ao[1],xs$33=[0,a$26,t],xs=xs$33;continue;
                   case 34:var a$27=ao[1],xs$34=[0,a$27,t],xs=xs$34;continue;
                   case 35:var a$28=ao[1],xs$35=[0,a$28,t],xs=xs$35;continue;
                   case 36:var a$29=ao[1],xs$36=[0,a$29,t],xs=xs$36;continue;
                   case 37:var a$30=ao[1],xs$37=[0,a$30,t],xs=xs$37;continue;
                   case 38:var a$31=ao[1],xs$38=[0,a$31,t],xs=xs$38;continue;
                   case 39:var a$32=ao[1],xs$39=[0,a$32,t],xs=xs$39;continue;
                   case 40:var a$33=ao[1],xs$40=[0,a$33,t],xs=xs$40;continue;
                   case 41:var a$34=ao[1],xs$41=[0,a$34,t],xs=xs$41;continue;
                   case 42:var a$35=ao[1],xs$42=[0,a$35,t],xs=xs$42;continue;
                   case 43:
                    var
                     b$11=ao[4],
                     a$36=ao[1],
                     xs$43=[0,a$36,[0,b$11,t]],
                     xs=xs$43;
                    continue;
                   default:var a$37=ao[1],xs$44=[0,a$37,t],xs=xs$44;continue}}
              var xs=t;
              continue}
            var xs=t;
            continue}
          return 0}}
      function reverse_push(v,x)
       {var xs$89=[0,[0,v,x],0],xs=xs$89;
        for(;;)
         {if(xs)
           {var t=xs[2],match$0=xs[1],x$0=match$0[2],v$2=match$0[1];
            if(3 === x$0[0])
             {var af=x$0[4],ao=x$0[3],aa=x$0[2],ap=x$0[1],_M6_=aa[1];
              switch(_M6_[0])
               {case 0:
                 if(1 === v$2[0])
                  var v$0=v$2[1],v$3=[0,caml_call1(A[59],v$0)],switch$0=1;
                 else
                  var switch$0=0;
                 break;
                case 1:
                 if(1 === v$2[0])
                  {var
                    v$1=v$2[1],
                    a=_M6_[1],
                    _M5_=caml_call1(A[10],v$1),
                    match=caml_equal(caml_call1(A[10],a),_M5_);
                   if(0 === match)
                    var v$3=[1,caml_call2(A[53],0,v$1)],switch$0=1;
                   else
                    var v$3=[1,v$1],switch$0=1}
                 else
                  var switch$0=0;
                 break;
                default:var switch$0=0}
              if(!switch$0)var v$3=v$2;
              aa[1] = caml_call2(Maths[4],aa[1],v$3);
              af[1] = af[1] - 1 | 0;
              if(0 === af[1])
               if(typeof ao === "number")
                {var xs=t;continue}
               else
                {var _PN_=ao[0];
                 if(45 <= _PN_)
                  switch(_PN_)
                   {case 45:
                     var
                      b$16=ao[4],
                      j$2=ao[3],
                      i$2=ao[2],
                      xs$45=[0,[0,caml_call3(Maths[41],aa[1],i$2,j$2),b$16],t],
                      xs=xs$45;
                     continue;
                    case 46:
                     var
                      b$17=ao[4],
                      j$3=ao[3],
                      i$3=ao[2],
                      a$43=ao[1],
                      _OP_=[0,[0,caml_call3(Maths[41],aa[1],i$3,j$3),b$17],t],
                      xs$46=[0,[0,aa[1],a$43],_OP_],
                      xs=xs$46;
                     continue;
                    case 47:
                     var a$44=ao[1],xs$47=[0,[0,aa[1],a$44],t],xs=xs$47;continue;
                    case 48:
                     var
                      b$18=ao[4],
                      j$4=ao[3],
                      i$4=ao[2],
                      xs$48=[0,[0,caml_call3(Maths[41],aa[1],i$4,j$4),b$18],t],
                      xs=xs$48;
                     continue;
                    case 49:
                     var
                      i$5=ao[2],
                      a$45=ao[1],
                      _OQ_=aa[1],
                      _OR_=zero(a$45),
                      xs$49=[0,[0,caml_call3(Maths[45],i$5,_OR_,_OQ_),a$45],t],
                      xs=xs$49;
                     continue;
                    case 50:
                     var
                      i$6=ao[3],
                      b$19=ao[2],
                      a$46=ao[1],
                      _OS_=[0,[0,caml_call2(Maths[44],i$6,aa[1]),b$19],t],
                      _OT_=zero(b$19),
                      xs$50=[0,[0,caml_call3(Maths[45],i$6,aa[1],_OT_),a$46],_OS_],
                      xs=xs$50;
                     continue;
                    case 51:
                     var
                      i$7=ao[3],
                      b$20=ao[2],
                      a$47=ao[1],
                      _OU_=zero(b$20),
                      xs$51=[0,[0,caml_call3(Maths[45],i$7,aa[1],_OU_),a$47],t],
                      xs=xs$51;
                     continue;
                    case 52:
                     var
                      i$8=ao[3],
                      b$21=ao[2],
                      xs$52=[0,[0,caml_call2(Maths[44],i$8,aa[1]),b$21],t],
                      xs=xs$52;
                     continue;
                    case 53:
                     var a$48=ao[1],xs$53=[0,[0,aa[1],a$48],t],xs=xs$53;continue;
                    case 54:
                     var
                      i$9=ao[2],
                      a$49=ao[1],
                      _OV_=caml_check_bound(shape(a$49),i$9)[i$9 + 1],
                      xs$54=[0,[0,repeat([0,i$9],aa[1],_OV_),a$49],t],
                      xs=xs$54;
                     continue;
                    case 55:
                     var
                      b$22=ao[2],
                      a$50=ao[1],
                      _OW_=aa[1],
                      _OX_=primal(a$50),
                      _OY_=caml_call1(Maths[51],_OX_),
                      _OZ_=[0,[0,caml_call2(Maths[50],_OY_,_OW_),b$22],t],
                      _O0_=primal(b$22),
                      _O1_=caml_call1(Maths[51],_O0_),
                      xs$55=[0,[0,caml_call2(Maths[50],aa[1],_O1_),a$50],_OZ_],
                      xs=xs$55;
                     continue;
                    case 56:
                     var
                      b$23=ao[2],
                      a$51=ao[1],
                      _O2_=caml_call1(Maths[51],b$23),
                      xs$56=[0,[0,caml_call2(Maths[50],aa[1],_O2_),a$51],t],
                      xs=xs$56;
                     continue;
                    case 57:
                     var
                      b$24=ao[2],
                      a$52=ao[1],
                      _O3_=aa[1],
                      _O4_=caml_call1(Maths[51],a$52),
                      xs$57=[0,[0,caml_call2(Maths[50],_O4_,_O3_),b$24],t],
                      xs=xs$57;
                     continue;
                    case 58:
                     var
                      a$53=ao[1],
                      xs$58=[0,[0,caml_call1(Maths[51],aa[1]),a$53],t],
                      xs=xs$58;
                     continue;
                    case 59:
                     var
                      a$54=ao[1],
                      _O5_=primal(a$54),
                      _O6_=caml_call1(Maths[19],_O5_),
                      xs$59=[0,[0,caml_call2(Maths[8],aa[1],_O6_),a$54],t],
                      xs=xs$59;
                     continue;
                    case 60:
                     var
                      a$55=ao[1],
                      _O7_=primal(a$55),
                      _O8_=caml_call2(Maths[10],aa[1],ap),
                      xs$60=[0,[0,caml_call2(Maths[8],_O8_,_O7_),a$55],t],
                      xs=xs$60;
                     continue;
                    case 61:
                     var
                      a$56=ao[1],
                      _O9_=primal(a$56),
                      _O__=caml_call2(Maths[8],aa[1],_fC_),
                      xs$61=[0,[0,caml_call2(Maths[8],_O__,_O9_),a$56],t],
                      xs=xs$61;
                     continue;
                    case 62:
                     var
                      a$57=ao[1],
                      _O$_=caml_call2(Maths[6],_fD_,ap),
                      _Pa_=caml_call2(Maths[8],aa[1],ap),
                      xs$62=[0,[0,caml_call2(Maths[8],_Pa_,_O$_),a$57],t],
                      xs=xs$62;
                     continue;
                    case 63:
                     var
                      a$58=ao[1],
                      _Pb_=primal(a$58),
                      _Pc_=caml_call1(Maths[19],_Pb_),
                      _Pd_=caml_call2(Maths[4],_Pc_,_fF_),
                      _Pe_=caml_call2(Maths[10],_Pd_,_fE_),
                      xs$63=[0,[0,caml_call2(Maths[8],aa[1],_Pe_),a$58],t],
                      xs=xs$63;
                     continue;
                    case 64:
                     var
                      a$59=ao[1],
                      dpt=caml_call1(Maths[51],ap),
                      _Pf_=aa[1],
                      _Pg_=caml_call1(Maths[17],dpt),
                      _Ph_=caml_call2(Maths[8],_Pg_,_Pf_),
                      xs$64=[0,[0,caml_call2(Maths[8],_Ph_,dpt),a$59],t],
                      xs=xs$64;
                     continue;
                    case 65:
                     var
                      i$10=ao[3],
                      b$25=ao[2],
                      a$60=ao[1],
                      _Pi_=[0,[0,caml_call2(Maths[63],aa[1],i$10),b$25],t],
                      xs$65=[0,[0,aa[1],a$60],_Pi_],
                      xs=xs$65;
                     continue;
                    case 66:
                     var a$61=ao[1],xs$66=[0,[0,aa[1],a$61],t],xs=xs$66;continue;
                    case 67:
                     var
                      i$11=ao[3],
                      b$26=ao[2],
                      xs$67=[0,[0,caml_call2(Maths[63],aa[1],i$11),b$26],t],
                      xs=xs$67;
                     continue;
                    case 68:
                     var
                      i$12=ao[2],
                      a$62=ao[1],
                      _Pj_=aa[1],
                      _Pk_=adjval(a$62),
                      _Pl_=caml_call3(Maths[62],_Pk_,_Pj_,i$12);
                     adjref(a$62)[1] = _Pl_;
                     var xs$68=[0,[0,zero(a$62),a$62],t],xs=xs$68;
                     continue;
                    case 69:
                     var
                      a$63=ao[1],
                      _Pm_=to_list(a$63),
                      xs$69=
                       append
                        (mapi
                          (function(aa)
                             {return function(i,v)
                               {return [0,caml_call2(Maths[63],aa[1],i),v]}}
                            (aa),
                           _Pm_),
                         t),
                      xs=xs$69;
                     continue;
                    case 70:
                     var
                      i$13=ao[3],
                      b$27=ao[2],
                      a$64=ao[1],
                      _Pn_=aa[1],
                      _Po_=caml_check_bound(shape(b$27),i$13)[i$13 + 1],
                      _Pp_=[0,caml_check_bound(shape(a$64),i$13)[i$13 + 1],_Po_],
                      s=caml_call3(Maths[91],i$13,_Pp_,_Pn_),
                      _Pq_=[0,[0,caml_check_bound(s,1)[2],b$27],t],
                      xs$70=[0,[0,caml_check_bound(s,0)[1],a$64],_Pq_],
                      xs=xs$70;
                     continue;
                    case 71:
                     var
                      i$14=ao[3],
                      b$28=ao[2],
                      a$65=ao[1],
                      _Pr_=aa[1],
                      _Ps_=caml_check_bound(shape(b$28),i$14)[i$14 + 1],
                      _Pt_=[0,caml_check_bound(shape(a$65),i$14)[i$14 + 1],_Ps_],
                      s$0=caml_call3(Maths[91],i$14,_Pt_,_Pr_),
                      xs$71=[0,[0,caml_check_bound(s$0,0)[1],a$65],t],
                      xs=xs$71;
                     continue;
                    case 72:
                     var
                      i$15=ao[3],
                      b$29=ao[2],
                      a$66=ao[1],
                      _Pu_=aa[1],
                      _Pv_=caml_check_bound(shape(b$29),i$15)[i$15 + 1],
                      _Pw_=[0,caml_check_bound(shape(a$66),i$15)[i$15 + 1],_Pv_],
                      s$1=caml_call3(Maths[91],i$15,_Pw_,_Pu_),
                      xs$72=[0,[0,caml_check_bound(s$1,1)[2],b$29],t],
                      xs=xs$72;
                     continue;
                    case 73:
                     var
                      s$2=ao[3],
                      b$30=ao[2],
                      a$67=ao[1],
                      _Px_=
                       [0,[0,caml_call4(Maths[68],a$67,b$30,s$2,aa[1]),b$30],t],
                      xs$73=
                       [0,[0,caml_call4(Maths[67],a$67,b$30,s$2,aa[1]),a$67],_Px_],
                      xs=xs$73;
                     continue;
                    case 74:
                     var
                      s$3=ao[3],
                      b$31=ao[2],
                      a$68=ao[1],
                      xs$74=
                       [0,[0,caml_call4(Maths[67],a$68,b$31,s$3,aa[1]),a$68],t],
                      xs=xs$74;
                     continue;
                    case 75:
                     var
                      s$4=ao[3],
                      b$32=ao[2],
                      a$69=ao[1],
                      xs$75=
                       [0,[0,caml_call4(Maths[68],a$69,b$32,s$4,aa[1]),b$32],t],
                      xs=xs$75;
                     continue;
                    case 76:
                     var
                      s$5=ao[3],
                      b$33=ao[2],
                      a$70=ao[1],
                      _Py_=
                       [0,[0,caml_call4(Maths[71],a$70,b$33,s$5,aa[1]),b$33],t],
                      xs$76=
                       [0,[0,caml_call4(Maths[70],a$70,b$33,s$5,aa[1]),a$70],_Py_],
                      xs=xs$76;
                     continue;
                    case 77:
                     var
                      s$6=ao[3],
                      b$34=ao[2],
                      a$71=ao[1],
                      xs$77=
                       [0,[0,caml_call4(Maths[70],a$71,b$34,s$6,aa[1]),a$71],t],
                      xs=xs$77;
                     continue;
                    case 78:
                     var
                      s$7=ao[3],
                      b$35=ao[2],
                      a$72=ao[1],
                      xs$78=
                       [0,[0,caml_call4(Maths[71],a$72,b$35,s$7,aa[1]),b$35],t],
                      xs=xs$78;
                     continue;
                    case 79:
                     var
                      s$8=ao[3],
                      b$36=ao[2],
                      a$73=ao[1],
                      _Pz_=
                       [0,[0,caml_call4(Maths[74],a$73,b$36,s$8,aa[1]),b$36],t],
                      xs$79=
                       [0,[0,caml_call4(Maths[73],a$73,b$36,s$8,aa[1]),a$73],_Pz_],
                      xs=xs$79;
                     continue;
                    case 80:
                     var
                      s$9=ao[3],
                      b$37=ao[2],
                      a$74=ao[1],
                      xs$80=
                       [0,[0,caml_call4(Maths[73],a$74,b$37,s$9,aa[1]),a$74],t],
                      xs=xs$80;
                     continue;
                    case 81:
                     var
                      s$10=ao[3],
                      b$38=ao[2],
                      a$75=ao[1],
                      xs$81=
                       [0,[0,caml_call4(Maths[74],a$75,b$38,s$10,aa[1]),b$38],t],
                      xs=xs$81;
                     continue;
                    case 82:
                     var
                      a$76=ao[1],
                      _PA_=shape(primal(a$76)),
                      xs$82=[0,[0,caml_call2(Maths[75],aa[1],_PA_),a$76],t],
                      xs=xs$82;
                     continue;
                    case 83:
                     var
                      s$11=ao[4],
                      d$0=ao[3],
                      p=ao[2],
                      a$77=ao[1],
                      _PB_=aa[1],
                      _PC_=primal(a$77),
                      xs$83=
                       [0,[0,caml_call5(Maths[78],p,_PC_,d$0,s$11,_PB_),a$77],t],
                      xs=xs$83;
                     continue;
                    case 84:
                     var
                      s$12=ao[4],
                      d$1=ao[3],
                      p$0=ao[2],
                      a$78=ao[1],
                      _PD_=aa[1],
                      _PE_=primal(a$78),
                      xs$84=
                       [0,[0,caml_call5(Maths[80],p$0,_PE_,d$1,s$12,_PD_),a$78],t],
                      xs=xs$84;
                     continue;
                    case 85:
                     var
                      s$13=ao[4],
                      d$2=ao[3],
                      p$1=ao[2],
                      a$79=ao[1],
                      _PF_=aa[1],
                      _PG_=primal(a$79),
                      xs$85=
                       [0,[0,caml_call5(Maths[82],p$1,_PG_,d$2,s$13,_PF_),a$79],t],
                      xs=xs$85;
                     continue;
                    case 86:
                     var
                      s$14=ao[4],
                      d$3=ao[3],
                      p$2=ao[2],
                      a$80=ao[1],
                      _PH_=aa[1],
                      _PI_=primal(a$80),
                      xs$86=
                       [0,[0,caml_call5(Maths[84],p$2,_PI_,d$3,s$14,_PH_),a$80],t],
                      xs=xs$86;
                     continue;
                    case 87:
                     var
                      s$15=ao[4],
                      d$4=ao[3],
                      p$3=ao[2],
                      a$81=ao[1],
                      _PJ_=aa[1],
                      _PK_=primal(a$81),
                      xs$87=
                       [0,[0,caml_call5(Maths[86],p$3,_PK_,d$4,s$15,_PJ_),a$81],t],
                      xs=xs$87;
                     continue;
                    default:
                     var
                      s$16=ao[4],
                      d$5=ao[3],
                      p$4=ao[2],
                      a$82=ao[1],
                      _PL_=aa[1],
                      _PM_=primal(a$82),
                      xs$88=
                       [0,[0,caml_call5(Maths[88],p$4,_PM_,d$5,s$16,_PL_),a$82],t],
                      xs=xs$88;
                     continue}
                 switch(_PN_)
                  {case 0:
                    var
                     b=ao[2],
                     a$0=ao[1],
                     xs$0=[0,[0,aa[1],a$0],[0,[0,aa[1],b],t]],
                     xs=xs$0;
                    continue;
                   case 1:
                    var a$1=ao[1],xs$1=[0,[0,aa[1],a$1],t],xs=xs$1;continue;
                   case 2:
                    var b$0=ao[2],xs$2=[0,[0,aa[1],b$0],t],xs=xs$2;continue;
                   case 3:
                    var
                     b$1=ao[2],
                     a$2=ao[1],
                     _M7_=[0,[0,caml_call1(Maths[17],aa[1]),b$1],t],
                     xs$3=[0,[0,aa[1],a$2],_M7_],
                     xs=xs$3;
                    continue;
                   case 4:
                    var a$3=ao[1],xs$4=[0,[0,aa[1],a$3],t],xs=xs$4;continue;
                   case 5:
                    var
                     b$2=ao[2],
                     xs$5=[0,[0,caml_call1(Maths[17],aa[1]),b$2],t],
                     xs=xs$5;
                    continue;
                   case 6:
                    var
                     b$3=ao[2],
                     a$4=ao[1],
                     _M8_=primal(a$4),
                     _M9_=[0,[0,caml_call2(Maths[8],aa[1],_M8_),b$3],t],
                     _M__=primal(b$3),
                     xs$6=[0,[0,caml_call2(Maths[8],aa[1],_M__),a$4],_M9_],
                     xs=xs$6;
                    continue;
                   case 7:
                    var
                     b$4=ao[2],
                     a$5=ao[1],
                     xs$7=[0,[0,caml_call2(Maths[8],aa[1],b$4),a$5],t],
                     xs=xs$7;
                    continue;
                   case 8:
                    var
                     b$5=ao[2],
                     a$6=ao[1],
                     xs$8=[0,[0,caml_call2(Maths[8],aa[1],a$6),b$5],t],
                     xs=xs$8;
                    continue;
                   case 9:
                    var
                     b$6=ao[2],
                     a$7=ao[1],
                     _M$_=primal(b$6),
                     _Na_=primal(b$6),
                     _Nb_=caml_call2(Maths[8],_Na_,_M$_),
                     _Nc_=primal(a$7),
                     _Nd_=caml_call1(Maths[17],_Nc_),
                     _Ne_=caml_call2(Maths[10],_Nd_,_Nb_),
                     _Nf_=[0,[0,caml_call2(Maths[8],aa[1],_Ne_),b$6],t],
                     _Ng_=primal(b$6),
                     xs$9=[0,[0,caml_call2(Maths[10],aa[1],_Ng_),a$7],_Nf_],
                     xs=xs$9;
                    continue;
                   case 10:
                    var
                     b$7=ao[2],
                     a$8=ao[1],
                     xs$10=[0,[0,caml_call2(Maths[10],aa[1],b$7),a$8],t],
                     xs=xs$10;
                    continue;
                   case 11:
                    var
                     b$8=ao[2],
                     a$9=ao[1],
                     _Nh_=primal(b$8),
                     _Ni_=primal(b$8),
                     _Nj_=caml_call2(Maths[8],_Ni_,_Nh_),
                     _Nk_=caml_call1(Maths[17],a$9),
                     _Nl_=caml_call2(Maths[10],_Nk_,_Nj_),
                     xs$11=[0,[0,caml_call2(Maths[8],aa[1],_Nl_),b$8],t],
                     xs=xs$11;
                    continue;
                   case 12:
                    var
                     b$9=ao[2],
                     a$10=ao[1],
                     _Nm_=primal(a$10),
                     _Nn_=caml_call1(Maths[25],_Nm_),
                     _No_=primal(b$9),
                     _Np_=primal(a$10),
                     _Nq_=caml_call2(Maths[12],_Np_,_No_),
                     _Nr_=caml_call2(Maths[8],aa[1],_Nq_),
                     _Ns_=[0,[0,caml_call2(Maths[8],_Nr_,_Nn_),b$9],t],
                     _Nt_=primal(b$9),
                     _Nu_=primal(b$9),
                     _Nv_=caml_call2(Maths[6],_Nu_,_fq_),
                     _Nw_=primal(a$10),
                     _Nx_=caml_call2(Maths[12],_Nw_,_Nv_),
                     _Ny_=caml_call2(Maths[8],aa[1],_Nx_),
                     xs$12=[0,[0,caml_call2(Maths[8],_Ny_,_Nt_),a$10],_Ns_],
                     xs=xs$12;
                    continue;
                   case 13:
                    var
                     b$10=ao[2],
                     a$11=ao[1],
                     _Nz_=caml_call2(Maths[6],b$10,_fr_),
                     _NA_=primal(a$11),
                     _NB_=caml_call2(Maths[12],_NA_,_Nz_),
                     _NC_=caml_call2(Maths[8],aa[1],_NB_),
                     xs$13=[0,[0,caml_call2(Maths[8],_NC_,b$10),a$11],t],
                     xs=xs$13;
                    continue;
                   case 14:
                    var
                     b$11=ao[2],
                     a$12=ao[1],
                     _ND_=caml_call1(Maths[25],a$12),
                     _NE_=primal(b$11),
                     _NF_=caml_call2(Maths[12],a$12,_NE_),
                     _NG_=caml_call2(Maths[8],aa[1],_NF_),
                     xs$14=[0,[0,caml_call2(Maths[8],_NG_,_ND_),b$11],t],
                     xs=xs$14;
                    continue;
                   case 15:
                    var
                     b$12=ao[2],
                     a$13=ao[1],
                     _NH_=primal(b$12),
                     _NI_=caml_call1(Maths[23],_NH_),
                     _NJ_=primal(a$13),
                     _NK_=caml_call1(Maths[23],_NJ_),
                     d=caml_call2(Maths[4],_NK_,_NI_),
                     _NL_=primal(a$13),
                     _NM_=caml_call1(Maths[17],_NL_),
                     _NN_=caml_call2(Maths[8],aa[1],_NM_),
                     _NO_=[0,[0,caml_call2(Maths[10],_NN_,d),b$12],t],
                     _NP_=primal(b$12),
                     _NQ_=caml_call2(Maths[8],aa[1],_NP_),
                     xs$15=[0,[0,caml_call2(Maths[10],_NQ_,d),a$13],_NO_],
                     xs=xs$15;
                    continue;
                   case 16:
                    var
                     b$13=ao[2],
                     a$14=ao[1],
                     _NR_=caml_call1(Maths[23],b$13),
                     _NS_=primal(a$14),
                     _NT_=caml_call1(Maths[23],_NS_),
                     _NU_=caml_call2(Maths[4],_NT_,_NR_),
                     _NV_=caml_call2(Maths[8],aa[1],b$13),
                     xs$16=[0,[0,caml_call2(Maths[10],_NV_,_NU_),a$14],t],
                     xs=xs$16;
                    continue;
                   case 17:
                    var
                     b$14=ao[2],
                     a$15=ao[1],
                     _NW_=primal(b$14),
                     _NX_=caml_call1(Maths[23],_NW_),
                     _NY_=caml_call1(Maths[23],a$15),
                     _NZ_=caml_call2(Maths[4],_NY_,_NX_),
                     _N0_=caml_call1(Maths[17],a$15),
                     _N1_=caml_call2(Maths[8],aa[1],_N0_),
                     xs$17=[0,[0,caml_call2(Maths[10],_N1_,_NZ_),b$14],t],
                     xs=xs$17;
                    continue;
                   case 18:
                    var
                     a$16=ao[1],
                     xs$18=[0,[0,caml_call1(Maths[17],aa[1]),a$16],t],
                     xs=xs$18;
                    continue;
                   case 19:
                    var
                     a$17=ao[1],
                     _N2_=primal(a$17),
                     _N3_=caml_call1(Maths[19],_N2_),
                     xs$19=[0,[0,caml_call2(Maths[8],aa[1],_N3_),a$17],t],
                     xs=xs$19;
                    continue;
                   case 20:
                    var a$18=ao[1],xs$20=[0,[0,zero(a$18),a$18],t],xs=xs$20;
                    continue;
                   case 21:
                    var a$19=ao[1],xs$21=[0,[0,zero(a$19),a$19],t],xs=xs$21;
                    continue;
                   case 22:
                    var a$20=ao[1],xs$22=[0,[0,zero(a$20),a$20],t],xs=xs$22;
                    continue;
                   case 23:
                    var a$21=ao[1],xs$23=[0,[0,zero(a$21),a$21],t],xs=xs$23;
                    continue;
                   case 24:
                    var
                     a$22=ao[1],
                     _N4_=primal(a$22),
                     _N5_=caml_call2(Maths[8],aa[1],_N4_),
                     xs$24=[0,[0,caml_call2(Maths[8],_N5_,_fs_),a$22],t],
                     xs=xs$24;
                    continue;
                   case 25:
                    var
                     a$23=ao[1],
                     _N6_=caml_call2(Maths[8],_ft_,ap),
                     xs$25=[0,[0,caml_call2(Maths[10],aa[1],_N6_),a$23],t],
                     xs=xs$25;
                    continue;
                   case 26:
                    var
                     a$24=ao[1],
                     _N7_=primal(a$24),
                     xs$26=[0,[0,caml_call2(Maths[10],aa[1],_N7_),a$24],t],
                     xs=xs$26;
                    continue;
                   case 27:
                    var
                     a$25=ao[1],
                     _N8_=primal(a$25),
                     _N9_=caml_call2(Maths[8],_N8_,[0,log2e]),
                     xs$27=[0,[0,caml_call2(Maths[10],aa[1],_N9_),a$25],t],
                     xs=xs$27;
                    continue;
                   case 28:
                    var
                     a$26=ao[1],
                     _N__=primal(a$26),
                     _N$_=caml_call2(Maths[8],_N__,[0,log10e]),
                     xs$28=[0,[0,caml_call2(Maths[10],aa[1],_N$_),a$26],t],
                     xs=xs$28;
                    continue;
                   case 29:
                    var
                     a$27=ao[1],
                     xs$29=[0,[0,caml_call2(Maths[8],aa[1],ap),a$27],t],
                     xs=xs$29;
                    continue;
                   case 30:
                    var
                     a$28=ao[1],
                     _Oa_=primal(a$28),
                     _Ob_=caml_call1(Maths[30],_Oa_),
                     xs$30=[0,[0,caml_call2(Maths[8],aa[1],_Ob_),a$28],t],
                     xs=xs$30;
                    continue;
                   case 31:
                    var
                     a$29=ao[1],
                     _Oc_=primal(a$29),
                     _Od_=caml_call1(Maths[29],_Oc_),
                     _Oe_=caml_call1(Maths[17],_Od_),
                     xs$31=[0,[0,caml_call2(Maths[8],aa[1],_Oe_),a$29],t],
                     xs=xs$31;
                    continue;
                   case 32:
                    var
                     a$30=ao[1],
                     _Of_=primal(a$30),
                     _Og_=caml_call1(Maths[30],_Of_),
                     _Oh_=caml_call1(Maths[23],_Og_),
                     xs$32=[0,[0,caml_call2(Maths[10],aa[1],_Oh_),a$30],t],
                     xs=xs$32;
                    continue;
                   case 33:
                    var
                     a$31=ao[1],
                     _Oi_=primal(a$31),
                     _Oj_=caml_call1(Maths[33],_Oi_),
                     xs$33=[0,[0,caml_call2(Maths[8],aa[1],_Oj_),a$31],t],
                     xs=xs$33;
                    continue;
                   case 34:
                    var
                     a$32=ao[1],
                     _Ok_=primal(a$32),
                     _Ol_=caml_call1(Maths[32],_Ok_),
                     xs$34=[0,[0,caml_call2(Maths[8],aa[1],_Ol_),a$32],t],
                     xs=xs$34;
                    continue;
                   case 35:
                    var
                     a$33=ao[1],
                     _Om_=primal(a$33),
                     _On_=caml_call1(Maths[33],_Om_),
                     _Oo_=caml_call1(Maths[23],_On_),
                     xs$35=[0,[0,caml_call2(Maths[10],aa[1],_Oo_),a$33],t],
                     xs=xs$35;
                    continue;
                   case 36:
                    var
                     a$34=ao[1],
                     _Op_=primal(a$34),
                     _Oq_=caml_call1(Maths[23],_Op_),
                     _Or_=caml_call2(Maths[6],_fu_,_Oq_),
                     _Os_=caml_call1(Maths[24],_Or_),
                     xs$36=[0,[0,caml_call2(Maths[10],aa[1],_Os_),a$34],t],
                     xs=xs$36;
                    continue;
                   case 37:
                    var
                     a$35=ao[1],
                     _Ot_=primal(a$35),
                     _Ou_=caml_call1(Maths[23],_Ot_),
                     _Ov_=caml_call2(Maths[6],_fv_,_Ou_),
                     _Ow_=caml_call1(Maths[24],_Ov_),
                     _Ox_=caml_call1(Maths[17],aa[1]),
                     xs$37=[0,[0,caml_call2(Maths[10],_Ox_,_Ow_),a$35],t],
                     xs=xs$37;
                    continue;
                   case 38:
                    var
                     a$36=ao[1],
                     _Oy_=primal(a$36),
                     _Oz_=caml_call1(Maths[23],_Oy_),
                     _OA_=caml_call2(Maths[4],_fw_,_Oz_),
                     xs$38=[0,[0,caml_call2(Maths[10],aa[1],_OA_),a$36],t],
                     xs=xs$38;
                    continue;
                   case 39:
                    var
                     a$37=ao[1],
                     _OB_=primal(a$37),
                     _OC_=caml_call1(Maths[23],_OB_),
                     _OD_=caml_call2(Maths[4],_OC_,_fx_),
                     _OE_=caml_call1(Maths[24],_OD_),
                     xs$39=[0,[0,caml_call2(Maths[10],aa[1],_OE_),a$37],t],
                     xs=xs$39;
                    continue;
                   case 40:
                    var
                     a$38=ao[1],
                     _OF_=primal(a$38),
                     _OG_=caml_call1(Maths[23],_OF_),
                     _OH_=caml_call2(Maths[6],_OG_,_fy_),
                     _OI_=caml_call1(Maths[24],_OH_),
                     xs$40=[0,[0,caml_call2(Maths[10],aa[1],_OI_),a$38],t],
                     xs=xs$40;
                    continue;
                   case 41:
                    var
                     a$39=ao[1],
                     _OJ_=primal(a$39),
                     _OK_=caml_call1(Maths[23],_OJ_),
                     _OL_=caml_call2(Maths[6],_fz_,_OK_),
                     xs$41=[0,[0,caml_call2(Maths[10],aa[1],_OL_),a$39],t],
                     xs=xs$41;
                    continue;
                   case 42:
                    var
                     j=ao[3],
                     i=ao[2],
                     a$40=ao[1],
                     _OM_=caml_call1(Maths[46],aa[1]),
                     _ON_=zero(a$40),
                     xs$42=[0,[0,caml_call4(Maths[42],_ON_,i,j,_OM_),a$40],t],
                     xs=xs$42;
                    continue;
                   case 43:
                    var
                     b$15=ao[4],
                     j$0=ao[3],
                     i$0=ao[2],
                     a$41=ao[1],
                     _OO_=[0,[0,caml_call3(Maths[41],aa[1],i$0,j$0),b$15],t],
                     xs$43=
                      [0,[0,caml_call4(Maths[42],aa[1],i$0,j$0,_fA_),a$41],_OO_],
                     xs=xs$43;
                    continue;
                   default:
                    var
                     j$1=ao[3],
                     i$1=ao[2],
                     a$42=ao[1],
                     xs$44=
                      [0,[0,caml_call4(Maths[42],aa[1],i$1,j$1,_fB_),a$42],t],
                     xs=xs$44;
                    continue}}
              var xs=t;
              continue}
            var xs=t;
            continue}
          return 0}}
      function reverse_prop(v,x){reverse_reset(x);return reverse_push(v,x)}
      function make_forward(p,t,i){return [2,p,t,i]}
      function make_reverse(p,i){return [3,p,[0,zero(p)],0,[0,0],i]}
      function diff(f,x)
       {var x$0=[2,x,_fG_,tag(0)],y=caml_call1(f,x$0),_M4_=tangent(y);
        return [0,primal(y),_M4_]}
      function diff$0(f,x){return diff(f,x)[2]}
      function grad(f,x)
       {var x$0=make_reverse(x,tag(0)),y=caml_call1(f,x$0);
        reverse_reset(y);
        reverse_push(_fH_,y);
        var _M3_=adjval(x$0);
        return [0,primal(y),_M3_]}
      function grad$0(f,x){return grad(f,x)[2]}
      function jacobianv(f,x,v)
       {var x$0=[2,x,v,tag(0)],y=caml_call1(f,x$0),_M2_=tangent(y);
        return [0,primal(y),_M2_]}
      function jacobianv$0(f,x,v){return jacobianv(f,x,v)[2]}
      function jacobianTv(f,x,v)
       {var x$0=make_reverse(x,tag(0)),y=caml_call1(f,x$0);
        reverse_reset(y);
        reverse_push(v,y);
        var _M1_=primal(adjval(x$0));
        return [0,primal(y),_M1_]}
      function jacobianTv$0(f,x,v){return jacobianTv(f,x,v)[2]}
      function jacobian(f,x)
       {var
         y=primal(caml_call1(f,x)),
         m=col_num(y),
         n=col_num(x),
         z=caml_call1(A[1],[0,m,n]),
         match=n < m?1:0;
        if(0 === match)
         {var
           _MY_=
            init
             (m,
              function(i)
               {var v=caml_call1(A[2],[0,1,m]);
                caml_call3(A[13],v,[0,0,i],1);
                return jacobianTv$0(f,x,[1,v])});
          iteri
           (function(i,v)
             {if(1 === v[0]){var v$0=v[1];return caml_call3(A[108],v$0,z,i)}
              return failwith(_fI_)},
            _MY_)}
        else
         {var
           _MZ_=
            init
             (n,
              function(i)
               {var v=caml_call1(A[2],[0,1,n]);
                caml_call3(A[13],v,[0,0,i],1);
                return jacobianv$0(f,x,[1,v])});
          iteri
           (function(i,v)
             {if(1 === v[0])
               {var v$0=v[1],_M0_=caml_call2(A[113],0,v$0);
                return caml_call3(A[109],_M0_,z,i)}
              return failwith(_fJ_)},
            _MZ_)}
        return [0,y,[1,z]]}
      function jacobian$0(f,x){return jacobian(f,x)[2]}
      function gradhessian(f,x)
       {return jacobian(function(_MX_){return grad$0(f,_MX_)},x)}
      function gradhessian$0(f,x)
       {var match=gradhessian(f,x),h=match[2],g=match[1];
        return [0,caml_call1(f,x),g,h]}
      function hessian(f,x)
       {return jacobian$0(function(_MW_){return grad$0(f,_MW_)},x)}
      function hessian$0(f,x)
       {var _MV_=hessian(f,x);return [0,caml_call1(f,x),_MV_]}
      function gradhessianv(f,x,v)
       {var
         match=grad(function(y){return jacobianv$0(f,y,v)},x),
         hv=match[2],
         gv=match[1];
        return [0,caml_call1(f,x),gv,hv]}
      function gradhessianv$0(f,x,v)
       {var match=gradhessianv(f,x,v),hv=match[3],gv=match[2];
        return [0,gv,hv]}
      function hessianv(f,x,v)
       {var match=gradhessianv(f,x,v),hv=match[3],fv=match[1];
        return [0,fv,hv]}
      function hessianv$0(f,x,v)
       {var match=gradhessianv(f,x,v),hv=match[3];return hv}
      function laplacian(f,x)
       {var _MU_=unpack_arr(hessian(f,x));return [0,caml_call1(A[112],_MU_)]}
      function laplacian$0(f,x)
       {var _MT_=laplacian(f,x);return [0,caml_call1(f,x),_MT_]}
      function empty(m,n){return [1,caml_call1(A[1],[0,m,n])]}
      function zeros(m,n){return [1,caml_call1(A[2],[0,m,n])]}
      function ones(m,n){return [1,caml_call1(A[3],[0,m,n])]}
      function uniform(a,b,m,n){return [1,caml_call3(A[6],a,b,[0,m,n])]}
      function gaussian(mu,sigma,m,n)
       {return [1,caml_call3(A[7],mu,sigma,[0,m,n])]}
      function reset(x){var _MS_=unpack_arr(x);return caml_call1(A[17],_MS_)}
      function reshape$0(m,n,x){return caml_call2(Maths[75],x,[0,m,n])}
      function shape$0(x)
       {var
         _MQ_=unpack_arr(x),
         s=caml_call1(A[10],_MQ_),
         _MR_=caml_check_bound(s,1)[2];
        return [0,caml_check_bound(s,0)[1],_MR_]}
      function row_num$0(x)
       {var _MP_=unpack_arr(x);
        return caml_check_bound(caml_call1(A[10],_MP_),0)[1]}
      function col_num$0(x)
       {var _MO_=unpack_arr(x);
        return caml_check_bound(caml_call1(A[10],_MO_),1)[2]}
      function numel$0(x){return numel(x)}
      function row(x,i){return caml_call2(Maths[63],x,i)}
      function get(x,i,j){return caml_call3(Maths[41],x,i,j)}
      function set(x,i,j,a){return caml_call4(Maths[42],x,i,j,a)}
      function mean$0(x){return caml_call1(Maths[48],x)}
      function add$1(x,y){return caml_call2(Maths[5],x,y)}
      function sub$0(x,y){return caml_call2(Maths[7],x,y)}
      function mul$0(x,y){return caml_call2(Maths[9],x,y)}
      function div$0(x,y){return caml_call2(Maths[11],x,y)}
      function dot$0(x,y){return caml_call2(Maths[50],x,y)}
      function map_by_row(f,x)
       {var _MN_=map$0(f,caml_call1(Maths[64],x));
        return caml_call1(Maths[65],_MN_)}
      function print(x)
       {var _MM_=unpack_arr(x);return caml_call5(A[28],0,0,0,0,_MM_)}
      function of_arrays(x){return [1,caml_call1(A[117],x)]}
      var
       Mat=
        [0,
         empty,
         zeros,
         ones,
         uniform,
         gaussian,
         reset,
         reshape$0,
         shape$0,
         row_num$0,
         col_num$0,
         numel$0,
         row,
         get,
         set,
         mean$0,
         add$1,
         sub$0,
         mul$0,
         div$0,
         dot$0,
         map_by_row,
         print,
         of_arrays];
      function empty$0(d){return [1,caml_call1(A[1],d)]}
      function zeros$0(d){return [1,caml_call1(A[2],d)]}
      function ones$0(d){return [1,caml_call1(A[3],d)]}
      function uniform$0(a,b,d){return [1,caml_call3(A[6],a,b,d)]}
      function gaussian$0(mu,sigma,d){return [1,caml_call3(A[7],mu,sigma,d)]}
      function reset$0(x)
       {var _ML_=unpack_arr(x);return caml_call1(A[17],_ML_)}
      function reshape$1(x,s){return caml_call2(Maths[75],x,s)}
      function shape$1(x)
       {var _MK_=unpack_arr(x);return caml_call1(A[10],_MK_)}
      function numel$1(x){return numel(x)}
      function add$2(x,y){return caml_call2(Maths[5],x,y)}
      function sub$1(x,y){return caml_call2(Maths[7],x,y)}
      function mul$1(x,y){return caml_call2(Maths[9],x,y)}
      function div$1(x,y){return caml_call2(Maths[11],x,y)}
      function dot$1(x,y){return caml_call2(Maths[50],x,y)}
      var
       Arr=
        [0,
         empty$0,
         zeros$0,
         ones$0,
         uniform$0,
         gaussian$0,
         reset$0,
         reshape$1,
         shape$1,
         numel$1,
         add$2,
         sub$1,
         mul$1,
         div$1,
         dot$1];
      function traverse_trace(x)
       {var h=create$0(0,512),index=[0,0],tlist=x;
        a:
        for(;;)
         {if(tlist)
           {var
             tl=tlist[2],
             hd=tlist[1],
             _MG_=indexfun(h,hd),
             param$0=caml_check_bound(h[2],_MG_)[_MG_ + 1],
             param=param$0;
            for(;;)
             {if(param)
               {var
                 k=param[1],
                 next=param[3],
                 _MF_=0 === caml_compare(k,hd)?1:0;
                if(!_MF_){var param=next;continue}
                var _MH_=_MF_}
              else
               var _MH_=0;
              if(0 === _MH_)
               {switch(hd[0])
                 {case 0:var match=[0,sprintf(_fK_),0];break;
                  case 1:var match=[0,sprintf(_fL_),0];break;
                  case 2:var match=[0,sprintf(_fM_),0];break;
                  default:
                   var ao=hd[3];
                   if(typeof ao === "number")
                    var _MI_=_fN_;
                   else
                    {var _MJ_=ao[0];
                     if(45 <= _MJ_)
                      switch(_MJ_)
                       {case 45:
                         var b$19=ao[4],a$44=ao[1],_MI_=[0,_gv_,[0,a$44,[0,b$19,0]]];
                         break;
                        case 46:
                         var b$20=ao[4],a$45=ao[1],_MI_=[0,_gw_,[0,a$45,[0,b$20,0]]];
                         break;
                        case 47:
                         var b$21=ao[4],a$46=ao[1],_MI_=[0,_gx_,[0,a$46,[0,b$21,0]]];
                         break;
                        case 48:
                         var b$22=ao[4],a$47=ao[1],_MI_=[0,_gy_,[0,a$47,[0,b$22,0]]];
                         break;
                        case 49:var a$48=ao[1],_MI_=[0,_gz_,[0,a$48,0]];break;
                        case 50:
                         var b$23=ao[2],a$49=ao[1],_MI_=[0,_gA_,[0,a$49,[0,b$23,0]]];
                         break;
                        case 51:
                         var b$24=ao[2],a$50=ao[1],_MI_=[0,_gB_,[0,a$50,[0,b$24,0]]];
                         break;
                        case 52:
                         var b$25=ao[2],a$51=ao[1],_MI_=[0,_gC_,[0,a$51,[0,b$25,0]]];
                         break;
                        case 53:var a$52=ao[1],_MI_=[0,_gD_,[0,a$52,0]];break;
                        case 54:var a$53=ao[1],_MI_=[0,_gE_,[0,a$53,0]];break;
                        case 55:
                         var b$26=ao[2],a$54=ao[1],_MI_=[0,_gF_,[0,a$54,[0,b$26,0]]];
                         break;
                        case 56:
                         var b$27=ao[2],a$55=ao[1],_MI_=[0,_gG_,[0,a$55,[0,b$27,0]]];
                         break;
                        case 57:
                         var b$28=ao[2],a$56=ao[1],_MI_=[0,_gH_,[0,a$56,[0,b$28,0]]];
                         break;
                        case 58:var a$57=ao[1],_MI_=[0,_gI_,[0,a$57,0]];break;
                        case 59:var a$58=ao[1],_MI_=[0,_gJ_,[0,a$58,0]];break;
                        case 60:var a$59=ao[1],_MI_=[0,_gK_,[0,a$59,0]];break;
                        case 61:var a$60=ao[1],_MI_=[0,_gL_,[0,a$60,0]];break;
                        case 62:var a$61=ao[1],_MI_=[0,_gM_,[0,a$61,0]];break;
                        case 63:var a$62=ao[1],_MI_=[0,_gN_,[0,a$62,0]];break;
                        case 64:var a$63=ao[1],_MI_=[0,_gO_,[0,a$63,0]];break;
                        case 65:
                         var b$29=ao[2],a$64=ao[1],_MI_=[0,_gP_,[0,a$64,[0,b$29,0]]];
                         break;
                        case 66:
                         var b$30=ao[2],a$65=ao[1],_MI_=[0,_gQ_,[0,a$65,[0,b$30,0]]];
                         break;
                        case 67:
                         var b$31=ao[2],a$66=ao[1],_MI_=[0,_gR_,[0,a$66,[0,b$31,0]]];
                         break;
                        case 68:var a$67=ao[1],_MI_=[0,_gS_,[0,a$67,0]];break;
                        case 69:var a$68=ao[1],_MI_=[0,_gT_,to_list(a$68)];break;
                        case 70:
                         var b$32=ao[2],a$69=ao[1],_MI_=[0,_gU_,[0,a$69,[0,b$32,0]]];
                         break;
                        case 71:
                         var b$33=ao[2],a$70=ao[1],_MI_=[0,_gV_,[0,a$70,[0,b$33,0]]];
                         break;
                        case 72:
                         var b$34=ao[2],a$71=ao[1],_MI_=[0,_gW_,[0,a$71,[0,b$34,0]]];
                         break;
                        case 73:
                         var b$35=ao[2],a$72=ao[1],_MI_=[0,_gX_,[0,a$72,[0,b$35,0]]];
                         break;
                        case 74:
                         var b$36=ao[2],a$73=ao[1],_MI_=[0,_gY_,[0,a$73,[0,b$36,0]]];
                         break;
                        case 75:
                         var b$37=ao[2],a$74=ao[1],_MI_=[0,_gZ_,[0,a$74,[0,b$37,0]]];
                         break;
                        case 76:
                         var b$38=ao[2],a$75=ao[1],_MI_=[0,_g0_,[0,a$75,[0,b$38,0]]];
                         break;
                        case 77:
                         var b$39=ao[2],a$76=ao[1],_MI_=[0,_g1_,[0,a$76,[0,b$39,0]]];
                         break;
                        case 78:
                         var b$40=ao[2],a$77=ao[1],_MI_=[0,_g2_,[0,a$77,[0,b$40,0]]];
                         break;
                        case 79:
                         var b$41=ao[2],a$78=ao[1],_MI_=[0,_g3_,[0,a$78,[0,b$41,0]]];
                         break;
                        case 80:
                         var b$42=ao[2],a$79=ao[1],_MI_=[0,_g4_,[0,a$79,[0,b$42,0]]];
                         break;
                        case 81:
                         var b$43=ao[2],a$80=ao[1],_MI_=[0,_g5_,[0,a$80,[0,b$43,0]]];
                         break;
                        case 82:var a$81=ao[1],_MI_=[0,_g6_,[0,a$81,0]];break;
                        case 83:var a$82=ao[1],_MI_=[0,_g7_,[0,a$82,0]];break;
                        case 84:var a$83=ao[1],_MI_=[0,_g8_,[0,a$83,0]];break;
                        case 85:var a$84=ao[1],_MI_=[0,_g9_,[0,a$84,0]];break;
                        case 86:var a$85=ao[1],_MI_=[0,_g__,[0,a$85,0]];break;
                        case 87:var a$86=ao[1],_MI_=[0,_g$_,[0,a$86,0]];break;
                        default:var a$87=ao[1],_MI_=[0,_ha_,[0,a$87,0]]}
                     else
                      switch(_MJ_)
                       {case 0:
                         var b=ao[2],a=ao[1],_MI_=[0,_fO_,[0,a,[0,b,0]]];break;
                        case 1:
                         var b$0=ao[2],a$0=ao[1],_MI_=[0,_fP_,[0,a$0,[0,b$0,0]]];
                         break;
                        case 2:
                         var b$1=ao[2],a$1=ao[1],_MI_=[0,_fQ_,[0,a$1,[0,b$1,0]]];
                         break;
                        case 3:
                         var b$2=ao[2],a$2=ao[1],_MI_=[0,_fR_,[0,a$2,[0,b$2,0]]];
                         break;
                        case 4:
                         var b$3=ao[2],a$3=ao[1],_MI_=[0,_fS_,[0,a$3,[0,b$3,0]]];
                         break;
                        case 5:
                         var b$4=ao[2],a$4=ao[1],_MI_=[0,_fT_,[0,a$4,[0,b$4,0]]];
                         break;
                        case 6:
                         var b$5=ao[2],a$5=ao[1],_MI_=[0,_fU_,[0,a$5,[0,b$5,0]]];
                         break;
                        case 7:
                         var b$6=ao[2],a$6=ao[1],_MI_=[0,_fV_,[0,a$6,[0,b$6,0]]];
                         break;
                        case 8:
                         var b$7=ao[2],a$7=ao[1],_MI_=[0,_fW_,[0,a$7,[0,b$7,0]]];
                         break;
                        case 9:
                         var b$8=ao[2],a$8=ao[1],_MI_=[0,_fX_,[0,a$8,[0,b$8,0]]];
                         break;
                        case 10:
                         var b$9=ao[2],a$9=ao[1],_MI_=[0,_fY_,[0,a$9,[0,b$9,0]]];
                         break;
                        case 11:
                         var b$10=ao[2],a$10=ao[1],_MI_=[0,_fZ_,[0,a$10,[0,b$10,0]]];
                         break;
                        case 12:
                         var b$11=ao[2],a$11=ao[1],_MI_=[0,_f0_,[0,a$11,[0,b$11,0]]];
                         break;
                        case 13:
                         var b$12=ao[2],a$12=ao[1],_MI_=[0,_f1_,[0,a$12,[0,b$12,0]]];
                         break;
                        case 14:
                         var b$13=ao[2],a$13=ao[1],_MI_=[0,_f2_,[0,a$13,[0,b$13,0]]];
                         break;
                        case 15:
                         var b$14=ao[2],a$14=ao[1],_MI_=[0,_f3_,[0,a$14,[0,b$14,0]]];
                         break;
                        case 16:
                         var b$15=ao[2],a$15=ao[1],_MI_=[0,_f4_,[0,a$15,[0,b$15,0]]];
                         break;
                        case 17:
                         var b$16=ao[2],a$16=ao[1],_MI_=[0,_f5_,[0,a$16,[0,b$16,0]]];
                         break;
                        case 18:var a$17=ao[1],_MI_=[0,_f6_,[0,a$17,0]];break;
                        case 19:var a$18=ao[1],_MI_=[0,_f7_,[0,a$18,0]];break;
                        case 20:var a$19=ao[1],_MI_=[0,_f8_,[0,a$19,0]];break;
                        case 21:var a$20=ao[1],_MI_=[0,_f9_,[0,a$20,0]];break;
                        case 22:var a$21=ao[1],_MI_=[0,_f__,[0,a$21,0]];break;
                        case 23:var a$22=ao[1],_MI_=[0,_f$_,[0,a$22,0]];break;
                        case 24:var a$23=ao[1],_MI_=[0,_ga_,[0,a$23,0]];break;
                        case 25:var a$24=ao[1],_MI_=[0,_gb_,[0,a$24,0]];break;
                        case 26:var a$25=ao[1],_MI_=[0,_gc_,[0,a$25,0]];break;
                        case 27:var a$26=ao[1],_MI_=[0,_gd_,[0,a$26,0]];break;
                        case 28:var a$27=ao[1],_MI_=[0,_ge_,[0,a$27,0]];break;
                        case 29:var a$28=ao[1],_MI_=[0,_gf_,[0,a$28,0]];break;
                        case 30:var a$29=ao[1],_MI_=[0,_gg_,[0,a$29,0]];break;
                        case 31:var a$30=ao[1],_MI_=[0,_gh_,[0,a$30,0]];break;
                        case 32:var a$31=ao[1],_MI_=[0,_gi_,[0,a$31,0]];break;
                        case 33:var a$32=ao[1],_MI_=[0,_gj_,[0,a$32,0]];break;
                        case 34:var a$33=ao[1],_MI_=[0,_gk_,[0,a$33,0]];break;
                        case 35:var a$34=ao[1],_MI_=[0,_gl_,[0,a$34,0]];break;
                        case 36:var a$35=ao[1],_MI_=[0,_gm_,[0,a$35,0]];break;
                        case 37:var a$36=ao[1],_MI_=[0,_gn_,[0,a$36,0]];break;
                        case 38:var a$37=ao[1],_MI_=[0,_go_,[0,a$37,0]];break;
                        case 39:var a$38=ao[1],_MI_=[0,_gp_,[0,a$38,0]];break;
                        case 40:var a$39=ao[1],_MI_=[0,_gq_,[0,a$39,0]];break;
                        case 41:var a$40=ao[1],_MI_=[0,_gr_,[0,a$40,0]];break;
                        case 42:var a$41=ao[1],_MI_=[0,_gs_,[0,a$41,0]];break;
                        case 43:
                         var b$17=ao[4],a$42=ao[1],_MI_=[0,_gt_,[0,a$42,[0,b$17,0]]];
                         break;
                        default:
                         var b$18=ao[4],a$43=ao[1],_MI_=[0,_gu_,[0,a$43,[0,b$18,0]]]}}
                   var match=_MI_}
                var prev=match[2],op=match[1];
                add(h,hd,[0,index[1],op,prev]);
                index[1] = index[1] + 1 | 0;
                var tlist$0=append(prev,tl),tlist=tlist$0;
                continue a}
              var tlist=tl;
              continue a}}
          return h}}
      function convert_terminal_output(nodes)
       {return fold
                (function(v,param,s0)
                  {var
                    v_prev=param[3],
                    v_op=param[2],
                    v_id=param[1],
                    v_ts=type_info(v);
                   return _d_
                           (s0,
                            fold_left
                             (function(s1,u)
                               {var
                                 match=find(nodes,u),
                                 u_op=match[2],
                                 u_id=match[1],
                                 u_ts=type_info(u);
                                return _d_
                                        (s1,caml_call6(sprintf(_hd_),u_id,u_op,u_ts,v_id,v_op,v_ts))},
                              _hc_,
                              v_prev))},
                 nodes,
                 _hb_)}
      function convert_dot_output(nodes)
       {var
         network=
          fold
           (function(v,param,s0)
             {var v_prev=param[3],v_id=param[1];
              return _d_
                      (s0,
                       fold_left
                        (function(s1,u)
                          {var match=find(nodes,u),u_id=match[1];
                           return _d_(s1,caml_call2(sprintf(_hg_),u_id,v_id))},
                         _hf_,
                         v_prev))},
            nodes,
            _he_),
         attrs=
          fold
           (function(v,param,s0)
             {var v_op=param[2],v_id=param[1];
              if(caml_string_equal(v_op,_hi_))
               {var _MD_=deep_info(v);
                return _d_(s0,caml_call4(sprintf(_hj_),v_id,v_id,v_op,_MD_))}
              var _ME_=deep_info(v);
              return _d_(s0,caml_call4(sprintf(_hk_),v_id,v_id,v_op,_ME_))},
            nodes,
            _hh_);
        return _d_(network,attrs)}
      function to_trace(nodes)
       {return convert_terminal_output(traverse_trace(nodes))}
      function to_dot(nodes)
       {var _MC_=convert_dot_output(traverse_trace(nodes));
        return caml_call1(sprintf(_hl_),_MC_)}
      function pp_num(formatter,x)
       {var _MB_=type_info(x);
        return caml_call2(fprintf$0(formatter),_hm_,_MB_)}
      return [0,
              global_tag,
              tag,
              cmp_tag,
              reset_zero,
              primal,
              primal$0,
              zero,
              tangent,
              adjref,
              adjval,
              shape,
              row_num,
              col_num,
              numel,
              clip_by_value,
              clip_by_l2norm,
              copy_primal,
              tile,
              repeat,
              pack_arr,
              unpack_arr,
              pack_flt,
              unpack_flt,
              deep_info,
              type_info,
              error_binop,
              error_uniop,
              Maths,
              reverse_reset,
              reverse_push,
              reverse_prop,
              make_forward,
              make_reverse,
              diff,
              diff$0,
              grad,
              grad$0,
              jacobianv,
              jacobianv$0,
              jacobianTv,
              jacobianTv$0,
              jacobian,
              jacobian$0,
              gradhessian,
              gradhessian$0,
              hessian,
              hessian$0,
              gradhessianv,
              gradhessianv$0,
              hessianv,
              hessianv$0,
              laplacian,
              laplacian$0,
              Mat,
              Arr,
              traverse_trace,
              convert_terminal_output,
              convert_dot_output,
              to_trace,
              to_dot,
              pp_num]}
    function add$1(x,y){return x + y}
    function sub$3(x,y){return x - y}
    function mul$0(x,y){return x * y}
    function div$0(x,y){return x / y}
    function pow(x,y){return Math.pow(x,y)}
    function atan2(x,y){return Math.atan2(x,y)}
    function abs$0(x){return Math.abs(x)}
    function neg(x){return -x}
    function sqr(x){return x * x}
    function sqrt(x){return Math.sqrt(x)}
    function exp(x){return Math.exp(x)}
    function log(x){return Math.log(x)}
    function log2(x){return Math.log(x) / 0.693147180559945286}
    var log10=caml_log10_float;
    function signum(x)
     {return 0 === caml_float_compare(x,nan)?nan:0 < x?1:x < 0?-1:0}
    function floor(x){return Math.floor(x)}
    function ceil(x){return Math.ceil(x)}
    function round(x){return Math.floor(x + 0.5)}
    function sin(x){return Math.sin(x)}
    function cos(x){return Math.cos(x)}
    function tan(x){return Math.tan(x)}
    var sinh=caml_sinh_float,cosh=caml_cosh_float,tanh=caml_tanh_float;
    function asin(x){return Math.asin(x)}
    function acos(x){return Math.acos(x)}
    function atan(x){return Math.atan(x)}
    function asinh(x){return Math.log(x + Math.sqrt(x * x + 1))}
    function acosh(x){return Math.log(x + Math.sqrt(x * x - 1))}
    function atanh(x){return 0.5 * Math.log((1 + x) / (1 - x))}
    function relu(x){return max(0,x)}
    function sigmoid(x){return 1 / (1 + Math.log(-x))}
    var
     rand_gen=make_self_init(0),
     u1=[0,0],
     u2=[0,0],
     case$0=[0,0],
     z0=[0,0],
     z1=[0,1];
    function add_elt(param)
     {switch(param)
       {case 0:return function(_Mu_,_Mt_){return _Mu_ + _Mt_};
        case 1:return function(_Ms_,_Mr_){return _Ms_ + _Mr_};
        case 2:return function(_Mq_,_Mp_){return _Mq_ + _Mp_ | 0};
        case 3:return function(_Mo_,_Mn_){return _Mo_ + _Mn_ | 0};
        case 4:return function(_Mm_,_Ml_){return _Mm_ + _Ml_ | 0};
        case 5:return function(_Mk_,_Mj_){return _Mk_ + _Mj_ | 0};
        case 6:return function(_Mi_,_Mh_){return _Mi_ + _Mh_ | 0};
        case 7:return caml_int64_add;
        case 10:return add$0;
        case 11:return add$0;
        default:return failwith(_ho_)}}
    function sub_elt(param)
     {switch(param)
       {case 0:return function(_Mg_,_Mf_){return _Mg_ - _Mf_};
        case 1:return function(_Me_,_Md_){return _Me_ - _Md_};
        case 2:return function(_Mc_,_Mb_){return _Mc_ - _Mb_ | 0};
        case 3:return function(_Ma_,_L$_){return _Ma_ - _L$_ | 0};
        case 4:return function(_L__,_L9_){return _L__ - _L9_ | 0};
        case 5:return function(_L8_,_L7_){return _L8_ - _L7_ | 0};
        case 6:return function(_L6_,_L5_){return _L6_ - _L5_ | 0};
        case 7:return caml_int64_sub;
        case 10:return sub$2;
        case 11:return sub$2;
        default:return failwith(_hp_)}}
    function mul_elt(param)
     {switch(param)
       {case 0:return function(_L4_,_L3_){return _L4_ * _L3_};
        case 1:return function(_L2_,_L1_){return _L2_ * _L1_};
        case 2:return function(_L0_,_LZ_){return caml_mul(_L0_,_LZ_)};
        case 3:return function(_LY_,_LX_){return caml_mul(_LY_,_LX_)};
        case 4:return function(_LW_,_LV_){return caml_mul(_LW_,_LV_)};
        case 5:return function(_LU_,_LT_){return caml_mul(_LU_,_LT_)};
        case 6:return function(_LS_,_LR_){return caml_mul(_LS_,_LR_)};
        case 7:return caml_int64_mul;
        case 10:return mul;
        case 11:return mul;
        default:return failwith(_hq_)}}
    function div_elt(param)
     {switch(param)
       {case 0:return function(_LQ_,_LP_){return _LQ_ / _LP_};
        case 1:return function(_LO_,_LN_){return _LO_ / _LN_};
        case 2:return caml_div;
        case 3:return caml_div;
        case 4:return caml_div;
        case 5:return caml_div;
        case 6:return caml_div;
        case 7:return caml_int64_div;
        case 10:return div;
        case 11:return div;
        default:return failwith(_hr_)}}
    function prepend_dims(dims,desired_len)
     {var dims_len=dims.length - 1;
      return desired_len <= dims_len
              ?dims
              :append$0(caml_make_vect(desired_len - dims_len | 0,1),dims)}
    function next_index(ind,dims)
     {var num_dims=ind.length - 1,p=[0,num_dims - 1 | 0],ok=[0,0];
      for(;;)
       {if(0 <= p[1])
         if(!ok[1])
          {var _LG_=p[1],_LH_=caml_check_bound(dims,_LG_)[_LG_ + 1],_LI_=p[1];
           if((caml_check_bound(ind,_LI_)[_LI_ + 1] + 1 | 0) < _LH_)
            {var
              _LJ_=p[1],
              _LK_=caml_check_bound(ind,_LJ_)[_LJ_ + 1] + 1 | 0,
              _LL_=p[1];
             caml_check_bound(ind,_LL_)[_LL_ + 1] = _LK_;
             ok[1] = 1;
             continue}
           var _LM_=p[1];
           caml_check_bound(ind,_LM_)[_LM_ + 1] = 0;
           p[1] = p[1] - 1 | 0;
           continue}
        return ok[1]}}
    function get_broadcasted_index(ind,dims)
     {var num_dims=dims.length - 1;
      function calc_fun(i)
       {var
         max_ind=caml_check_bound(dims,i)[i + 1],
         ind_val=caml_check_bound(ind,i)[i + 1];
        if(ind_val < max_ind)return ind_val;
        if(1 === max_ind)return 0;
        throw [0,Invalid_argument,_hG_]}
      return init(num_dims,calc_fun)}
    function apply_perm(arr,perm)
     {return init
              (arr.length - 1,
               function(i)
                {var _LF_=caml_check_bound(perm,i)[i + 1];
                 return caml_check_bound(arr,_LF_)[_LF_ + 1]})}
    function enumerate_slice_def(dim,step,start,stop)
     {var
       start$0=0 <= start?start:dim + start | 0,
       stop$0=0 <= stop?stop:dim + stop | 0;
      if(step)var x=step[1],step$0=x;else var step$0=start$0 <= stop$0?1:-1;
      var switch$0=start$0 <= stop$0?0 < step$0?1:0:0;
      if(!switch$0)
       {var switch$1=stop$0 < start$0?0 <= step$0?1:0:1;
        if(switch$1)throw [0,Assert_failure,_hI_]}
      var
       step_abs=abs(step$0),
       len=caml_div(abs(stop$0 - start$0 | 0) + step_abs | 0,step_abs);
      return init(len,function(i){return start$0 + caml_mul(i,step$0) | 0})}
    function expand_slice_indices(index_list,dims)
     {var rank=dims.length - 1,len=0,param=index_list;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        var
         expand_slice_index=
          function(i,ind)
           {if(ind)
             {var _LA_=ind[2],_LB_=ind[1];
              if(_LA_)
               {var _LC_=_LA_[2],_LD_=_LA_[1];
                if(_LC_)
                 {if(_LC_[2])return failwith(_hJ_);
                  var step=_LC_[1];
                  return enumerate_slice_def
                          (caml_check_bound(dims,i)[i + 1],[0,step],_LB_,_LD_)}
                return enumerate_slice_def
                        (caml_check_bound(dims,i)[i + 1],0,_LB_,_LD_)}
              return enumerate_slice_def
                      (caml_check_bound(dims,i)[i + 1],0,_LB_,_LB_)}
            function _LE_(i){return i}
            return init(caml_check_bound(dims,i)[i + 1],_LE_)},
         _Lx_=
          init
           (rank - len | 0,
            function(p)
             {var _Lz_=p + len | 0;
              function _Ly_(i){return i}
              return init(caml_check_bound(dims,_Lz_)[_Lz_ + 1],_Ly_)});
        return append$0(of_list(mapi(expand_slice_index,index_list)),_Lx_)}}
    function create$1(kind,dims,value)
     {var varr=caml_ba_create(kind,0,dims);
      caml_ba_fill(varr,value);
      return varr}
    function zeros(kind,dims){return create$1(kind,dims,zero$0(kind))}
    function shape(varr){return dims(varr)}
    function num_dims(varr){return shape(varr).length - 1}
    function numel(varr)
     {var v_shape=shape(varr),_Lu_=1;
      return fold_left$0
              (function(_Lw_,_Lv_){return caml_mul(_Lw_,_Lv_)},_Lu_,v_shape)}
    var get=caml_ba_get_generic,set=caml_ba_set_generic;
    function get_slice(index_list,varr)
     {var
       dims=shape(varr),
       rank=dims.length - 1,
       index_array=expand_slice_indices(index_list,dims),
       slice_dims=map$0(function(a){return a.length - 1},index_array),
       slice_varr=caml_ba_create(caml_ba_kind(varr),0,slice_dims),
       slice_ind=caml_make_vect(rank,0),
       original_ind=caml_make_vect(rank,0),
       should_stop=[0,0];
      for(;;)
       {if(should_stop[1])return slice_varr;
        var _Lq_=rank - 1 | 0,_Lp_=0;
        if(!(_Lq_ < 0))
         {var i=_Lp_;
          for(;;)
           {var
             _Lr_=caml_check_bound(slice_ind,i)[i + 1],
             _Ls_=
              caml_check_bound(caml_check_bound(index_array,i)[i + 1],_Lr_)
               [_Lr_ + 1];
            caml_check_bound(original_ind,i)[i + 1] = _Ls_;
            var _Lt_=i + 1 | 0;
            if(_Lq_ !== i){var i=_Lt_;continue}
            break}}
        caml_ba_set_generic
         (slice_varr,slice_ind,caml_ba_get_generic(varr,original_ind));
        if(1 - next_index(slice_ind,slice_dims)){should_stop[1] = 1;continue}
        continue}}
    function set_slice(index_list,varr,slice_varr)
     {var
       dims=shape(varr),
       rank=dims.length - 1,
       index_array=expand_slice_indices(index_list,dims),
       slice_dims=map$0(function(a){return a.length - 1},index_array),
       slice_varr$0=caml_ba_reshape(slice_varr,slice_dims),
       slice_ind=caml_make_vect(rank,0),
       original_ind=caml_make_vect(rank,0),
       should_stop=[0,0];
      for(;;)
       {if(should_stop[1])return 0;
        var _Ll_=rank - 1 | 0,_Lk_=0;
        if(!(_Ll_ < 0))
         {var i=_Lk_;
          for(;;)
           {var
             _Lm_=caml_check_bound(slice_ind,i)[i + 1],
             _Ln_=
              caml_check_bound(caml_check_bound(index_array,i)[i + 1],_Lm_)
               [_Lm_ + 1];
            caml_check_bound(original_ind,i)[i + 1] = _Ln_;
            var _Lo_=i + 1 | 0;
            if(_Ll_ !== i){var i=_Lo_;continue}
            break}}
        caml_ba_set_generic
         (varr,original_ind,caml_ba_get_generic(slice_varr$0,slice_ind));
        if(1 - next_index(slice_ind,slice_dims)){should_stop[1] = 1;continue}
        continue}}
    function copy$0(varr)
     {var
       _Lj_=shape(varr),
       varr_copy=caml_ba_create(caml_ba_kind(varr),0,_Lj_);
      caml_ba_blit(varr,varr_copy);
      return varr_copy}
    function reset(varr){return caml_ba_fill(varr,0)}
    var reshape=caml_ba_reshape;
    function flatten(varr){return caml_ba_reshape(varr,[0,numel(varr)])}
    function reverse(varr)
     {var
       n=numel(varr),
       _Lf_=shape(varr),
       ret=caml_ba_create(caml_ba_kind(varr),0,_Lf_),
       ret_flat=caml_ba_reshape(ret,[0,n]),
       varr_flat=caml_ba_reshape(varr,[0,n]),
       _Lh_=n - 1 | 0,
       _Lg_=0;
      if(!(_Lh_ < 0))
       {var i=_Lg_;
        for(;;)
         {caml_ba_set_generic
           (ret_flat,
            [0,i],
            caml_ba_get_generic(varr_flat,[0,(n - 1 | 0) - i | 0]));
          var _Li_=i + 1 | 0;
          if(_Lh_ !== i){var i=_Li_;continue}
          break}}
      return ret}
    function apply_fun(f,varr)
     {var
       varr_linear=array1_of_genarray(flatten(varr)),
       length=numel(varr),
       _Ld_=length - 1 | 0,
       _Lc_=0;
      if(!(_Ld_ < 0))
       {var i=_Lc_;
        for(;;)
         {caml_ba_set_1
           (varr_linear,i,caml_call1(f,caml_ba_get_1(varr_linear,i)));
          var _Le_=i + 1 | 0;
          if(_Ld_ !== i){var i=_Le_;continue}
          break}}
      return 0}
    function map$2(f,varr)
     {var varr_copy=copy$0(varr);apply_fun(f,varr_copy);return varr_copy}
    function strides(x){return calc_stride(shape(x))}
    function slice_size(x)
     {var
       s=shape(x),
       d=s.length - 1,
       _K8_=d - 1 | 0,
       r=caml_make_vect(d,caml_check_bound(s,_K8_)[_K8_ + 1]),
       _K9_=d - 2 | 0;
      if(!(_K9_ < 0))
       {var i=_K9_;
        for(;;)
         {var
           _K__=i + 1 | 0,
           _K$_=caml_check_bound(r,_K__)[_K__ + 1],
           _La_=caml_mul(caml_check_bound(s,i)[i + 1],_K$_);
          caml_check_bound(r,i)[i + 1] = _La_;
          var _Lb_=i - 1 | 0;
          if(0 !== i){var i=_Lb_;continue}
          break}}
      return r}
    function fold$0(axis$0,f,a,x$0)
     {function f$0(param,b,c){return caml_call2(f,b,c)}
      var x=array1_of_genarray(flatten(x$0));
      if(axis$0)
       {var axis=axis$0[1],d=num_dims(x$0);
        if(0 <= axis)
         if(axis < d)
          {var
            s=shape(x$0),
            stride=strides(x$0),
            slicez=slice_size(x$0),
            _KW_=caml_check_bound(slicez,axis)[axis + 1],
            m=caml_div(numel(x$0),_KW_),
            n=caml_check_bound(slicez,axis)[axis + 1],
            o=caml_check_bound(stride,axis)[axis + 1];
           caml_check_bound(s,axis)[axis + 1] = 1;
           var
            start_x=[0,0],
            start_y=[0,0],
            incy=[0,0],
            k=[0,0],
            y=create$1(caml_ba_kind(x$0),s,a),
            y$0=array1_of_genarray(flatten(y)),
            _KY_=m - 1 | 0,
            _KX_=0;
           if(!(_KY_ < 0))
            {var i=_KX_;
             for(;;)
              {var _K0_=n - 1 | 0,_KZ_=0;
               if(!(_K0_ < 0))
                {var j=_KZ_;
                 for(;;)
                  {var
                    b=caml_ba_get_1(y$0,start_y[1] + incy[1] | 0),
                    c=caml_ba_get_1(x,start_x[1] + j | 0),
                    _K2_=f$0(k[1],b,c);
                   caml_ba_set_1(y$0,start_y[1] + incy[1] | 0,_K2_);
                   incy[1] = (incy[1] + 1 | 0) === o?0:incy[1] + 1 | 0;
                   k[1] = k[1] + 1 | 0;
                   var _K3_=j + 1 | 0;
                   if(_K0_ !== j){var j=_K3_;continue}
                   break}}
               start_x[1] = start_x[1] + n | 0;
               start_y[1] = start_y[1] + o | 0;
               var _K1_=i + 1 | 0;
               if(_KY_ !== i){var i=_K1_;continue}
               break}}
           return y}
        throw [0,Assert_failure,_hK_]}
      var b$0=[0,a],_K5_=numel(x$0) - 1 | 0,_K4_=0;
      if(!(_K5_ < 0))
       {var i$0=_K4_;
        for(;;)
         {var c$0=caml_ba_get_1(x,i$0);
          b$0[1] = f$0(i$0,b$0[1],c$0);
          var _K7_=i$0 + 1 | 0;
          if(_K5_ !== i$0){var i$0=_K7_;continue}
          break}}
      var _K6_=b$0[1];
      return create$1(caml_ba_kind(x$0),[0,1],_K6_)}
    function scan(axis,f,x)
     {var d=num_dims(x);
      if(axis)var a=axis[1],a$0=a;else var a$0=d - 1 | 0;
      if(0 <= a$0)
       if(a$0 < d)
        {var
          stride=strides(x),
          slicez=slice_size(x),
          _KN_=caml_check_bound(slicez,a$0)[a$0 + 1],
          m=caml_div(numel(x),_KN_),
          _KO_=caml_check_bound(stride,a$0)[a$0 + 1],
          n=caml_check_bound(slicez,a$0)[a$0 + 1] - _KO_ | 0,
          incx=caml_check_bound(slicez,a$0)[a$0 + 1],
          incy=slicez[a$0 + 1],
          start_x=[0,0],
          start_y=[0,caml_check_bound(stride,a$0)[a$0 + 1]],
          k=[0,0],
          y=copy$0(x),
          y$0=array1_of_genarray(flatten(y)),
          _KQ_=m - 1 | 0,
          _KP_=0;
         if(!(_KQ_ < 0))
          {var i=_KP_;
           for(;;)
            {var _KS_=n - 1 | 0,_KR_=0;
             if(!(_KS_ < 0))
              {var j=_KR_;
               for(;;)
                {var
                  a$1=caml_ba_get_1(y$0,start_x[1] + j | 0),
                  b=caml_ba_get_1(y$0,start_y[1] + j | 0),
                  _KV_=caml_call2(f,a$1,b);
                 caml_ba_set_1(y$0,start_y[1] + j | 0,_KV_);
                 k[1] = k[1] + 1 | 0;
                 var _KU_=j + 1 | 0;
                 if(_KS_ !== j){var j=_KU_;continue}
                 break}}
             start_x[1] = start_x[1] + incx | 0;
             start_y[1] = start_y[1] + incy | 0;
             var _KT_=i + 1 | 0;
             if(_KQ_ !== i){var i=_KT_;continue}
             break}}
         return y}
      throw [0,Assert_failure,_hL_]}
    function print(max_row$0,max_col$0,header$0,fmt,varr)
     {var
       dims$0=shape(varr),
       rank=dims$0.length - 1,
       _Kw_=rank - 1 | 0,
       n$0=caml_check_bound(dims$0,_Kw_)[_Kw_ + 1];
      if(max_row$0)
       var a$0=max_row$0[1],max_row$1=[0,a$0];
      else
       var max_row$1=[0,caml_div(numel(varr),n$0)];
      if(max_col$0)
       var a$1=max_col$0[1],max_col$1=[0,a$1];
      else
       var max_col$1=[0,n$0];
      if(header$0)var sth=header$0[1],header=sth;else var header=1;
      if(max_row$1)var sth$0=max_row$1[1],max_row=sth$0;else var max_row=10;
      if(max_col$1)var sth$1=max_col$1[1],max_col=sth$1;else var max_col=10;
      if(fmt)
       var f$0=fmt[1],elt_to_str_fun=f$0;
      else
       {var param=caml_ba_kind(varr);
        switch(param)
         {case 0:
           var _Kv_=function(v){return caml_call1(sprintf(_dd_),v)};break;
          case 1:
           var _Kv_=function(v){return caml_call1(sprintf(_de_),v)};break;
          case 2:
           var _Kv_=function(v){return caml_call1(sprintf(_df_),v)};break;
          case 3:
           var _Kv_=function(v){return caml_call1(sprintf(_dg_),v)};break;
          case 4:
           var _Kv_=function(v){return caml_call1(sprintf(_dh_),v)};break;
          case 5:
           var _Kv_=function(v){return caml_call1(sprintf(_di_),v)};break;
          case 6:
           var _Kv_=function(v){return caml_call1(sprintf(_dj_),v)};break;
          case 7:
           var _Kv_=function(v){return caml_call1(sprintf(_dk_),v)};break;
          case 8:
           var _Kv_=function(v){return caml_call1(sprintf(_dl_),v)};break;
          case 9:
           var _Kv_=function(v){return caml_call1(sprintf(_dm_),v)};break;
          case 10:
           var
            _Kv_=
             function(v)
              {var _KL_=v[2],_KM_=v[1];
               return caml_call2(sprintf(_dn_),_KM_,_KL_)};
           break;
          case 11:
           var
            _Kv_=
             function(v)
              {var _KJ_=v[2],_KK_=v[1];
               return caml_call2(sprintf(_do_),_KK_,_KJ_)};
           break;
          default:var _Kv_=function(v){return caml_call1(sprintf(_dp_),v)}}
        var elt_to_str_fun=_Kv_}
      if(0 === caml_ba_num_dims(varr))
       var out_s$0=caml_call1(elt_to_str_fun,caml_ba_get_generic(varr,[0]));
      else
       {var
         shape$0=dims(varr),
         _Kk_=caml_ba_num_dims(varr) - 1 | 0,
         col_num=caml_check_bound(shape$0,_Kk_)[_Kk_ + 1],
         _Kl_=1,
         row_num=
          caml_div
           (fold_left$0
             (function(_KI_,_KH_){return caml_mul(_KI_,_KH_)},_Kl_,shape$0),
            col_num),
         y=caml_ba_reshape(varr,[0,row_num,col_num]),
         discontinuous=
          function(max_w,w)
           {var
             half=max_w / 2 | 0,
             fst_half=init(half,function(i){return i}),
             snd_half=init(half,function(i){return (i + w | 0) - half | 0});
            return append$0(append$0(fst_half,[0,-1]),snd_half)},
         match=row_num <= max_row?1:0,
         row_indices=
          0 === match
           ?discontinuous(max_row,row_num)
           :init(row_num,function(i){return i}),
         match$0=col_num <= max_col?1:0,
         col_indices=
          0 === match$0
           ?discontinuous(max_col,col_num)
           :init(col_num,function(i){return i}),
         sx=row_indices.length - 1,
         sy=col_indices.length - 1,
         tbody=caml_make_vect(sx,[0]),
         _Kf_=sx - 1 | 0,
         _Ke_=0;
        if(!(_Kf_ < 0))
         {var x=_Ke_;
          for(;;)
           {tbody[x + 1] = caml_make_vect(sy,init$0);
            var _Kg_=x + 1 | 0;
            if(_Kf_ !== x){var x=_Kg_;continue}
            break}}
        iteri
         (function(i$0,i)
           {return iteri
                    (function(j$0,j)
                      {if(0 <= i)
                        if(0 <= j)
                         {var
                           e=caml_ba_get_generic(y,[0,i,j]),
                           s=caml_call1(elt_to_str_fun,e);
                          return caml_check_bound
                                   (caml_check_bound(tbody,i$0)[i$0 + 1],j$0)
                                  [j$0 + 1]
                                 =
                                 s}
                       return caml_check_bound
                                (caml_check_bound(tbody,i$0)[i$0 + 1],j$0)
                               [j$0 + 1]
                              =
                              _hz_},
                     col_indices)},
          row_indices);
        var
         shape$1=dims(varr),
         s=calc_stride(shape$1),
         dim_num=shape$1.length - 1,
         _Km_=dim_num - 1 | 0,
         col_num$0=caml_check_bound(shape$1,_Km_)[_Km_ + 1],
         row_header=
          map$0
           (function(i)
             {if(0 <= i)
               {var
                 i$0=caml_mul(i,col_num$0),
                 j=copy(s),
                 _KA_=caml_div(i$0,caml_check_bound(s,0)[1]);
                caml_check_bound(j,0)[1] = _KA_;
                var _KC_=s.length - 1 - 1 | 0,_KB_=1;
                if(!(_KC_ < 1))
                 {var k=_KB_;
                  for(;;)
                   {var
                     _KE_=k - 1 | 0,
                     _KD_=caml_check_bound(s,k)[k + 1],
                     _KF_=
                      caml_div
                       (caml_mod(i$0,caml_check_bound(s,_KE_)[_KE_ + 1]),_KD_);
                    caml_check_bound(j,k)[k + 1] = _KF_;
                    var _KG_=k + 1 | 0;
                    if(_KC_ !== k){var k=_KG_;continue}
                    break}}
                var
                 idx_nd=sub$1(j,0,dim_num - 1 | 0),
                 idx_s=
                  1 === dim_num
                   ?_hs_
                   :2 === dim_num
                     ?caml_new_string("" + caml_check_bound(idx_nd,0)[1])
                     :string_of_array(_hv_,_hu_,0,string_of_int,idx_nd);
                return caml_call2(sprintf(_ht_),row_prefix,idx_s)}
              return _hw_},
            row_indices),
         col_header=
          map$0
           (function(i)
             {return 0 <= i?caml_call2(sprintf(_hx_),col_prefix,i):_hy_},
            col_indices);
        if(0 === header)
         var table=tbody;
        else
         {var
           a=append$0([0,col_header],tbody),
           row_header$0=append$0([0,_hA_],row_header),
           f=
            function(i,row)
             {return append$0([0,caml_check_bound(row_header$0,i)[i + 1]],row)},
           l=a.length - 1;
          if(0 === l)
           var _Ku_=[0];
          else
           {var r=caml_make_vect(l,f(0,a[1])),_Ki_=l - 1 | 0,_Kh_=1;
            if(!(_Ki_ < 1))
             {var i=_Kh_;
              for(;;)
               {r[i + 1] = f(i,a[i + 1]);
                var _Kj_=i + 1 | 0;
                if(_Ki_ !== i){var i=_Kj_;continue}
                break}}
            var _Ku_=r}
          var table=_Ku_}
        var
         row_num$0=table.length - 1,
         col_num$1=caml_check_bound(table,0)[1].length - 1,
         col_width=
          init
           (col_num$1,
            function(i)
             {var col_width=[0,0],_Ky_=table.length - 1 - 1 | 0,_Kx_=0;
              if(!(_Ky_ < 0))
               {var row_idx=_Kx_;
                for(;;)
                 {var
                   w=
                    caml_ml_string_length
                     (caml_check_bound
                        (caml_check_bound(table,row_idx)[row_idx + 1],i)
                       [i + 1]);
                  col_width[1] = max(col_width[1],w);
                  var _Kz_=row_idx + 1 | 0;
                  if(_Ky_ !== row_idx){var row_idx=_Kz_;continue}
                  break}}
              return col_width[1]}),
         out_s=[0,_hB_],
         _Ko_=row_num$0 - 1 | 0,
         _Kn_=0;
        if(!(_Ko_ < 0))
         {var i$0=_Kn_;
          for(;;)
           {var _Kq_=col_num$1 - 1 | 0,_Kp_=0;
            if(!(_Kq_ < 0))
             {var j=_Kp_;
              for(;;)
               {var
                 n=caml_check_bound(col_width,j)[j + 1],
                 s$0=
                  caml_check_bound(caml_check_bound(table,i$0)[i$0 + 1],j)
                   [j + 1],
                 w=max(0,n - caml_ml_string_length(s$0) | 0),
                 new_s=_d_(make$0(w,32),s$0),
                 _Ks_=_d_(new_s,_hD_);
                out_s[1] = _d_(out_s[1],_Ks_);
                var _Kt_=j + 1 | 0;
                if(_Kq_ !== j){var j=_Kt_;continue}
                break}}
            out_s[1] = _d_(out_s[1],_hC_);
            var _Kr_=i$0 + 1 | 0;
            if(_Ko_ !== i$0){var i$0=_Kr_;continue}
            break}}
        var out_s$0=out_s[1]}
      open_box(0);
      caml_call2(fprintf$0(formatter),_hE_,out_s$0);
      return close_box(0)}
    function tile(varr,reps)
     {var
       dims=shape(varr),
       result_rank=max(dims.length - 1,reps.length - 1),
       dims$0=prepend_dims(dims,result_rank),
       reps$0=prepend_dims(reps,result_rank),
       varr$0=caml_ba_reshape(varr,dims$0),
       result_dims=map2(function(a,b){return caml_mul(a,b)},dims$0,reps$0),
       result_varr=caml_ba_create(caml_ba_kind(varr$0),0,result_dims),
       result_ind=caml_make_vect(result_rank,0),
       original_ind=caml_make_vect(result_rank,0),
       should_stop=[0,0];
      for(;;)
       {if(should_stop[1])return result_varr;
        var _Ka_=result_rank - 1 | 0,_J$_=0;
        if(!(_Ka_ < 0))
         {var i=_J$_;
          for(;;)
           {var
             _Kb_=caml_check_bound(dims$0,i)[i + 1],
             _Kc_=caml_mod(caml_check_bound(result_ind,i)[i + 1],_Kb_);
            caml_check_bound(original_ind,i)[i + 1] = _Kc_;
            var _Kd_=i + 1 | 0;
            if(_Ka_ !== i){var i=_Kd_;continue}
            break}}
        caml_ba_set_generic
         (result_varr,result_ind,caml_ba_get_generic(varr$0,original_ind));
        if(1 - next_index(result_ind,result_dims))
         {should_stop[1] = 1;continue}
        continue}}
    function split(opt,parts,varr)
     {if(opt)var sth=opt[1],axis=sth;else var axis=0;
      var
       dims=shape(varr),
       rank=dims.length - 1,
       pos=[0,0],
       axis_indices=
        map$0
         (function(d)
           {pos[1] = pos[1] + d | 0;
            return [0,pos[1] - d | 0,[0,pos[1] - 1 | 0,0]]},
          parts),
       slices_defs=
        map$0
         (function(ind)
           {return to_list(init(rank,function(i){return i === axis?ind:0}))},
          axis_indices);
      return map$0(function(def){return get_slice(def,varr)},slices_defs)}
    function draw(opt,varr,count)
     {if(opt)var sth=opt[1],axis=sth;else var axis=0;
      var
       dims=shape(varr),
       len=dims.length - 1,
       range=caml_check_bound(dims,axis)[axis + 1];
      if(range < count)throw [0,Invalid_argument,_hH_];
      var pop_cnt=[0,range];
      function _J6_(i){return i}
      var pop=init(pop_cnt[1],_J6_),s=make_self_init(0);
      function draw_fun(param)
       {var _J8_=pop_cnt[1];
        if(1073741823 < _J8_)
         var switch$0=0;
        else
         if(0 < _J8_)
          for(;;)
           {var r=bits(s),v=caml_mod(r,_J8_);
            if(((1073741823 - _J8_ | 0) + 1 | 0) < (r - v | 0))continue;
            var index=v,switch$0=1;
            break}
         else
          var switch$0=0;
        if(!switch$0)var index=invalid_arg(_bL_);
        var sample=caml_check_bound(pop,index)[index + 1];
        pop_cnt[1] = pop_cnt[1] - 1 | 0;
        var _J9_=pop_cnt[1],_J__=caml_check_bound(pop,_J9_)[_J9_ + 1];
        caml_check_bound(pop,index)[index + 1] = _J__;
        return sample}
      var indices=init(count,draw_fun);
      function f(i){return i === axis?to_list(indices):0}
      if(0 <= len)
       if(1e4 < len)
        {var acc=0,i=0;
         for(;;)
          {if(!(len <= i))
            {var i$0=i + 1 | 0,acc$0=[0,f(i),acc],acc=acc$0,i=i$0;continue}
           var _J7_=rev(acc);
           break}}
       else
        var _J7_=init_aux(0,len,f);
      else
       var _J7_=invalid_arg(_l_);
      return [0,get_slice(_J7_,varr),indices]}
    function concatenate(opt,varrs)
     {if(opt)var sth=opt[1],axis=sth;else var axis=0;
      var
       varrs_num=varrs.length - 1,
       all_dims=map$0(shape,varrs),
       prefix_dims=sub$1(caml_check_bound(all_dims,0)[1],0,axis),
       _JS_=0,
       sum_axis_dims=
        fold_left$0
         (function(x,a){return x + caml_check_bound(a,axis)[axis + 1] | 0},
          _JS_,
          all_dims),
       _JT_=(caml_check_bound(all_dims,0)[1].length - 1 - axis | 0) - 1 | 0,
       suffix_dims=sub$1(caml_check_bound(all_dims,0)[1],axis + 1 | 0,_JT_),
       result_dims=
        caml_array_concat
         ([0,prefix_dims,[0,[0,sum_axis_dims],[0,suffix_dims,0]]]),
       result_varr=
        caml_ba_create
         (caml_ba_kind(caml_check_bound(varrs,0)[1]),0,result_dims),
       _JU_=1,
       prefix_dims_product=
        fold_left$0
         (function(_J5_,_J4_){return caml_mul(_J5_,_J4_)},_JU_,prefix_dims),
       _JV_=1,
       suffix_dims_product=
        fold_left$0
         (function(_J3_,_J2_){return caml_mul(_J3_,_J2_)},_JV_,suffix_dims);
      function reshaper_fun(varr)
       {var
         old_shape=shape(varr),
         new_shape=
          [0,
           prefix_dims_product,
           caml_mul
            (caml_check_bound(old_shape,axis)[axis + 1],suffix_dims_product)];
        return caml_ba_reshape(varr,new_shape)}
      var
       reshaped_result=reshaper_fun(result_varr),
       reshaped_varrs=map$0(reshaper_fun,varrs),
       _JX_=prefix_dims_product - 1 | 0,
       _JW_=0;
      if(!(_JX_ < 0))
       {var i=_JW_;
        for(;;)
         {var
           start_index=[0,0],
           result_slice=caml_ba_slice(reshaped_result,[0,i]),
           _JZ_=varrs_num - 1 | 0,
           _JY_=0;
          if(!(_JZ_ < 0))
           {var j=_JY_;
            for(;;)
             {var
               src_slice=
                caml_ba_slice(caml_check_bound(reshaped_varrs,j)[j + 1],[0,i]),
               block_len=
                caml_mul
                 (caml_check_bound(caml_check_bound(all_dims,j)[j + 1],axis)
                   [axis + 1],
                  suffix_dims_product),
               result_sub=caml_ba_sub(result_slice,start_index[1],block_len);
              caml_ba_blit(src_slice,result_sub);
              start_index[1] = start_index[1] + block_len | 0;
              var _J1_=j + 1 | 0;
              if(_JZ_ !== j){var j=_J1_;continue}
              break}}
          var _J0_=i + 1 | 0;
          if(_JX_ !== i){var i=_J0_;continue}
          break}}
      return result_varr}
    function repeat(opt,varr,reps)
     {if(opt)var sth=opt[1],axis=sth;else var axis=0;
      var varrs=caml_make_vect(reps,varr);
      return concatenate([0,axis],varrs)}
    function abs$1(varr){return map$2(abs$0,varr)}
    function neg$0(varr){return map$2(neg,varr)}
    function floor$0(varr){return map$2(floor,varr)}
    function ceil$0(varr){return map$2(ceil,varr)}
    function round$0(varr){return map$2(round,varr)}
    function sqr$0(varr){return map$2(sqr,varr)}
    function sqrt$0(varr){return map$2(sqrt,varr)}
    function log$0(varr){return map$2(log,varr)}
    function log2$0(varr){return map$2(log2,varr)}
    function log10$0(varr){return map$2(log10,varr)}
    function exp$0(varr){return map$2(exp,varr)}
    function sin$0(varr){return map$2(sin,varr)}
    function cos$0(varr){return map$2(cos,varr)}
    function tan$0(varr){return map$2(tan,varr)}
    function sinh$0(varr){return map$2(sinh,varr)}
    function cosh$0(varr){return map$2(cosh,varr)}
    function tanh$0(varr){return map$2(tanh,varr)}
    function asin$0(varr){return map$2(asin,varr)}
    function acos$0(varr){return map$2(acos,varr)}
    function atan$0(varr){return map$2(atan,varr)}
    function asinh$0(varr){return map$2(asinh,varr)}
    function acosh$0(varr){return map$2(acosh,varr)}
    function atanh$0(varr){return map$2(atanh,varr)}
    function sum(opt,varr)
     {if(opt)var sth=opt[1],axis=sth;else var axis=0;
      var old_dims=shape(varr),old_rank=old_dims.length - 1;
      if(0 === old_rank)return varr;
      var
       old_ind=caml_make_vect(old_rank,0),
       new_rank=old_rank - 1 | 0,
       new_dims=
        init
         (new_rank,
          function(i)
           {if(i < axis)return caml_check_bound(old_dims,i)[i + 1];
            var _JR_=i + 1 | 0;
            return caml_check_bound(old_dims,_JR_)[_JR_ + 1]}),
       new_varr=caml_ba_create(caml_ba_kind(varr),0,new_dims),
       new_ind=caml_make_vect(new_rank,0),
       should_stop=[0,0],
       sum=[0,0];
      for(;;)
       {if(should_stop[1])return new_varr;
        var _JK_=new_rank - 1 | 0,_JJ_=0;
        if(!(_JK_ < 0))
         {var i$0=_JJ_;
          for(;;)
           {var
             _JP_=caml_check_bound(new_ind,i$0)[i$0 + 1],
             i$1=i$0 < axis?i$0:i$0 + 1 | 0;
            caml_check_bound(old_ind,i$1)[i$1 + 1] = _JP_;
            var _JQ_=i$0 + 1 | 0;
            if(_JK_ !== i$0){var i$0=_JQ_;continue}
            break}}
        sum[1] = 0;
        var _JM_=caml_check_bound(old_dims,axis)[axis + 1] - 1 | 0,_JL_=0;
        if(!(_JM_ < 0))
         {var i=_JL_;
          for(;;)
           {caml_check_bound(old_ind,axis)[axis + 1] = i;
            var _JN_=caml_ba_get_generic(varr,old_ind);
            sum[1] = sum[1] + _JN_;
            var _JO_=i + 1 | 0;
            if(_JM_ !== i){var i=_JO_;continue}
            break}}
        caml_ba_set_generic(new_varr,new_ind,sum[1]);
        if(1 - next_index(new_ind,new_dims)){should_stop[1] = 1;continue}
        continue}}
    function sum_slices(opt,varr)
     {if(opt)var sth=opt[1],axis=sth;else var axis=0;
      var
       dims=shape(varr),
       rank=dims.length - 1,
       _Jy_=sub$1(dims,0,axis + 1 | 0),
       _Jz_=1,
       num_rows=
        fold_left$0(function(_JI_,_JH_){return caml_mul(_JI_,_JH_)},_Jz_,_Jy_),
       num_cols=caml_div(numel(varr),num_rows),
       varr_mat=caml_ba_reshape(varr,[0,num_rows,num_cols]),
       result_vec=caml_ba_create(caml_ba_kind(varr),0,[0,num_cols]),
       result_varr=
        caml_ba_reshape
         (result_vec,sub$1(dims,axis + 1 | 0,(rank - axis | 0) - 1 | 0)),
       row_sum=[0,0],
       _JB_=num_cols - 1 | 0,
       _JA_=0;
      if(!(_JB_ < 0))
       {var j=_JA_;
        for(;;)
         {row_sum[1] = 0;
          var _JD_=num_rows - 1 | 0,_JC_=0;
          if(!(_JD_ < 0))
           {var i=_JC_;
            for(;;)
             {var _JF_=caml_ba_get_generic(varr_mat,[0,i,j]);
              row_sum[1] = row_sum[1] + _JF_;
              var _JG_=i + 1 | 0;
              if(_JD_ !== i){var i=_JG_;continue}
              break}}
          caml_ba_set_generic(result_vec,[0,j],row_sum[1]);
          var _JE_=j + 1 | 0;
          if(_JB_ !== j){var j=_JE_;continue}
          break}}
      return result_varr}
    function signum$0(varr){return map$2(signum,varr)}
    function sigmoid$0(varr){return map$2(sigmoid,varr)}
    function relu$0(varr){return map$2(relu,varr)}
    function fold_left$1(f,a,varr)
     {var
       aref=[0,a],
       varr_linear=array1_of_genarray(flatten(varr)),
       length=numel(varr),
       _Jv_=length - 1 | 0,
       _Ju_=0;
      if(!(_Jv_ < 0))
       {var i=_Ju_;
        for(;;)
         {var _Jw_=caml_ba_get_1(varr_linear,i);
          aref[1] = caml_call2(f,aref[1],_Jw_);
          var _Jx_=i + 1 | 0;
          if(_Jv_ !== i){var i=_Jx_;continue}
          break}}
      return aref[1]}
    function min$0(varr){return fold_left$1(min,max_float,varr)}
    function max$0(varr){return fold_left$1(max,min_float,varr)}
    function sum$0(varr)
     {var _Jr_=0;
      return fold_left$1(function(_Jt_,_Js_){return _Jt_ + _Js_},_Jr_,varr)}
    function l1norm(varr)
     {function l1norm_fun(aggregate,elem){return aggregate + Math.abs(elem)}
      return fold_left$1(l1norm_fun,0,varr)}
    function l2norm_sqr(varr)
     {function l2norm_sqr_fun(aggregate,elem){return aggregate + elem * elem}
      return fold_left$1(l2norm_sqr_fun,0,varr)}
    function l2norm(varr)
     {var l2norm_sqr_val=l2norm_sqr(varr);return Math.sqrt(l2norm_sqr_val)}
    function scalar_pow(a,varr)
     {function scalar_pow_fun(x){return Math.pow(a,x)}
      return map$2(scalar_pow_fun,varr)}
    function pow_scalar(varr,a)
     {function pow_scalar_fun(x){return Math.pow(x,a)}
      return map$2(pow_scalar_fun,varr)}
    function scalar_atan2(a,varr)
     {function scalar_atan2_fun(x){return Math.atan2(a,x)}
      return map$2(scalar_atan2_fun,varr)}
    function atan2_scalar(varr,a)
     {function atan2_scalar_fun(x){return Math.atan2(x,a)}
      return map$2(atan2_scalar_fun,varr)}
    function broadcasted_op(varr_a,varr_b,op_fun)
     {var
       dims_b$0=shape(varr_b),
       dims_a$0=shape(varr_a),
       len_c=max(dims_a$0.length - 1,dims_b$0.length - 1),
       dims_a=prepend_dims(dims_a$0,len_c),
       dims_b=prepend_dims(dims_b$0,len_c),
       dims_c=caml_make_vect(len_c,0),
       _Jn_=len_c - 1 | 0,
       _Jm_=0;
      if(!(_Jn_ < 0))
       {var i=_Jm_;
        for(;;)
         {var
           val_a=caml_check_bound(dims_a,i)[i + 1],
           val_b=caml_check_bound(dims_b,i)[i + 1];
          if(val_a === val_b)
           caml_check_bound(dims_c,i)[i + 1] = val_a;
          else
           {if(1 !== val_a)if(1 !== val_b)throw [0,Invalid_argument,_hF_];
            var _Jp_=max(val_a,val_b);
            caml_check_bound(dims_c,i)[i + 1] = _Jp_}
          var _Jo_=i + 1 | 0;
          if(_Jn_ !== i){var i=_Jo_;continue}
          break}}
      var
       kind=caml_ba_kind(varr_a),
       varr_a$0=caml_ba_reshape(varr_a,dims_a),
       varr_b$0=caml_ba_reshape(varr_b,dims_b),
       varr_c=caml_ba_create(kind,0,dims_c),
       ind=caml_make_vect(dims_c.length - 1,0),
       should_stop=[0,0];
      for(;;)
       {if(should_stop[1])return varr_c;
        var
         ind_a=get_broadcasted_index(ind,dims_a),
         ind_b=get_broadcasted_index(ind,dims_b),
         _Jq_=caml_ba_get_generic(varr_b$0,ind_b);
        caml_ba_set_generic
         (varr_c,
          ind,
          caml_call2(op_fun,caml_ba_get_generic(varr_a$0,ind_a),_Jq_));
        if(1 - next_index(ind,dims_c))should_stop[1] = 1;
        continue}}
    function add$2(varr_a,varr_b)
     {var op=add_elt(caml_ba_kind(varr_a));
      return broadcasted_op(varr_a,varr_b,op)}
    function sub$4(varr_a,varr_b)
     {var op=sub_elt(caml_ba_kind(varr_a));
      return broadcasted_op(varr_a,varr_b,op)}
    function mul$1(varr_a,varr_b)
     {var op=mul_elt(caml_ba_kind(varr_a));
      return broadcasted_op(varr_a,varr_b,op)}
    function div$1(varr_a,varr_b)
     {var op=div_elt(caml_ba_kind(varr_a));
      return broadcasted_op(varr_a,varr_b,op)}
    function atan2$0(varr_a,varr_b)
     {return broadcasted_op(varr_a,varr_b,atan2)}
    function pow$0(varr_a,varr_b)
     {return broadcasted_op
              (varr_a,varr_b,function(_Jl_,_Jk_){return Math.pow(_Jl_,_Jk_)})}
    function add_scalar(varr,a)
     {var op=add_elt(caml_ba_kind(varr));
      function add_scalar_fun(x){return caml_call2(op,x,a)}
      return map$2(add_scalar_fun,varr)}
    function sub_scalar(varr,a)
     {var op=sub_elt(caml_ba_kind(varr));
      function sub_scalar_fun(x){return caml_call2(op,x,a)}
      return map$2(sub_scalar_fun,varr)}
    function mul_scalar(varr,a)
     {var op=mul_elt(caml_ba_kind(varr));
      function mul_scalar_fun(x){return caml_call2(op,x,a)}
      return map$2(mul_scalar_fun,varr)}
    function div_scalar(varr,a)
     {var op=div_elt(caml_ba_kind(varr));
      function div_scalar_fun(x){return caml_call2(op,x,a)}
      return map$2(div_scalar_fun,varr)}
    function clip_by_value(opt,_Jj_,varr)
     {if(opt)var sth=opt[1],amin=sth;else var amin=min_float;
      if(_Jj_)var sth$0=_Jj_[1],amax=sth$0;else var amax=max_float;
      function clip_by_val_fun(x){return min(amax,max(amin,x))}
      return map$2(clip_by_val_fun,varr)}
    function scalar_add(a,varr){return add_scalar(varr,a)}
    function scalar_sub(a,varr)
     {var op=sub_elt(caml_ba_kind(varr));
      function scalar_sub_fun(x){return caml_call2(op,a,x)}
      return map$2(scalar_sub_fun,varr)}
    function scalar_mul(a,varr){return mul_scalar(varr,a)}
    function scalar_div(a,varr)
     {var op=div_elt(caml_ba_kind(varr));
      function scalar_div_fun(x){return caml_call2(op,a,x)}
      return map$2(scalar_div_fun,varr)}
    function clip_by_l2norm(clip_norm,varr)
     {var l2norm_val=l2norm(varr);
      return clip_norm < l2norm_val
              ?mul_scalar(varr,clip_norm / l2norm_val)
              :varr}
    function compare_util_shortcircuit(varr_a,varr_b,comp_fun)
     {var n=numel(varr_a),m=numel(varr_b);
      if(n !== m)return 0;
      var
       varr_a$0=array1_of_genarray(flatten(varr_a)),
       varr_b$0=array1_of_genarray(flatten(varr_b)),
       all_ok=[0,1],
       i=[0,0];
      for(;;)
       {if(all_ok[1])
         if(i[1] < n)
          {var x=caml_ba_get_1(varr_a$0,i[1]),y=caml_ba_get_1(varr_b$0,i[1]);
           if(1 - caml_call2(comp_fun,x,y))all_ok[1] = 0;
           i[1] = i[1] + 1 | 0;
           continue}
        return all_ok[1]}}
    function approx_equal(eps$0,varr_a,varr_b)
     {if(eps$0)var eps$1=eps$0[1],eps$2=eps$1;else var eps$2=eps(0);
      function approx_equal_fun(x,y){return Math.abs(x - y) < eps$2?1:0}
      return compare_util_shortcircuit(varr_a,varr_b,approx_equal_fun)}
    function equal(varr_a,varr_b)
     {return compare_util_shortcircuit(varr_a,varr_b,caml_equal)}
    function not_equal(varr_a,varr_b)
     {return compare_util_shortcircuit(varr_a,varr_b,caml_notequal)}
    function less(varr_a,varr_b)
     {return compare_util_shortcircuit(varr_a,varr_b,caml_lessthan)}
    function greater(varr_a,varr_b)
     {return compare_util_shortcircuit(varr_a,varr_b,caml_greaterthan)}
    function less_equal(varr_a,varr_b)
     {return compare_util_shortcircuit(varr_a,varr_b,caml_lessequal)}
    function greater_equal(varr_a,varr_b)
     {return compare_util_shortcircuit(varr_a,varr_b,caml_greaterequal)}
    function approx_equal_scalar(eps$0,varr_a$0,y)
     {if(eps$0)var eps$1=eps$0[1],eps$2=eps$1;else var eps$2=eps(0);
      var
       n=numel(varr_a$0),
       varr_a=array1_of_genarray(flatten(varr_a$0)),
       all_ok=[0,1],
       i=[0,0];
      for(;;)
       {if(all_ok[1])
         if(i[1] < n)
          {var x=caml_ba_get_1(varr_a,i[1]);
           if(1 - (Math.abs(x - y) < eps$2?1:0))all_ok[1] = 0;
           i[1] = i[1] + 1 | 0;
           continue}
        return all_ok[1]}}
    function elt_compare_util(varr_a,varr_b,one_fun)
     {var kind=caml_ba_kind(varr_a),c0=zero$0(kind),c1=one$0(kind);
      function comp_fun(x,y){return caml_call2(one_fun,x,y)?c1:c0}
      return broadcasted_op(varr_a,varr_b,comp_fun)}
    function elt_equal(varr_a,varr_b)
     {return elt_compare_util(varr_a,varr_b,caml_equal)}
    function approx_elt_equal(eps$0,varr_a,varr_b)
     {if(eps$0)var eps$1=eps$0[1],eps$2=eps$1;else var eps$2=eps(0);
      function approx_equal_fun(x,y){return Math.abs(x - y) < eps$2?1:0}
      return elt_compare_util(varr_a,varr_b,approx_equal_fun)}
    function elt_not_equal(varr_a,varr_b)
     {return elt_compare_util(varr_a,varr_b,caml_notequal)}
    function elt_less(varr_a,varr_b)
     {return elt_compare_util(varr_a,varr_b,caml_lessthan)}
    function elt_greater(varr_a,varr_b)
     {return elt_compare_util(varr_a,varr_b,caml_greaterthan)}
    function elt_less_equal(varr_a,varr_b)
     {return elt_compare_util(varr_a,varr_b,caml_lessequal)}
    function elt_greater_equal(varr_a,varr_b)
     {return elt_compare_util(varr_a,varr_b,caml_greaterequal)}
    function elt_compare_scalar_util(varr_a,one_fun)
     {var kind=caml_ba_kind(varr_a),c0=zero$0(kind),c1=one$0(kind);
      function comp_fun(x){return caml_call1(one_fun,x)?c1:c0}
      return map$2(comp_fun,varr_a)}
    function elt_equal_scalar(varr_a,b)
     {function equal_scalar_fun(x){return caml_equal(x,b)}
      return elt_compare_scalar_util(varr_a,equal_scalar_fun)}
    function approx_elt_equal_scalar(eps$0,varr_a,b)
     {if(eps$0)var eps$1=eps$0[1],eps$2=eps$1;else var eps$2=eps(0);
      function approx_equal_scalar_fun(x){return Math.abs(x - b) < eps$2?1:0}
      return elt_compare_scalar_util(varr_a,approx_equal_scalar_fun)}
    function elt_not_equal_scalar(varr_a,b)
     {function not_equal_scalar_fun(x){return caml_notequal(x,b)}
      return elt_compare_scalar_util(varr_a,not_equal_scalar_fun)}
    function elt_less_scalar(varr_a,b)
     {function less_scalar_fun(x){return caml_lessthan(x,b)}
      return elt_compare_scalar_util(varr_a,less_scalar_fun)}
    function elt_greater_scalar(varr_a,b)
     {function greater_scalar_fun(x){return caml_greaterthan(x,b)}
      return elt_compare_scalar_util(varr_a,greater_scalar_fun)}
    function elt_less_equal_scalar(varr_a,b)
     {function less_equal_scalar_fun(x){return caml_lessequal(x,b)}
      return elt_compare_scalar_util(varr_a,less_equal_scalar_fun)}
    function elt_greater_equal_scalar(varr_a,b)
     {function greater_equal_scalar_fun(x){return caml_greaterthan(x,b)}
      return elt_compare_scalar_util(varr_a,greater_equal_scalar_fun)}
    function not_exists(f,varr$0)
     {var
       n=numel(varr$0),
       varr=array1_of_genarray(flatten(varr$0)),
       found=[0,0],
       i=[0,0];
      for(;;)
       {if(i[1] < n)
         if(!found[1])
          {var x=caml_ba_get_1(varr,i[1]);
           if(caml_call1(f,x))found[1] = 1;
           i[1] = i[1] + 1 | 0;
           continue}
        return 1 - found[1]}}
    function is_zero(varr)
     {var k=caml_ba_kind(varr),c0=zero$0(k);
      function non_zero_fun(x){return caml_notequal(x,c0)}
      return not_exists(non_zero_fun,varr)}
    function is_positive(varr)
     {var k=caml_ba_kind(varr),c0=zero$0(k);
      function non_positive_fun(x){return caml_lessequal(x,c0)}
      return not_exists(non_positive_fun,varr)}
    function is_negative(varr)
     {var k=caml_ba_kind(varr),c0=zero$0(k);
      function non_negative_fun(x){return caml_greaterequal(x,c0)}
      return not_exists(non_negative_fun,varr)}
    function is_nonpositive(varr)
     {var k=caml_ba_kind(varr),c0=zero$0(k);
      function positive_fun(x){return caml_greaterthan(x,c0)}
      return not_exists(positive_fun,varr)}
    function is_nonnegative(varr)
     {var k=caml_ba_kind(varr),c0=zero$0(k);
      function negative_fun(x){return caml_lessthan(x,c0)}
      return not_exists(negative_fun,varr)}
    function conv2d(opt,input,kernel,stride)
     {if(opt)var sth=opt[1],padding=sth;else var padding=0;
      if(4 === num_dims(input))
       {if(4 === num_dims(kernel))
         {if(2 === stride.length - 1)
           {var
             input_shp=shape(input),
             batches=caml_check_bound(input_shp,0)[1],
             input_cols=caml_check_bound(input_shp,1)[2],
             input_rows=caml_check_bound(input_shp,2)[3],
             in_channel=caml_check_bound(input_shp,3)[4],
             kernel_shp=shape(kernel),
             kernel_cols=caml_check_bound(kernel_shp,0)[1],
             kernel_rows=caml_check_bound(kernel_shp,1)[2],
             out_channel=caml_check_bound(kernel_shp,3)[4];
            if(in_channel === caml_check_bound(kernel_shp,2)[3])
             {var
               col_stride=caml_check_bound(stride,0)[1],
               row_stride=caml_check_bound(stride,1)[2],
               match=
                calc_conv2d_output_shape
                 (padding,
                  input_cols,
                  input_rows,
                  kernel_cols,
                  kernel_rows,
                  row_stride,
                  col_stride),
               output_rows=match[2],
               output_cols=match[1],
               kind=caml_ba_kind(input),
               output=
                caml_ba_create
                 (kind,0,[0,batches,output_cols,output_rows,out_channel]),
               match$0=
                calc_conv2d_padding
                 (input_cols,
                  input_rows,
                  kernel_cols,
                  kernel_rows,
                  output_cols,
                  output_rows,
                  row_stride,
                  col_stride),
               pad_left=match$0[2],
               pad_top=match$0[1],
               sum=[0,0],
               _I0_=batches - 1 | 0,
               _IZ_=0;
              if(!(_I0_ < 0))
               {var b=_IZ_;
                for(;;)
                 {var _I2_=output_cols - 1 | 0,_I1_=0;
                  if(!(_I2_ < 0))
                   {var i=_I1_;
                    for(;;)
                     {var _I5_=output_rows - 1 | 0,_I4_=0;
                      if(!(_I5_ < 0))
                       {var j=_I4_;
                        for(;;)
                         {var _I8_=out_channel - 1 | 0,_I7_=0;
                          if(!(_I8_ < 0))
                           {var k=_I7_;
                            for(;;)
                             {sum[1] = 0;
                              var _I$_=kernel_cols - 1 | 0,_I__=0;
                              if(!(_I$_ < 0))
                               {var di=_I__;
                                for(;;)
                                 {var _Jc_=kernel_rows - 1 | 0,_Jb_=0;
                                  if(!(_Jc_ < 0))
                                   {var dj=_Jb_;
                                    for(;;)
                                     {var _Jf_=in_channel - 1 | 0,_Je_=0;
                                      if(!(_Jf_ < 0))
                                       {var q=_Je_;
                                        for(;;)
                                         {var
                                           in_col=(caml_mul(i,col_stride) + di | 0) - pad_left | 0,
                                           in_row=(caml_mul(j,row_stride) + dj | 0) - pad_top | 0;
                                          if(0 <= in_col)
                                           if(in_col < input_cols)
                                            if(0 <= in_row)
                                             if(in_row < input_rows)
                                              var
                                               in_val=caml_ba_get_generic(input,[0,b,in_col,in_row,q]),
                                               switch$0=1;
                                             else
                                              var switch$0=0;
                                            else
                                             var switch$0=0;
                                           else
                                            var switch$0=0;
                                          else
                                           var switch$0=0;
                                          if(!switch$0)var in_val=0;
                                          var _Jh_=in_val * caml_ba_get_generic(kernel,[0,di,dj,q,k]);
                                          sum[1] = sum[1] + _Jh_;
                                          var _Ji_=q + 1 | 0;
                                          if(_Jf_ !== q){var q=_Ji_;continue}
                                          break}}
                                      var _Jg_=dj + 1 | 0;
                                      if(_Jc_ !== dj){var dj=_Jg_;continue}
                                      break}}
                                  var _Jd_=di + 1 | 0;
                                  if(_I$_ !== di){var di=_Jd_;continue}
                                  break}}
                              caml_ba_set_generic(output,[0,b,i,j,k],sum[1]);
                              var _Ja_=k + 1 | 0;
                              if(_I8_ !== k){var k=_Ja_;continue}
                              break}}
                          var _I9_=j + 1 | 0;
                          if(_I5_ !== j){var j=_I9_;continue}
                          break}}
                      var _I6_=i + 1 | 0;
                      if(_I2_ !== i){var i=_I6_;continue}
                      break}}
                  var _I3_=b + 1 | 0;
                  if(_I0_ !== b){var b=_I3_;continue}
                  break}}
              return output}
            throw [0,Assert_failure,_hM_]}
          throw [0,Assert_failure,_hN_]}
        throw [0,Assert_failure,_hO_]}
      throw [0,Assert_failure,_hP_]}
    function conv1d(opt,input,kernel,stride)
     {if(opt)var sth=opt[1],padding=sth;else var padding=0;
      if(3 === num_dims(input))
       {if(3 === num_dims(kernel))
         {if(1 === stride.length - 1)
           {var
             input_shp=shape(input),
             batches=caml_check_bound(input_shp,0)[1],
             input_cols=caml_check_bound(input_shp,1)[2],
             in_channel=caml_check_bound(input_shp,2)[3],
             input$0=
              caml_ba_reshape(input,[0,batches,1,input_cols,in_channel]),
             kernel_shp=shape(kernel),
             kernel_cols=caml_check_bound(kernel_shp,0)[1],
             out_channel=caml_check_bound(kernel_shp,2)[3];
            if(in_channel === caml_check_bound(kernel_shp,1)[2])
             {var
               kernel$0=
                caml_ba_reshape
                 (kernel,[0,1,kernel_cols,in_channel,out_channel]),
               col_stride=caml_check_bound(stride,0)[1],
               stride$0=[0,1,col_stride],
               output=conv2d([0,padding],input$0,kernel$0,stride$0),
               output_shp=shape(output),
               output_cols=caml_check_bound(output_shp,2)[3],
               output$0=
                caml_ba_reshape(output,[0,batches,output_cols,out_channel]);
              return output$0}
            throw [0,Assert_failure,_hQ_]}
          throw [0,Assert_failure,_hR_]}
        throw [0,Assert_failure,_hS_]}
      throw [0,Assert_failure,_hT_]}
    function conv3d(opt,input,kernel,stride)
     {if(opt)var sth=opt[1],padding=sth;else var padding=0;
      if(5 === num_dims(input))
       {if(5 === num_dims(kernel))
         {if(3 === stride.length - 1)
           {var
             input_shp=shape(input),
             batches=caml_check_bound(input_shp,0)[1],
             input_cols=caml_check_bound(input_shp,1)[2],
             input_rows=caml_check_bound(input_shp,2)[3],
             input_dpts=caml_check_bound(input_shp,3)[4],
             in_channel=caml_check_bound(input_shp,4)[5],
             kernel_shp=shape(kernel),
             kernel_cols=caml_check_bound(kernel_shp,0)[1],
             kernel_rows=caml_check_bound(kernel_shp,1)[2],
             kernel_dpts=caml_check_bound(kernel_shp,2)[3],
             out_channel=caml_check_bound(kernel_shp,4)[5];
            if(in_channel === caml_check_bound(kernel_shp,3)[4])
             {var
               col_stride=caml_check_bound(stride,0)[1],
               row_stride=caml_check_bound(stride,1)[2],
               dpt_stride=caml_check_bound(stride,2)[3],
               match=
                calc_conv3d_output_shape
                 (padding,
                  input_cols,
                  input_rows,
                  input_dpts,
                  kernel_cols,
                  kernel_rows,
                  kernel_dpts,
                  row_stride,
                  col_stride,
                  dpt_stride),
               output_dpts=match[3],
               output_rows=match[2],
               output_cols=match[1],
               kind=caml_ba_kind(input),
               output=
                caml_ba_create
                 (kind,
                  0,
                  [0,batches,output_cols,output_rows,output_dpts,out_channel]),
               match$0=
                calc_conv3d_padding
                 (input_cols,
                  input_rows,
                  input_dpts,
                  kernel_cols,
                  kernel_rows,
                  kernel_dpts,
                  output_cols,
                  output_rows,
                  output_dpts,
                  row_stride,
                  col_stride,
                  dpt_stride),
               pad_shallow=match$0[3],
               pad_left=match$0[2],
               pad_top=match$0[1],
               sum=[0,0],
               _Iy_=batches - 1 | 0,
               _Ix_=0;
              if(!(_Iy_ < 0))
               {var b=_Ix_;
                for(;;)
                 {var _IA_=output_cols - 1 | 0,_Iz_=0;
                  if(!(_IA_ < 0))
                   {var i=_Iz_;
                    for(;;)
                     {var _ID_=output_rows - 1 | 0,_IC_=0;
                      if(!(_ID_ < 0))
                       {var j=_IC_;
                        for(;;)
                         {var _IG_=output_dpts - 1 | 0,_IF_=0;
                          if(!(_IG_ < 0))
                           {var dpt=_IF_;
                            for(;;)
                             {var _IJ_=out_channel - 1 | 0,_II_=0;
                              if(!(_IJ_ < 0))
                               {var k=_II_;
                                for(;;)
                                 {sum[1] = 0;
                                  var _IM_=kernel_cols - 1 | 0,_IL_=0;
                                  if(!(_IM_ < 0))
                                   {var di=_IL_;
                                    for(;;)
                                     {var _IP_=kernel_rows - 1 | 0,_IO_=0;
                                      if(!(_IP_ < 0))
                                       {var dj=_IO_;
                                        for(;;)
                                         {var _IS_=kernel_dpts - 1 | 0,_IR_=0;
                                          if(!(_IS_ < 0))
                                           {var d_dpt=_IR_;
                                            for(;;)
                                             {var _IV_=in_channel - 1 | 0,_IU_=0;
                                              if(!(_IV_ < 0))
                                               {var q=_IU_;
                                                for(;;)
                                                 {var
                                                   in_col=(caml_mul(i,col_stride) + di | 0) - pad_left | 0,
                                                   in_row=(caml_mul(j,row_stride) + dj | 0) - pad_top | 0,
                                                   in_dpt=
                                                    (caml_mul(dpt,dpt_stride) + d_dpt | 0)
                                                    -
                                                    pad_shallow
                                                    |
                                                    0;
                                                  if(0 <= in_col)
                                                   if(in_col < input_cols)
                                                    if(0 <= in_row)
                                                     if(in_row < input_rows)
                                                      if(0 <= in_dpt)
                                                       if(in_dpt < input_dpts)
                                                        var
                                                         in_val=
                                                          caml_ba_get_generic(input,[0,b,in_col,in_row,in_dpt,q]),
                                                         switch$0=1;
                                                       else
                                                        var switch$0=0;
                                                      else
                                                       var switch$0=0;
                                                     else
                                                      var switch$0=0;
                                                    else
                                                     var switch$0=0;
                                                   else
                                                    var switch$0=0;
                                                  else
                                                   var switch$0=0;
                                                  if(!switch$0)var in_val=0;
                                                  var
                                                   _IX_=
                                                    in_val * caml_ba_get_generic(kernel,[0,di,dj,d_dpt,q,k]);
                                                  sum[1] = sum[1] + _IX_;
                                                  var _IY_=q + 1 | 0;
                                                  if(_IV_ !== q){var q=_IY_;continue}
                                                  break}}
                                              var _IW_=d_dpt + 1 | 0;
                                              if(_IS_ !== d_dpt){var d_dpt=_IW_;continue}
                                              break}}
                                          var _IT_=dj + 1 | 0;
                                          if(_IP_ !== dj){var dj=_IT_;continue}
                                          break}}
                                      var _IQ_=di + 1 | 0;
                                      if(_IM_ !== di){var di=_IQ_;continue}
                                      break}}
                                  caml_ba_set_generic(output,[0,b,i,j,dpt,k],sum[1]);
                                  var _IN_=k + 1 | 0;
                                  if(_IJ_ !== k){var k=_IN_;continue}
                                  break}}
                              var _IK_=dpt + 1 | 0;
                              if(_IG_ !== dpt){var dpt=_IK_;continue}
                              break}}
                          var _IH_=j + 1 | 0;
                          if(_ID_ !== j){var j=_IH_;continue}
                          break}}
                      var _IE_=i + 1 | 0;
                      if(_IA_ !== i){var i=_IE_;continue}
                      break}}
                  var _IB_=b + 1 | 0;
                  if(_Iy_ !== b){var b=_IB_;continue}
                  break}}
              return output}
            throw [0,Assert_failure,_hU_]}
          throw [0,Assert_failure,_hV_]}
        throw [0,Assert_failure,_hW_]}
      throw [0,Assert_failure,_hX_]}
    function pool2d
     (opt,input,kernel,stride,init_pool_fun,add_val_pool_fun,end_pool_fun)
     {if(opt)var sth=opt[1],padding=sth;else var padding=0;
      if(4 === num_dims(input))
       {if(2 === kernel.length - 1)
         {if(2 === stride.length - 1)
           {var
             input_shp=shape(input),
             batches=caml_check_bound(input_shp,0)[1],
             input_cols=caml_check_bound(input_shp,1)[2],
             input_rows=caml_check_bound(input_shp,2)[3],
             in_channel=caml_check_bound(input_shp,3)[4],
             kernel_cols=caml_check_bound(kernel,0)[1],
             kernel_rows=caml_check_bound(kernel,1)[2],
             col_stride=caml_check_bound(stride,0)[1],
             row_stride=caml_check_bound(stride,1)[2],
             match=
              calc_conv2d_output_shape
               (padding,
                input_cols,
                input_rows,
                kernel_cols,
                kernel_rows,
                row_stride,
                col_stride),
             output_rows=match[2],
             output_cols=match[1],
             kind=caml_ba_kind(input),
             output=
              caml_ba_create
               (kind,0,[0,batches,output_cols,output_rows,in_channel]),
             match$0=
              calc_conv2d_padding
               (input_cols,
                input_rows,
                kernel_cols,
                kernel_rows,
                output_cols,
                output_rows,
                row_stride,
                col_stride),
             pad_left=match$0[2],
             pad_top=match$0[1],
             _Ic_=batches - 1 | 0,
             _Ib_=0;
            if(!(_Ic_ < 0))
             {var b=_Ib_;
              for(;;)
               {var _Ie_=output_cols - 1 | 0,_Id_=0;
                if(!(_Ie_ < 0))
                 {var i=_Id_;
                  for(;;)
                   {var _Ih_=output_rows - 1 | 0,_Ig_=0;
                    if(!(_Ih_ < 0))
                     {var j=_Ig_;
                      for(;;)
                       {var _Ik_=in_channel - 1 | 0,_Ij_=0;
                        if(!(_Ik_ < 0))
                         {var k=_Ij_;
                          for(;;)
                           {caml_call1(init_pool_fun,0);
                            var _In_=kernel_cols - 1 | 0,_Im_=0;
                            if(!(_In_ < 0))
                             {var di=_Im_;
                              for(;;)
                               {var _Iq_=kernel_rows - 1 | 0,_Ip_=0;
                                if(!(_Iq_ < 0))
                                 {var dj=_Ip_;
                                  for(;;)
                                   {var
                                     in_col=(caml_mul(i,col_stride) + di | 0) - pad_left | 0,
                                     in_row=(caml_mul(j,row_stride) + dj | 0) - pad_top | 0,
                                     _Is_=0 <= in_col?1:0;
                                    if(_Is_)
                                     {var _It_=in_col < input_cols?1:0;
                                      if(_It_)
                                       var
                                        _Iu_=0 <= in_row?1:0,
                                        _Iv_=_Iu_?in_row < input_rows?1:0:_Iu_;
                                      else
                                       var _Iv_=_It_}
                                    else
                                     var _Iv_=_Is_;
                                    if(_Iv_)
                                     caml_call1
                                      (add_val_pool_fun,
                                       caml_ba_get_generic(input,[0,b,in_col,in_row,k]));
                                    var _Iw_=dj + 1 | 0;
                                    if(_Iq_ !== dj){var dj=_Iw_;continue}
                                    break}}
                                var _Ir_=di + 1 | 0;
                                if(_In_ !== di){var di=_Ir_;continue}
                                break}}
                            caml_ba_set_generic
                             (output,[0,b,i,j,k],caml_call1(end_pool_fun,0));
                            var _Io_=k + 1 | 0;
                            if(_Ik_ !== k){var k=_Io_;continue}
                            break}}
                        var _Il_=j + 1 | 0;
                        if(_Ih_ !== j){var j=_Il_;continue}
                        break}}
                    var _Ii_=i + 1 | 0;
                    if(_Ie_ !== i){var i=_Ii_;continue}
                    break}}
                var _If_=b + 1 | 0;
                if(_Ic_ !== b){var b=_If_;continue}
                break}}
            return output}
          throw [0,Assert_failure,_hY_]}
        throw [0,Assert_failure,_hZ_]}
      throw [0,Assert_failure,_h0_]}
    function pool3d
     (opt,input,kernel,stride,init_pool_fun,add_val_pool_fun,end_pool_fun)
     {if(opt)var sth=opt[1],padding=sth;else var padding=0;
      if(5 === num_dims(input))
       {if(3 === kernel.length - 1)
         {if(3 === stride.length - 1)
           {var
             input_shp=shape(input),
             batches=caml_check_bound(input_shp,0)[1],
             input_cols=caml_check_bound(input_shp,1)[2],
             input_rows=caml_check_bound(input_shp,2)[3],
             input_dpts=caml_check_bound(input_shp,3)[4],
             in_channel=caml_check_bound(input_shp,4)[5],
             kernel_cols=caml_check_bound(kernel,0)[1],
             kernel_rows=caml_check_bound(kernel,1)[2],
             kernel_dpts=caml_check_bound(kernel,2)[3],
             col_stride=caml_check_bound(stride,0)[1],
             row_stride=caml_check_bound(stride,1)[2],
             dpt_stride=caml_check_bound(stride,2)[3],
             match=
              calc_conv3d_output_shape
               (padding,
                input_cols,
                input_rows,
                input_dpts,
                kernel_cols,
                kernel_rows,
                kernel_dpts,
                row_stride,
                col_stride,
                dpt_stride),
             output_dpts=match[3],
             output_rows=match[2],
             output_cols=match[1],
             kind=caml_ba_kind(input),
             output=
              caml_ba_create
               (kind,
                0,
                [0,batches,output_cols,output_rows,output_dpts,in_channel]),
             match$0=
              calc_conv3d_padding
               (input_cols,
                input_rows,
                input_dpts,
                kernel_cols,
                kernel_rows,
                kernel_dpts,
                output_cols,
                output_rows,
                output_dpts,
                row_stride,
                col_stride,
                dpt_stride),
             pad_shallow=match$0[3],
             pad_left=match$0[2],
             pad_top=match$0[1],
             _HK_=batches - 1 | 0,
             _HJ_=0;
            if(!(_HK_ < 0))
             {var b=_HJ_;
              for(;;)
               {var _HM_=output_cols - 1 | 0,_HL_=0;
                if(!(_HM_ < 0))
                 {var i=_HL_;
                  for(;;)
                   {var _HP_=output_rows - 1 | 0,_HO_=0;
                    if(!(_HP_ < 0))
                     {var j=_HO_;
                      for(;;)
                       {var _HS_=output_dpts - 1 | 0,_HR_=0;
                        if(!(_HS_ < 0))
                         {var dpt=_HR_;
                          for(;;)
                           {var _HV_=in_channel - 1 | 0,_HU_=0;
                            if(!(_HV_ < 0))
                             {var k=_HU_;
                              for(;;)
                               {caml_call1(init_pool_fun,0);
                                var _HY_=kernel_cols - 1 | 0,_HX_=0;
                                if(!(_HY_ < 0))
                                 {var di=_HX_;
                                  for(;;)
                                   {var _H1_=kernel_rows - 1 | 0,_H0_=0;
                                    if(!(_H1_ < 0))
                                     {var dj=_H0_;
                                      for(;;)
                                       {var _H4_=kernel_dpts - 1 | 0,_H3_=0;
                                        if(!(_H4_ < 0))
                                         {var d_dpt=_H3_;
                                          for(;;)
                                           {var
                                             in_col=(caml_mul(i,col_stride) + di | 0) - pad_left | 0,
                                             in_row=(caml_mul(j,row_stride) + dj | 0) - pad_top | 0,
                                             in_dpt=
                                              (caml_mul(dpt,dpt_stride) + d_dpt | 0)
                                              -
                                              pad_shallow
                                              |
                                              0,
                                             _H6_=0 <= in_col?1:0;
                                            if(_H6_)
                                             {var _H7_=in_col < input_cols?1:0;
                                              if(_H7_)
                                               {var _H8_=0 <= in_row?1:0;
                                                if(_H8_)
                                                 {var _H9_=in_row < input_rows?1:0;
                                                  if(_H9_)
                                                   var
                                                    _H__=0 <= in_dpt?1:0,
                                                    _H$_=_H__?in_dpt < input_dpts?1:0:_H__;
                                                  else
                                                   var _H$_=_H9_}
                                                else
                                                 var _H$_=_H8_}
                                              else
                                               var _H$_=_H7_}
                                            else
                                             var _H$_=_H6_;
                                            if(_H$_)
                                             caml_call1
                                              (add_val_pool_fun,
                                               caml_ba_get_generic(input,[0,b,in_col,in_row,in_dpt,k]));
                                            var _Ia_=d_dpt + 1 | 0;
                                            if(_H4_ !== d_dpt){var d_dpt=_Ia_;continue}
                                            break}}
                                        var _H5_=dj + 1 | 0;
                                        if(_H1_ !== dj){var dj=_H5_;continue}
                                        break}}
                                    var _H2_=di + 1 | 0;
                                    if(_HY_ !== di){var di=_H2_;continue}
                                    break}}
                                caml_ba_set_generic
                                 (output,[0,b,i,j,dpt,k],caml_call1(end_pool_fun,0));
                                var _HZ_=k + 1 | 0;
                                if(_HV_ !== k){var k=_HZ_;continue}
                                break}}
                            var _HW_=dpt + 1 | 0;
                            if(_HS_ !== dpt){var dpt=_HW_;continue}
                            break}}
                        var _HT_=j + 1 | 0;
                        if(_HP_ !== j){var j=_HT_;continue}
                        break}}
                    var _HQ_=i + 1 | 0;
                    if(_HM_ !== i){var i=_HQ_;continue}
                    break}}
                var _HN_=b + 1 | 0;
                if(_HK_ !== b){var b=_HN_;continue}
                break}}
            return output}
          throw [0,Assert_failure,_h1_]}
        throw [0,Assert_failure,_h2_]}
      throw [0,Assert_failure,_h3_]}
    function max_pool2d(opt,input,kernel,stride)
     {if(opt)var sth=opt[1],padding=sth;else var padding=0;
      var max_pool=[0,0];
      function init_pool_fun(param){max_pool[1] = min_float;return 0}
      function add_val_pool_fun(v){max_pool[1] = max(max_pool[1],v);return 0}
      function end_pool_fun(param){return max_pool[1]}
      return pool2d
              ([0,padding],
               input,
               kernel,
               stride,
               init_pool_fun,
               add_val_pool_fun,
               end_pool_fun)}
    function max_pool1d(opt,input,kernel,stride)
     {if(opt)var sth=opt[1],padding=sth;else var padding=0;
      if(3 === num_dims(input))
       {if(1 === kernel.length - 1)
         {if(1 === stride.length - 1)
           {var
             input_shp=shape(input),
             batches=caml_check_bound(input_shp,0)[1],
             input_cols=caml_check_bound(input_shp,1)[2],
             in_channel=caml_check_bound(input_shp,2)[3],
             input$0=
              caml_ba_reshape(input,[0,batches,1,input_cols,in_channel]),
             kernel_cols=caml_check_bound(kernel,0)[1],
             kernel$0=[0,1,kernel_cols],
             col_stride=caml_check_bound(stride,0)[1],
             stride$0=[0,1,col_stride],
             output=max_pool2d([0,padding],input$0,kernel$0,stride$0),
             output_shp=shape(output),
             output_cols=caml_check_bound(output_shp,2)[3],
             output$0=
              caml_ba_reshape(output,[0,batches,output_cols,in_channel]);
            return output$0}
          throw [0,Assert_failure,_h4_]}
        throw [0,Assert_failure,_h5_]}
      throw [0,Assert_failure,_h6_]}
    function max_pool3d(opt,input,kernel,stride)
     {if(opt)var sth=opt[1],padding=sth;else var padding=0;
      var max_pool=[0,0];
      function init_pool_fun(param){max_pool[1] = min_float;return 0}
      function add_val_pool_fun(v){max_pool[1] = max(max_pool[1],v);return 0}
      function end_pool_fun(param){return max_pool[1]}
      return pool3d
              ([0,padding],
               input,
               kernel,
               stride,
               init_pool_fun,
               add_val_pool_fun,
               end_pool_fun)}
    function avg_pool2d(opt,input,kernel,stride)
     {if(opt)var sth=opt[1],padding=sth;else var padding=0;
      var sum_pool=[0,0],cnt=[0,0];
      function init_pool_fun(param){sum_pool[1] = 0;cnt[1] = 0;return 0}
      function add_val_pool_fun(v)
       {sum_pool[1] = sum_pool[1] + v;cnt[1] = cnt[1] + 1;return 0}
      function end_pool_fun(param){return sum_pool[1] / cnt[1]}
      return pool2d
              ([0,padding],
               input,
               kernel,
               stride,
               init_pool_fun,
               add_val_pool_fun,
               end_pool_fun)}
    function avg_pool1d(opt,input,kernel,stride)
     {if(opt)var sth=opt[1],padding=sth;else var padding=0;
      if(3 === num_dims(input))
       {if(1 === kernel.length - 1)
         {if(1 === stride.length - 1)
           {var
             input_shp=shape(input),
             batches=caml_check_bound(input_shp,0)[1],
             input_cols=caml_check_bound(input_shp,1)[2],
             in_channel=caml_check_bound(input_shp,2)[3],
             input$0=
              caml_ba_reshape(input,[0,batches,1,input_cols,in_channel]),
             kernel_cols=caml_check_bound(kernel,0)[1],
             kernel$0=[0,1,kernel_cols],
             col_stride=caml_check_bound(stride,0)[1],
             stride$0=[0,1,col_stride],
             output=avg_pool2d([0,padding],input$0,kernel$0,stride$0),
             output_shp=shape(output),
             output_cols=caml_check_bound(output_shp,2)[3],
             output$0=
              caml_ba_reshape(output,[0,batches,output_cols,in_channel]);
            return output$0}
          throw [0,Assert_failure,_h7_]}
        throw [0,Assert_failure,_h8_]}
      throw [0,Assert_failure,_h9_]}
    function avg_pool3d(opt,input,kernel,stride)
     {if(opt)var sth=opt[1],padding=sth;else var padding=0;
      var sum_pool=[0,0],cnt=[0,0];
      function init_pool_fun(param){sum_pool[1] = 0;cnt[1] = 0;return 0}
      function add_val_pool_fun(v)
       {sum_pool[1] = sum_pool[1] + v;cnt[1] = cnt[1] + 1;return 0}
      function end_pool_fun(param){return sum_pool[1] / cnt[1]}
      return pool3d
              ([0,padding],
               input,
               kernel,
               stride,
               init_pool_fun,
               add_val_pool_fun,
               end_pool_fun)}
    function conv2d_backward_input(input,kernel,stride,output)
     {if(4 === num_dims(input))
       {if(4 === num_dims(kernel))
         {if(4 === num_dims(output))
           {if(2 === stride.length - 1)
             {var
               input_shp=shape(input),
               batches=caml_check_bound(input_shp,0)[1],
               input_cols=caml_check_bound(input_shp,1)[2],
               input_rows=caml_check_bound(input_shp,2)[3],
               in_channel=caml_check_bound(input_shp,3)[4],
               kernel_shp=shape(kernel),
               kernel_cols=caml_check_bound(kernel_shp,0)[1],
               kernel_rows=caml_check_bound(kernel_shp,1)[2],
               out_channel=caml_check_bound(kernel_shp,3)[4];
              if(in_channel === caml_check_bound(kernel_shp,2)[3])
               {var
                 output_shp=shape(output),
                 output_cols=caml_check_bound(output_shp,1)[2],
                 output_rows=caml_check_bound(output_shp,2)[3];
                if(batches === caml_check_bound(output_shp,0)[1])
                 {if(out_channel === caml_check_bound(output_shp,3)[4])
                   {var
                     col_stride=caml_check_bound(stride,0)[1],
                     row_stride=caml_check_bound(stride,1)[2],
                     _Hh_=shape(input),
                     input$0=caml_ba_create(caml_ba_kind(input),0,_Hh_),
                     match=
                      calc_conv2d_padding
                       (input_cols,
                        input_rows,
                        kernel_cols,
                        kernel_rows,
                        output_cols,
                        output_rows,
                        row_stride,
                        col_stride),
                     pad_left=match[2],
                     pad_top=match[1],
                     _Hj_=batches - 1 | 0,
                     _Hi_=0;
                    if(!(_Hj_ < 0))
                     {var b=_Hi_;
                      for(;;)
                       {var _Hl_=input_cols - 1 | 0,_Hk_=0;
                        if(!(_Hl_ < 0))
                         {var in_i=_Hk_;
                          for(;;)
                           {var _Ho_=input_rows - 1 | 0,_Hn_=0;
                            if(!(_Ho_ < 0))
                             {var in_j=_Hn_;
                              for(;;)
                               {var _Hr_=in_channel - 1 | 0,_Hq_=0;
                                if(!(_Hr_ < 0))
                                 {var q=_Hq_;
                                  for(;;)
                                   {var sum=[0,0],_Hu_=kernel_cols - 1 | 0,_Ht_=0;
                                    if(!(_Hu_ < 0))
                                     {var di=_Ht_;
                                      for(;;)
                                       {var _Hx_=kernel_rows - 1 | 0,_Hw_=0;
                                        if(!(_Hx_ < 0))
                                         {var dj=_Hw_;
                                          for(;;)
                                           {var
                                             _Hz_=
                                              0 === caml_mod((in_i + pad_left | 0) - di | 0,col_stride)
                                               ?1
                                               :0,
                                             _HA_=
                                              _Hz_
                                               ?0 === caml_mod((in_j + pad_top | 0) - dj | 0,row_stride)
                                                 ?1
                                                 :0
                                               :_Hz_;
                                            if(_HA_)
                                             {var
                                               out_col=caml_div((in_i + pad_left | 0) - di | 0,col_stride),
                                               out_row=caml_div((in_j + pad_top | 0) - dj | 0,row_stride),
                                               _HB_=0 <= out_col?1:0;
                                              if(_HB_)
                                               {var _HC_=out_col < output_cols?1:0;
                                                if(_HC_)
                                                 var
                                                  _HD_=0 <= out_row?1:0,
                                                  _HE_=_HD_?out_row < output_rows?1:0:_HD_;
                                                else
                                                 var _HE_=_HC_}
                                              else
                                               var _HE_=_HB_;
                                              if(_HE_)
                                               {var _HG_=out_channel - 1 | 0,_HF_=0;
                                                if(!(_HG_ < 0))
                                                 {var k=_HF_;
                                                  for(;;)
                                                   {var
                                                     out_grad=caml_ba_get_generic(output,[0,b,out_col,out_row,k]),
                                                     kernel_val=caml_ba_get_generic(kernel,[0,di,dj,q,k]);
                                                    sum[1] = sum[1] + out_grad * kernel_val;
                                                    var _HI_=k + 1 | 0;
                                                    if(_HG_ !== k){var k=_HI_;continue}
                                                    break}}}}
                                            var _HH_=dj + 1 | 0;
                                            if(_Hx_ !== dj){var dj=_HH_;continue}
                                            break}}
                                        var _Hy_=di + 1 | 0;
                                        if(_Hu_ !== di){var di=_Hy_;continue}
                                        break}}
                                    caml_ba_set_generic(input$0,[0,b,in_i,in_j,q],sum[1]);
                                    var _Hv_=q + 1 | 0;
                                    if(_Hr_ !== q){var q=_Hv_;continue}
                                    break}}
                                var _Hs_=in_j + 1 | 0;
                                if(_Ho_ !== in_j){var in_j=_Hs_;continue}
                                break}}
                            var _Hp_=in_i + 1 | 0;
                            if(_Hl_ !== in_i){var in_i=_Hp_;continue}
                            break}}
                        var _Hm_=b + 1 | 0;
                        if(_Hj_ !== b){var b=_Hm_;continue}
                        break}}
                    return input$0}
                  throw [0,Assert_failure,_h__]}
                throw [0,Assert_failure,_h$_]}
              throw [0,Assert_failure,_ia_]}
            throw [0,Assert_failure,_ib_]}
          throw [0,Assert_failure,_ic_]}
        throw [0,Assert_failure,_id_]}
      throw [0,Assert_failure,_ie_]}
    function conv2d_backward_kernel(input,kernel,stride,output)
     {if(4 === num_dims(input))
       {if(4 === num_dims(kernel))
         {if(4 === num_dims(output))
           {if(2 === stride.length - 1)
             {var
               input_shp=shape(input),
               batches=caml_check_bound(input_shp,0)[1],
               input_cols=caml_check_bound(input_shp,1)[2],
               input_rows=caml_check_bound(input_shp,2)[3],
               in_channel=caml_check_bound(input_shp,3)[4],
               kernel_shp=shape(kernel),
               kernel_cols=caml_check_bound(kernel_shp,0)[1],
               kernel_rows=caml_check_bound(kernel_shp,1)[2],
               out_channel=caml_check_bound(kernel_shp,3)[4];
              if(in_channel === caml_check_bound(kernel_shp,2)[3])
               {var
                 output_shp=shape(output),
                 output_cols=caml_check_bound(output_shp,1)[2],
                 output_rows=caml_check_bound(output_shp,2)[3];
                if(batches === caml_check_bound(output_shp,0)[1])
                 {if(out_channel === caml_check_bound(output_shp,3)[4])
                   {var
                     col_stride=caml_check_bound(stride,0)[1],
                     row_stride=caml_check_bound(stride,1)[2],
                     _GT_=shape(kernel),
                     kernel$0=caml_ba_create(caml_ba_kind(kernel),0,_GT_),
                     match=
                      calc_conv2d_padding
                       (input_cols,
                        input_rows,
                        kernel_cols,
                        kernel_rows,
                        output_cols,
                        output_rows,
                        row_stride,
                        col_stride),
                     pad_left=match[2],
                     pad_top=match[1],
                     _GV_=kernel_cols - 1 | 0,
                     _GU_=0;
                    if(!(_GV_ < 0))
                     {var di=_GU_;
                      for(;;)
                       {var _GX_=kernel_rows - 1 | 0,_GW_=0;
                        if(!(_GX_ < 0))
                         {var dj=_GW_;
                          for(;;)
                           {var _G0_=in_channel - 1 | 0,_GZ_=0;
                            if(!(_G0_ < 0))
                             {var q=_GZ_;
                              for(;;)
                               {var _G3_=out_channel - 1 | 0,_G2_=0;
                                if(!(_G3_ < 0))
                                 {var k=_G2_;
                                  for(;;)
                                   {var sum=[0,0],_G6_=batches - 1 | 0,_G5_=0;
                                    if(!(_G6_ < 0))
                                     {var b=_G5_;
                                      for(;;)
                                       {var _G9_=output_cols - 1 | 0,_G8_=0;
                                        if(!(_G9_ < 0))
                                         {var i=_G8_;
                                          for(;;)
                                           {var _Ha_=output_rows - 1 | 0,_G$_=0;
                                            if(!(_Ha_ < 0))
                                             {var j=_G$_;
                                              for(;;)
                                               {var
                                                 in_col=(caml_mul(i,col_stride) + di | 0) - pad_left | 0,
                                                 in_row=(caml_mul(j,row_stride) + dj | 0) - pad_top | 0,
                                                 _Hc_=0 <= in_col?1:0;
                                                if(_Hc_)
                                                 {var _Hd_=in_col < input_cols?1:0;
                                                  if(_Hd_)
                                                   var
                                                    _He_=0 <= in_row?1:0,
                                                    _Hf_=_He_?in_row < input_rows?1:0:_He_;
                                                  else
                                                   var _Hf_=_Hd_}
                                                else
                                                 var _Hf_=_Hc_;
                                                if(_Hf_)
                                                 {var
                                                   out_grad=caml_ba_get_generic(output,[0,b,i,j,k]),
                                                   input_val=caml_ba_get_generic(input,[0,b,in_col,in_row,q]);
                                                  sum[1] = sum[1] + out_grad * input_val}
                                                var _Hg_=j + 1 | 0;
                                                if(_Ha_ !== j){var j=_Hg_;continue}
                                                break}}
                                            var _Hb_=i + 1 | 0;
                                            if(_G9_ !== i){var i=_Hb_;continue}
                                            break}}
                                        var _G__=b + 1 | 0;
                                        if(_G6_ !== b){var b=_G__;continue}
                                        break}}
                                    caml_ba_set_generic(kernel$0,[0,di,dj,q,k],sum[1]);
                                    var _G7_=k + 1 | 0;
                                    if(_G3_ !== k){var k=_G7_;continue}
                                    break}}
                                var _G4_=q + 1 | 0;
                                if(_G0_ !== q){var q=_G4_;continue}
                                break}}
                            var _G1_=dj + 1 | 0;
                            if(_GX_ !== dj){var dj=_G1_;continue}
                            break}}
                        var _GY_=di + 1 | 0;
                        if(_GV_ !== di){var di=_GY_;continue}
                        break}}
                    return kernel$0}
                  throw [0,Assert_failure,_if_]}
                throw [0,Assert_failure,_ig_]}
              throw [0,Assert_failure,_ih_]}
            throw [0,Assert_failure,_ii_]}
          throw [0,Assert_failure,_ij_]}
        throw [0,Assert_failure,_ik_]}
      throw [0,Assert_failure,_il_]}
    function conv1d_backward_input(input,kernel,stride,output)
     {if(3 === num_dims(input))
       {if(3 === num_dims(kernel))
         {if(3 === num_dims(output))
           {if(1 === stride.length - 1)
             {var
               input_shp=shape(input),
               batches=caml_check_bound(input_shp,0)[1],
               input_cols=caml_check_bound(input_shp,1)[2],
               in_channel=caml_check_bound(input_shp,2)[3],
               input$0=
                caml_ba_reshape(input,[0,batches,1,input_cols,in_channel]),
               kernel_shp=shape(kernel),
               kernel_cols=caml_check_bound(kernel_shp,0)[1],
               out_channel=caml_check_bound(kernel_shp,2)[3];
              if(in_channel === caml_check_bound(kernel_shp,1)[2])
               {var
                 kernel$0=
                  caml_ba_reshape
                   (kernel,[0,1,kernel_cols,in_channel,out_channel]),
                 output_shp=shape(output),
                 output_cols=caml_check_bound(output_shp,1)[2];
                if(batches === caml_check_bound(output_shp,0)[1])
                 {if(out_channel === caml_check_bound(output_shp,2)[3])
                   {var
                     output$0=
                      caml_ba_reshape
                       (output,[0,batches,1,output_cols,out_channel]),
                     col_stride=caml_check_bound(stride,0)[1],
                     stride$0=[0,1,col_stride],
                     input$1=
                      conv2d_backward_input(input$0,kernel$0,stride$0,output$0);
                    return caml_ba_reshape(input$1,input_shp)}
                  throw [0,Assert_failure,_im_]}
                throw [0,Assert_failure,_in_]}
              throw [0,Assert_failure,_io_]}
            throw [0,Assert_failure,_ip_]}
          throw [0,Assert_failure,_iq_]}
        throw [0,Assert_failure,_ir_]}
      throw [0,Assert_failure,_is_]}
    function conv1d_backward_kernel(input,kernel,stride,output)
     {if(3 === num_dims(input))
       {if(3 === num_dims(kernel))
         {if(3 === num_dims(output))
           {if(1 === stride.length - 1)
             {var
               input_shp=shape(input),
               batches=caml_check_bound(input_shp,0)[1],
               input_cols=caml_check_bound(input_shp,1)[2],
               in_channel=caml_check_bound(input_shp,2)[3],
               input$0=
                caml_ba_reshape(input,[0,batches,1,input_cols,in_channel]),
               kernel_shp=shape(kernel),
               kernel_cols=caml_check_bound(kernel_shp,0)[1],
               out_channel=caml_check_bound(kernel_shp,2)[3];
              if(in_channel === caml_check_bound(kernel_shp,1)[2])
               {var
                 kernel$0=
                  caml_ba_reshape
                   (kernel,[0,1,kernel_cols,in_channel,out_channel]),
                 output_shp=shape(output),
                 output_cols=caml_check_bound(output_shp,1)[2];
                if(batches === caml_check_bound(output_shp,0)[1])
                 {if(out_channel === caml_check_bound(output_shp,2)[3])
                   {var
                     output$0=
                      caml_ba_reshape
                       (output,[0,batches,1,output_cols,out_channel]),
                     col_stride=caml_check_bound(stride,0)[1],
                     stride$0=[0,1,col_stride],
                     kernel$1=
                      conv2d_backward_kernel(input$0,kernel$0,stride$0,output$0);
                    return caml_ba_reshape(kernel$1,kernel_shp)}
                  throw [0,Assert_failure,_it_]}
                throw [0,Assert_failure,_iu_]}
              throw [0,Assert_failure,_iv_]}
            throw [0,Assert_failure,_iw_]}
          throw [0,Assert_failure,_ix_]}
        throw [0,Assert_failure,_iy_]}
      throw [0,Assert_failure,_iz_]}
    function conv3d_backward_input(input,kernel,stride,output)
     {if(5 === num_dims(input))
       {if(5 === num_dims(kernel))
         {if(5 === num_dims(output))
           {if(3 === stride.length - 1)
             {var
               input_shp=shape(input),
               batches=caml_check_bound(input_shp,0)[1],
               input_cols=caml_check_bound(input_shp,1)[2],
               input_rows=caml_check_bound(input_shp,2)[3],
               input_dpts=caml_check_bound(input_shp,3)[4],
               in_channel=caml_check_bound(input_shp,4)[5],
               kernel_shp=shape(kernel),
               kernel_cols=caml_check_bound(kernel_shp,0)[1],
               kernel_rows=caml_check_bound(kernel_shp,1)[2],
               kernel_dpts=caml_check_bound(kernel_shp,2)[3],
               out_channel=caml_check_bound(kernel_shp,4)[5];
              if(in_channel === caml_check_bound(kernel_shp,3)[4])
               {var
                 output_shp=shape(output),
                 output_cols=caml_check_bound(output_shp,1)[2],
                 output_rows=caml_check_bound(output_shp,2)[3],
                 output_dpts=caml_check_bound(output_shp,3)[4];
                if(batches === caml_check_bound(output_shp,0)[1])
                 {if(out_channel === caml_check_bound(output_shp,4)[5])
                   {var
                     col_stride=caml_check_bound(stride,0)[1],
                     row_stride=caml_check_bound(stride,1)[2],
                     dpt_stride=caml_check_bound(stride,2)[3],
                     _Gi_=shape(input),
                     input$0=caml_ba_create(caml_ba_kind(input),0,_Gi_),
                     match=
                      calc_conv3d_padding
                       (input_cols,
                        input_rows,
                        input_dpts,
                        kernel_cols,
                        kernel_rows,
                        kernel_dpts,
                        output_cols,
                        output_rows,
                        output_dpts,
                        row_stride,
                        col_stride,
                        dpt_stride),
                     pad_shallow=match[3],
                     pad_left=match[2],
                     pad_top=match[1],
                     _Gk_=batches - 1 | 0,
                     _Gj_=0;
                    if(!(_Gk_ < 0))
                     {var b=_Gj_;
                      for(;;)
                       {var _Gm_=input_cols - 1 | 0,_Gl_=0;
                        if(!(_Gm_ < 0))
                         {var in_i=_Gl_;
                          for(;;)
                           {var _Gp_=input_rows - 1 | 0,_Go_=0;
                            if(!(_Gp_ < 0))
                             {var in_j=_Go_;
                              for(;;)
                               {var _Gs_=input_dpts - 1 | 0,_Gr_=0;
                                if(!(_Gs_ < 0))
                                 {var in_dpt=_Gr_;
                                  for(;;)
                                   {var _Gv_=in_channel - 1 | 0,_Gu_=0;
                                    if(!(_Gv_ < 0))
                                     {var q=_Gu_;
                                      for(;;)
                                       {var sum=[0,0],_Gy_=kernel_cols - 1 | 0,_Gx_=0;
                                        if(!(_Gy_ < 0))
                                         {var di=_Gx_;
                                          for(;;)
                                           {var _GB_=kernel_rows - 1 | 0,_GA_=0;
                                            if(!(_GB_ < 0))
                                             {var dj=_GA_;
                                              for(;;)
                                               {var _GE_=kernel_dpts - 1 | 0,_GD_=0;
                                                if(!(_GE_ < 0))
                                                 {var d_dpt=_GD_;
                                                  for(;;)
                                                   {var
                                                     _GG_=
                                                      0 === caml_mod((in_i + pad_left | 0) - di | 0,col_stride)
                                                       ?1
                                                       :0;
                                                    if(_GG_)
                                                     var
                                                      _GH_=
                                                       0 === caml_mod((in_j + pad_top | 0) - dj | 0,row_stride)?1:0,
                                                      _GI_=
                                                       _GH_
                                                        ?0
                                                          ===
                                                          caml_mod((in_dpt + pad_shallow | 0) - d_dpt | 0,dpt_stride)
                                                          ?1
                                                          :0
                                                        :_GH_;
                                                    else
                                                     var _GI_=_GG_;
                                                    if(_GI_)
                                                     {var
                                                       out_col=caml_div((in_i + pad_left | 0) - di | 0,col_stride),
                                                       out_row=caml_div((in_j + pad_top | 0) - dj | 0,row_stride),
                                                       out_dpt=
                                                        caml_div((in_dpt + pad_shallow | 0) - d_dpt | 0,dpt_stride),
                                                       _GJ_=0 <= out_col?1:0;
                                                      if(_GJ_)
                                                       {var _GK_=out_col < output_cols?1:0;
                                                        if(_GK_)
                                                         {var _GL_=0 <= out_row?1:0;
                                                          if(_GL_)
                                                           {var _GM_=out_row < output_rows?1:0;
                                                            if(_GM_)
                                                             var
                                                              _GN_=0 <= out_dpt?1:0,
                                                              _GO_=_GN_?out_dpt < output_dpts?1:0:_GN_;
                                                            else
                                                             var _GO_=_GM_}
                                                          else
                                                           var _GO_=_GL_}
                                                        else
                                                         var _GO_=_GK_}
                                                      else
                                                       var _GO_=_GJ_;
                                                      if(_GO_)
                                                       {var _GQ_=out_channel - 1 | 0,_GP_=0;
                                                        if(!(_GQ_ < 0))
                                                         {var k=_GP_;
                                                          for(;;)
                                                           {var
                                                             out_grad=
                                                              caml_ba_get_generic(output,[0,b,out_col,out_row,out_dpt,k]),
                                                             kernel_val=caml_ba_get_generic(kernel,[0,di,dj,d_dpt,q,k]);
                                                            sum[1] = sum[1] + out_grad * kernel_val;
                                                            var _GS_=k + 1 | 0;
                                                            if(_GQ_ !== k){var k=_GS_;continue}
                                                            break}}}}
                                                    var _GR_=d_dpt + 1 | 0;
                                                    if(_GE_ !== d_dpt){var d_dpt=_GR_;continue}
                                                    break}}
                                                var _GF_=dj + 1 | 0;
                                                if(_GB_ !== dj){var dj=_GF_;continue}
                                                break}}
                                            var _GC_=di + 1 | 0;
                                            if(_Gy_ !== di){var di=_GC_;continue}
                                            break}}
                                        caml_ba_set_generic(input$0,[0,b,in_i,in_j,in_dpt,q],sum[1]);
                                        var _Gz_=q + 1 | 0;
                                        if(_Gv_ !== q){var q=_Gz_;continue}
                                        break}}
                                    var _Gw_=in_dpt + 1 | 0;
                                    if(_Gs_ !== in_dpt){var in_dpt=_Gw_;continue}
                                    break}}
                                var _Gt_=in_j + 1 | 0;
                                if(_Gp_ !== in_j){var in_j=_Gt_;continue}
                                break}}
                            var _Gq_=in_i + 1 | 0;
                            if(_Gm_ !== in_i){var in_i=_Gq_;continue}
                            break}}
                        var _Gn_=b + 1 | 0;
                        if(_Gk_ !== b){var b=_Gn_;continue}
                        break}}
                    return input$0}
                  throw [0,Assert_failure,_iA_]}
                throw [0,Assert_failure,_iB_]}
              throw [0,Assert_failure,_iC_]}
            throw [0,Assert_failure,_iD_]}
          throw [0,Assert_failure,_iE_]}
        throw [0,Assert_failure,_iF_]}
      throw [0,Assert_failure,_iG_]}
    function conv3d_backward_kernel(input,kernel,stride,output)
     {if(5 === num_dims(input))
       {if(5 === num_dims(kernel))
         {if(5 === num_dims(output))
           {if(3 === stride.length - 1)
             {var
               input_shp=shape(input),
               batches=caml_check_bound(input_shp,0)[1],
               input_cols=caml_check_bound(input_shp,1)[2],
               input_rows=caml_check_bound(input_shp,2)[3],
               input_dpts=caml_check_bound(input_shp,3)[4],
               in_channel=caml_check_bound(input_shp,4)[5],
               kernel_shp=shape(kernel),
               kernel_cols=caml_check_bound(kernel_shp,0)[1],
               kernel_rows=caml_check_bound(kernel_shp,1)[2],
               kernel_dpts=caml_check_bound(kernel_shp,2)[3],
               out_channel=caml_check_bound(kernel_shp,4)[5];
              if(in_channel === caml_check_bound(kernel_shp,3)[4])
               {var
                 output_shp=shape(output),
                 output_cols=caml_check_bound(output_shp,1)[2],
                 output_rows=caml_check_bound(output_shp,2)[3],
                 output_dpts=caml_check_bound(output_shp,3)[4];
                if(batches === caml_check_bound(output_shp,0)[1])
                 {if(out_channel === caml_check_bound(output_shp,4)[5])
                   {var
                     col_stride=caml_check_bound(stride,0)[1],
                     row_stride=caml_check_bound(stride,1)[2],
                     dpt_stride=caml_check_bound(stride,2)[3],
                     _FM_=shape(kernel),
                     kernel$0=caml_ba_create(caml_ba_kind(kernel),0,_FM_),
                     match=
                      calc_conv3d_padding
                       (input_cols,
                        input_rows,
                        input_dpts,
                        kernel_cols,
                        kernel_rows,
                        kernel_dpts,
                        output_cols,
                        output_rows,
                        output_dpts,
                        row_stride,
                        col_stride,
                        dpt_stride),
                     pad_shallow=match[3],
                     pad_left=match[2],
                     pad_top=match[1],
                     _FO_=kernel_cols - 1 | 0,
                     _FN_=0;
                    if(!(_FO_ < 0))
                     {var di=_FN_;
                      for(;;)
                       {var _FQ_=kernel_rows - 1 | 0,_FP_=0;
                        if(!(_FQ_ < 0))
                         {var dj=_FP_;
                          for(;;)
                           {var _FT_=kernel_dpts - 1 | 0,_FS_=0;
                            if(!(_FT_ < 0))
                             {var d_dpt=_FS_;
                              for(;;)
                               {var _FW_=in_channel - 1 | 0,_FV_=0;
                                if(!(_FW_ < 0))
                                 {var q=_FV_;
                                  for(;;)
                                   {var _FZ_=out_channel - 1 | 0,_FY_=0;
                                    if(!(_FZ_ < 0))
                                     {var k=_FY_;
                                      for(;;)
                                       {var sum=[0,0],_F2_=batches - 1 | 0,_F1_=0;
                                        if(!(_F2_ < 0))
                                         {var b=_F1_;
                                          for(;;)
                                           {var _F5_=output_cols - 1 | 0,_F4_=0;
                                            if(!(_F5_ < 0))
                                             {var i=_F4_;
                                              for(;;)
                                               {var _F8_=output_rows - 1 | 0,_F7_=0;
                                                if(!(_F8_ < 0))
                                                 {var j=_F7_;
                                                  for(;;)
                                                   {var _F$_=output_dpts - 1 | 0,_F__=0;
                                                    if(!(_F$_ < 0))
                                                     {var dpt=_F__;
                                                      for(;;)
                                                       {var
                                                         in_col=(caml_mul(i,col_stride) + di | 0) - pad_left | 0,
                                                         in_row=(caml_mul(j,row_stride) + dj | 0) - pad_top | 0,
                                                         in_dpt=
                                                          (caml_mul(dpt,dpt_stride) + d_dpt | 0)
                                                          -
                                                          pad_shallow
                                                          |
                                                          0,
                                                         _Gb_=0 <= in_col?1:0;
                                                        if(_Gb_)
                                                         {var _Gc_=in_col < input_cols?1:0;
                                                          if(_Gc_)
                                                           {var _Gd_=0 <= in_row?1:0;
                                                            if(_Gd_)
                                                             {var _Ge_=in_row < input_rows?1:0;
                                                              if(_Ge_)
                                                               var
                                                                _Gf_=0 <= in_dpt?1:0,
                                                                _Gg_=_Gf_?in_dpt < input_dpts?1:0:_Gf_;
                                                              else
                                                               var _Gg_=_Ge_}
                                                            else
                                                             var _Gg_=_Gd_}
                                                          else
                                                           var _Gg_=_Gc_}
                                                        else
                                                         var _Gg_=_Gb_;
                                                        if(_Gg_)
                                                         {var
                                                           out_grad=caml_ba_get_generic(output,[0,b,i,j,dpt,k]),
                                                           input_val=
                                                            caml_ba_get_generic(input,[0,b,in_col,in_row,in_dpt,q]);
                                                          sum[1] = sum[1] + out_grad * input_val}
                                                        var _Gh_=dpt + 1 | 0;
                                                        if(_F$_ !== dpt){var dpt=_Gh_;continue}
                                                        break}}
                                                    var _Ga_=j + 1 | 0;
                                                    if(_F8_ !== j){var j=_Ga_;continue}
                                                    break}}
                                                var _F9_=i + 1 | 0;
                                                if(_F5_ !== i){var i=_F9_;continue}
                                                break}}
                                            var _F6_=b + 1 | 0;
                                            if(_F2_ !== b){var b=_F6_;continue}
                                            break}}
                                        caml_ba_set_generic(kernel$0,[0,di,dj,d_dpt,q,k],sum[1]);
                                        var _F3_=k + 1 | 0;
                                        if(_FZ_ !== k){var k=_F3_;continue}
                                        break}}
                                    var _F0_=q + 1 | 0;
                                    if(_FW_ !== q){var q=_F0_;continue}
                                    break}}
                                var _FX_=d_dpt + 1 | 0;
                                if(_FT_ !== d_dpt){var d_dpt=_FX_;continue}
                                break}}
                            var _FU_=dj + 1 | 0;
                            if(_FQ_ !== dj){var dj=_FU_;continue}
                            break}}
                        var _FR_=di + 1 | 0;
                        if(_FO_ !== di){var di=_FR_;continue}
                        break}}
                    return kernel$0}
                  throw [0,Assert_failure,_iH_]}
                throw [0,Assert_failure,_iI_]}
              throw [0,Assert_failure,_iJ_]}
            throw [0,Assert_failure,_iK_]}
          throw [0,Assert_failure,_iL_]}
        throw [0,Assert_failure,_iM_]}
      throw [0,Assert_failure,_iN_]}
    function pool2d_backward
     (padding,
      input,
      kernel,
      stride,
      output,
      init_pool_fun,
      add_val_pool_fun,
      end_pool_fun,
      compute_grad_fun)
     {if(4 === num_dims(input))
       {if(2 === kernel.length - 1)
         {if(2 === stride.length - 1)
           {var
             input_shp=shape(input),
             batches=caml_check_bound(input_shp,0)[1],
             input_cols=caml_check_bound(input_shp,1)[2],
             input_rows=caml_check_bound(input_shp,2)[3],
             in_channel=caml_check_bound(input_shp,3)[4],
             kernel_cols=caml_check_bound(kernel,0)[1],
             kernel_rows=caml_check_bound(kernel,1)[2],
             col_stride=caml_check_bound(stride,0)[1],
             row_stride=caml_check_bound(stride,1)[2],
             output_shp=shape(output),
             output_cols=caml_check_bound(output_shp,1)[2],
             output_rows=caml_check_bound(output_shp,2)[3];
            if(batches === caml_check_bound(output_shp,0)[1])
             {if(in_channel === caml_check_bound(output_shp,3)[4])
               {var
                 match=
                  calc_conv2d_padding
                   (input_cols,
                    input_rows,
                    kernel_cols,
                    kernel_rows,
                    output_cols,
                    output_rows,
                    row_stride,
                    col_stride),
                 pad_left=match[2],
                 pad_top=match[1],
                 _Ff_=shape(input),
                 input$0=zeros(caml_ba_kind(input),_Ff_),
                 _Fh_=batches - 1 | 0,
                 _Fg_=0;
                if(!(_Fh_ < 0))
                 {var b=_Fg_;
                  for(;;)
                   {var _Fj_=output_cols - 1 | 0,_Fi_=0;
                    if(!(_Fj_ < 0))
                     {var i=_Fi_;
                      for(;;)
                       {var _Fm_=output_rows - 1 | 0,_Fl_=0;
                        if(!(_Fm_ < 0))
                         {var j=_Fl_;
                          for(;;)
                           {var _Fp_=in_channel - 1 | 0,_Fo_=0;
                            if(!(_Fp_ < 0))
                             {var k=_Fo_;
                              for(;;)
                               {caml_call1(init_pool_fun,0);
                                var _Fs_=kernel_cols - 1 | 0,_Fr_=0;
                                if(!(_Fs_ < 0))
                                 {var di$0=_Fr_;
                                  for(;;)
                                   {var _FF_=kernel_rows - 1 | 0,_FE_=0;
                                    if(!(_FF_ < 0))
                                     {var dj$0=_FE_;
                                      for(;;)
                                       {var
                                         in_col$0=(caml_mul(i,col_stride) + di$0 | 0) - pad_left | 0,
                                         in_row$0=(caml_mul(j,row_stride) + dj$0 | 0) - pad_top | 0,
                                         _FH_=0 <= in_col$0?1:0;
                                        if(_FH_)
                                         {var _FI_=in_col$0 < input_cols?1:0;
                                          if(_FI_)
                                           var
                                            _FJ_=0 <= in_row$0?1:0,
                                            _FK_=_FJ_?in_row$0 < input_rows?1:0:_FJ_;
                                          else
                                           var _FK_=_FI_}
                                        else
                                         var _FK_=_FH_;
                                        if(_FK_)
                                         caml_call1
                                          (add_val_pool_fun,
                                           caml_ba_get_generic(input,[0,b,in_col$0,in_row$0,k]));
                                        var _FL_=dj$0 + 1 | 0;
                                        if(_FF_ !== dj$0){var dj$0=_FL_;continue}
                                        break}}
                                    var _FG_=di$0 + 1 | 0;
                                    if(_Fs_ !== di$0){var di$0=_FG_;continue}
                                    break}}
                                var
                                 output_val=caml_call1(end_pool_fun,0),
                                 output_grad=caml_ba_get_generic(output,[0,b,i,j,k]),
                                 _Fu_=kernel_cols - 1 | 0,
                                 _Ft_=0;
                                if(!(_Fu_ < 0))
                                 {var di=_Ft_;
                                  for(;;)
                                   {var _Fx_=kernel_rows - 1 | 0,_Fw_=0;
                                    if(!(_Fx_ < 0))
                                     {var dj=_Fw_;
                                      for(;;)
                                       {var
                                         in_col=(caml_mul(i,col_stride) + di | 0) - pad_left | 0,
                                         in_row=(caml_mul(j,row_stride) + dj | 0) - pad_top | 0,
                                         _Fz_=0 <= in_col?1:0;
                                        if(_Fz_)
                                         {var _FA_=in_col < input_cols?1:0;
                                          if(_FA_)
                                           var
                                            _FB_=0 <= in_row?1:0,
                                            _FC_=_FB_?in_row < input_rows?1:0:_FB_;
                                          else
                                           var _FC_=_FA_}
                                        else
                                         var _FC_=_Fz_;
                                        if(_FC_)
                                         {var
                                           input_val=caml_ba_get_generic(input,[0,b,in_col,in_row,k]),
                                           input_grad=
                                            caml_ba_get_generic(input$0,[0,b,in_col,in_row,k]);
                                          caml_ba_set_generic
                                           (input$0,
                                            [0,b,in_col,in_row,k],
                                            caml_call4
                                             (compute_grad_fun,
                                              input_val,
                                              input_grad,
                                              output_val,
                                              output_grad))}
                                        var _FD_=dj + 1 | 0;
                                        if(_Fx_ !== dj){var dj=_FD_;continue}
                                        break}}
                                    var _Fy_=di + 1 | 0;
                                    if(_Fu_ !== di){var di=_Fy_;continue}
                                    break}}
                                var _Fv_=k + 1 | 0;
                                if(_Fp_ !== k){var k=_Fv_;continue}
                                break}}
                            var _Fq_=j + 1 | 0;
                            if(_Fm_ !== j){var j=_Fq_;continue}
                            break}}
                        var _Fn_=i + 1 | 0;
                        if(_Fj_ !== i){var i=_Fn_;continue}
                        break}}
                    var _Fk_=b + 1 | 0;
                    if(_Fh_ !== b){var b=_Fk_;continue}
                    break}}
                return input$0}
              throw [0,Assert_failure,_iO_]}
            throw [0,Assert_failure,_iP_]}
          throw [0,Assert_failure,_iQ_]}
        throw [0,Assert_failure,_iR_]}
      throw [0,Assert_failure,_iS_]}
    function max_pool2d_backward(padding,input,kernel,stride,output)
     {var max_pool=[0,0];
      function init_pool_fun(param){max_pool[1] = min_float;return 0}
      function add_val_pool_fun(v){max_pool[1] = max(max_pool[1],v);return 0}
      function end_pool_fun(param){return max_pool[1]}
      function compute_grad_fun(input_val,input_grad,output_val,output_grad)
       {return Math.abs(input_val - output_val) < 1e-08
                ?input_grad + output_grad
                :input_grad}
      return pool2d_backward
              (padding,
               input,
               kernel,
               stride,
               output,
               init_pool_fun,
               add_val_pool_fun,
               end_pool_fun,
               compute_grad_fun)}
    function avg_pool2d_backward(padding,input,kernel,stride,output)
     {var sum_pool=[0,0],cnt=[0,0];
      function init_pool_fun(param){sum_pool[1] = 0;cnt[1] = 0;return 0}
      function add_val_pool_fun(v)
       {sum_pool[1] = sum_pool[1] + v;cnt[1] = cnt[1] + 1;return 0}
      function end_pool_fun(param){return sum_pool[1] / cnt[1]}
      function compute_grad_fun(input_val,input_grad,output_val,output_grad)
       {return input_grad + output_grad / cnt[1]}
      return pool2d_backward
              (padding,
               input,
               kernel,
               stride,
               output,
               init_pool_fun,
               add_val_pool_fun,
               end_pool_fun,
               compute_grad_fun)}
    function pool3d_backward
     (padding,
      input,
      kernel,
      stride,
      output,
      init_pool_fun,
      add_val_pool_fun,
      end_pool_fun,
      compute_grad_fun)
     {if(5 === num_dims(input))
       {if(3 === kernel.length - 1)
         {if(3 === stride.length - 1)
           {var
             input_shp=shape(input),
             batches=caml_check_bound(input_shp,0)[1],
             input_cols=caml_check_bound(input_shp,1)[2],
             input_rows=caml_check_bound(input_shp,2)[3],
             input_dpts=caml_check_bound(input_shp,3)[4],
             in_channel=caml_check_bound(input_shp,4)[5],
             kernel_cols=caml_check_bound(kernel,0)[1],
             kernel_rows=caml_check_bound(kernel,1)[2],
             kernel_dpts=caml_check_bound(kernel,2)[3],
             col_stride=caml_check_bound(stride,0)[1],
             row_stride=caml_check_bound(stride,1)[2],
             dpt_stride=caml_check_bound(stride,2)[3],
             output_shp=shape(output),
             output_cols=caml_check_bound(output_shp,1)[2],
             output_rows=caml_check_bound(output_shp,2)[3],
             output_dpts=caml_check_bound(output_shp,3)[4];
            if(batches === caml_check_bound(output_shp,0)[1])
             {if(in_channel === caml_check_bound(output_shp,4)[5])
               {var
                 match=
                  calc_conv3d_padding
                   (input_cols,
                    input_rows,
                    input_dpts,
                    kernel_cols,
                    kernel_rows,
                    kernel_dpts,
                    output_cols,
                    output_rows,
                    output_dpts,
                    row_stride,
                    col_stride,
                    dpt_stride),
                 pad_shallow=match[3],
                 pad_left=match[2],
                 pad_top=match[1],
                 _Ex_=shape(input),
                 input$0=zeros(caml_ba_kind(input),_Ex_),
                 _Ez_=batches - 1 | 0,
                 _Ey_=0;
                if(!(_Ez_ < 0))
                 {var b=_Ey_;
                  for(;;)
                   {var _EB_=output_cols - 1 | 0,_EA_=0;
                    if(!(_EB_ < 0))
                     {var i=_EA_;
                      for(;;)
                       {var _EE_=output_rows - 1 | 0,_ED_=0;
                        if(!(_EE_ < 0))
                         {var j=_ED_;
                          for(;;)
                           {var _EH_=output_dpts - 1 | 0,_EG_=0;
                            if(!(_EH_ < 0))
                             {var dpt=_EG_;
                              for(;;)
                               {var _EK_=in_channel - 1 | 0,_EJ_=0;
                                if(!(_EK_ < 0))
                                 {var k=_EJ_;
                                  for(;;)
                                   {caml_call1(init_pool_fun,0);
                                    var _EN_=kernel_cols - 1 | 0,_EM_=0;
                                    if(!(_EN_ < 0))
                                     {var di$0=_EM_;
                                      for(;;)
                                       {var _E5_=kernel_rows - 1 | 0,_E4_=0;
                                        if(!(_E5_ < 0))
                                         {var dj$0=_E4_;
                                          for(;;)
                                           {var _E8_=kernel_dpts - 1 | 0,_E7_=0;
                                            if(!(_E8_ < 0))
                                             {var dk$0=_E7_;
                                              for(;;)
                                               {var
                                                 in_col$0=(caml_mul(i,col_stride) + di$0 | 0) - pad_left | 0,
                                                 in_row$0=(caml_mul(j,row_stride) + dj$0 | 0) - pad_top | 0,
                                                 in_dpt$0=
                                                  (caml_mul(dpt,dpt_stride) + dk$0 | 0)
                                                  -
                                                  pad_shallow
                                                  |
                                                  0,
                                                 _E__=0 <= in_col$0?1:0;
                                                if(_E__)
                                                 {var _E$_=in_col$0 < input_cols?1:0;
                                                  if(_E$_)
                                                   {var _Fa_=0 <= in_row$0?1:0;
                                                    if(_Fa_)
                                                     {var _Fb_=in_row$0 < input_rows?1:0;
                                                      if(_Fb_)
                                                       var
                                                        _Fc_=0 <= in_dpt$0?1:0,
                                                        _Fd_=_Fc_?in_dpt$0 < input_dpts?1:0:_Fc_;
                                                      else
                                                       var _Fd_=_Fb_}
                                                    else
                                                     var _Fd_=_Fa_}
                                                  else
                                                   var _Fd_=_E$_}
                                                else
                                                 var _Fd_=_E__;
                                                if(_Fd_)
                                                 caml_call1
                                                  (add_val_pool_fun,
                                                   caml_ba_get_generic
                                                    (input,[0,b,in_col$0,in_row$0,in_dpt$0,k]));
                                                var _Fe_=dk$0 + 1 | 0;
                                                if(_E8_ !== dk$0){var dk$0=_Fe_;continue}
                                                break}}
                                            var _E9_=dj$0 + 1 | 0;
                                            if(_E5_ !== dj$0){var dj$0=_E9_;continue}
                                            break}}
                                        var _E6_=di$0 + 1 | 0;
                                        if(_EN_ !== di$0){var di$0=_E6_;continue}
                                        break}}
                                    var
                                     output_val=caml_call1(end_pool_fun,0),
                                     output_grad=caml_ba_get_generic(output,[0,b,i,j,dpt,k]),
                                     _EP_=kernel_cols - 1 | 0,
                                     _EO_=0;
                                    if(!(_EP_ < 0))
                                     {var di=_EO_;
                                      for(;;)
                                       {var _ES_=kernel_rows - 1 | 0,_ER_=0;
                                        if(!(_ES_ < 0))
                                         {var dj=_ER_;
                                          for(;;)
                                           {var _EV_=kernel_dpts - 1 | 0,_EU_=0;
                                            if(!(_EV_ < 0))
                                             {var dk=_EU_;
                                              for(;;)
                                               {var
                                                 in_col=(caml_mul(i,col_stride) + di | 0) - pad_left | 0,
                                                 in_row=(caml_mul(j,row_stride) + dj | 0) - pad_top | 0,
                                                 in_dpt=(caml_mul(dpt,dpt_stride) + dk | 0) - pad_shallow | 0,
                                                 _EX_=0 <= in_col?1:0;
                                                if(_EX_)
                                                 {var _EY_=in_col < input_cols?1:0;
                                                  if(_EY_)
                                                   {var _EZ_=0 <= in_row?1:0;
                                                    if(_EZ_)
                                                     {var _E0_=in_row < input_rows?1:0;
                                                      if(_E0_)
                                                       var
                                                        _E1_=0 <= in_dpt?1:0,
                                                        _E2_=_E1_?in_dpt < input_dpts?1:0:_E1_;
                                                      else
                                                       var _E2_=_E0_}
                                                    else
                                                     var _E2_=_EZ_}
                                                  else
                                                   var _E2_=_EY_}
                                                else
                                                 var _E2_=_EX_;
                                                if(_E2_)
                                                 {var
                                                   input_val=
                                                    caml_ba_get_generic(input,[0,b,in_col,in_row,in_dpt,k]),
                                                   input_grad=
                                                    caml_ba_get_generic(input$0,[0,b,in_col,in_row,in_dpt,k]);
                                                  caml_ba_set_generic
                                                   (input$0,
                                                    [0,b,in_col,in_row,in_dpt,k],
                                                    caml_call4
                                                     (compute_grad_fun,
                                                      input_val,
                                                      input_grad,
                                                      output_val,
                                                      output_grad))}
                                                var _E3_=dk + 1 | 0;
                                                if(_EV_ !== dk){var dk=_E3_;continue}
                                                break}}
                                            var _EW_=dj + 1 | 0;
                                            if(_ES_ !== dj){var dj=_EW_;continue}
                                            break}}
                                        var _ET_=di + 1 | 0;
                                        if(_EP_ !== di){var di=_ET_;continue}
                                        break}}
                                    var _EQ_=k + 1 | 0;
                                    if(_EK_ !== k){var k=_EQ_;continue}
                                    break}}
                                var _EL_=dpt + 1 | 0;
                                if(_EH_ !== dpt){var dpt=_EL_;continue}
                                break}}
                            var _EI_=j + 1 | 0;
                            if(_EE_ !== j){var j=_EI_;continue}
                            break}}
                        var _EF_=i + 1 | 0;
                        if(_EB_ !== i){var i=_EF_;continue}
                        break}}
                    var _EC_=b + 1 | 0;
                    if(_Ez_ !== b){var b=_EC_;continue}
                    break}}
                return input$0}
              throw [0,Assert_failure,_iT_]}
            throw [0,Assert_failure,_iU_]}
          throw [0,Assert_failure,_iV_]}
        throw [0,Assert_failure,_iW_]}
      throw [0,Assert_failure,_iX_]}
    function max_pool3d_backward(padding,input,kernel,stride,output)
     {var max_pool=[0,0];
      function init_pool_fun(param){max_pool[1] = min_float;return 0}
      function add_val_pool_fun(v){max_pool[1] = max(max_pool[1],v);return 0}
      function end_pool_fun(param){return max_pool[1]}
      function compute_grad_fun(input_val,input_grad,output_val,output_grad)
       {return Math.abs(input_val - output_val) < 1e-08
                ?input_grad + output_grad
                :input_grad}
      return pool3d_backward
              (padding,
               input,
               kernel,
               stride,
               output,
               init_pool_fun,
               add_val_pool_fun,
               end_pool_fun,
               compute_grad_fun)}
    function avg_pool3d_backward(padding,input,kernel,stride,output)
     {var sum_pool=[0,0],cnt=[0,0];
      function init_pool_fun(param){sum_pool[1] = 0;cnt[1] = 0;return 0}
      function add_val_pool_fun(v)
       {sum_pool[1] = sum_pool[1] + v;cnt[1] = cnt[1] + 1;return 0}
      function end_pool_fun(param){return sum_pool[1] / cnt[1]}
      function compute_grad_fun(input_val,input_grad,output_val,output_grad)
       {return input_grad + output_grad / cnt[1]}
      return pool3d_backward
              (padding,
               input,
               kernel,
               stride,
               output,
               init_pool_fun,
               add_val_pool_fun,
               end_pool_fun,
               compute_grad_fun)}
    function max_pool1d_backward(padding,input,kernel,stride,output)
     {if(3 === num_dims(input))
       {if(1 === kernel.length - 1)
         {if(1 === stride.length - 1)
           {var
             input_shp=shape(input),
             batches=caml_check_bound(input_shp,0)[1],
             input_cols=caml_check_bound(input_shp,1)[2],
             in_channel=caml_check_bound(input_shp,2)[3],
             input$0=
              caml_ba_reshape(input,[0,batches,1,input_cols,in_channel]),
             kernel_cols=caml_check_bound(kernel,0)[1],
             kernel$0=[0,1,kernel_cols],
             col_stride=caml_check_bound(stride,0)[1],
             stride$0=[0,1,col_stride],
             output_shp=shape(output),
             output_cols=caml_check_bound(output_shp,1)[2],
             out_channel=caml_check_bound(output_shp,2)[3],
             output$0=
              caml_ba_reshape(output,[0,batches,1,output_cols,out_channel]),
             input$1=
              max_pool2d_backward(padding,input$0,kernel$0,stride$0,output$0);
            return caml_ba_reshape(input$1,input_shp)}
          throw [0,Assert_failure,_iY_]}
        throw [0,Assert_failure,_iZ_]}
      throw [0,Assert_failure,_i0_]}
    function avg_pool1d_backward(padding,input,kernel,stride,output)
     {if(3 === num_dims(input))
       {if(1 === kernel.length - 1)
         {if(1 === stride.length - 1)
           {var
             input_shp=shape(input),
             batches=caml_check_bound(input_shp,0)[1],
             input_cols=caml_check_bound(input_shp,1)[2],
             in_channel=caml_check_bound(input_shp,2)[3],
             input$0=
              caml_ba_reshape(input,[0,batches,1,input_cols,in_channel]),
             kernel_cols=caml_check_bound(kernel,0)[1],
             kernel$0=[0,1,kernel_cols],
             col_stride=caml_check_bound(stride,0)[1],
             stride$0=[0,1,col_stride],
             output_shp=shape(output),
             output_cols=caml_check_bound(output_shp,1)[2],
             out_channel=caml_check_bound(output_shp,2)[3],
             output$0=
              caml_ba_reshape(output,[0,batches,1,output_cols,out_channel]),
             input$1=
              avg_pool2d_backward(padding,input$0,kernel$0,stride$0,output$0);
            return caml_ba_reshape(input$1,input_shp)}
          throw [0,Assert_failure,_i1_]}
        throw [0,Assert_failure,_i2_]}
      throw [0,Assert_failure,_i3_]}
    function check_is_matrix(dims)
     {if(2 === dims.length - 1)return 0;throw [0,Invalid_argument,_i5_]}
    function row_num(varr)
     {var dims=shape(varr);
      check_is_matrix(dims);
      return caml_check_bound(dims,0)[1]}
    function col_num(varr)
     {var dims=shape(varr);
      check_is_matrix(dims);
      return caml_check_bound(dims,1)[2]}
    function row(varr,ind)
     {var dims=shape(varr);
      check_is_matrix(dims);
      return caml_ba_slice(varr,[0,ind])}
    function rows(varr,indices)
     {var dims=shape(varr);
      check_is_matrix(dims);
      var
       new_rownum=indices.length - 1,
       new_colnum=caml_check_bound(dims,1)[2],
       new_varr=caml_ba_create(caml_ba_kind(varr),0,[0,new_rownum,new_colnum]),
       _Eu_=new_rownum - 1 | 0,
       _Et_=0;
      if(!(_Eu_ < 0))
       {var i=_Et_;
        for(;;)
         {var _Ev_=caml_ba_slice(new_varr,[0,i]);
          caml_ba_blit
           (caml_ba_slice(varr,[0,caml_check_bound(indices,i)[i + 1]]),_Ev_);
          var _Ew_=i + 1 | 0;
          if(_Eu_ !== i){var i=_Ew_;continue}
          break}}
      return new_varr}
    function copy_row_to(vec,varr,ind)
     {var dims=shape(varr);
      check_is_matrix(dims);
      return caml_ba_blit(vec,caml_ba_slice(varr,[0,ind]))}
    function copy_col_to(vec,varr,ind)
     {var dims=shape(varr);
      check_is_matrix(dims);
      var dims$0=shape(vec),param$0=to_list(dims$0),accu=0,param=param$0;
      for(;;)
       {if(param)
         {var l=param[2],x=param[1];
          if(1 < x){var accu$0=[0,x,accu],accu=accu$0,param=l;continue}
          var param=l;
          continue}
        var
         removed_ones_list=rev(accu),
         not_empty_list=removed_ones_list || _i4_,
         vec_dims=of_list(not_empty_list);
        if(1 === vec_dims.length - 1)
         {var
           vec_len=caml_check_bound(vec_dims,0)[1],
           num_rows=caml_check_bound(dims,0)[1],
           vec_linear=array1_of_genarray(flatten(vec));
          if(num_rows !== vec_len)throw [0,Invalid_argument,_i6_];
          var _Er_=num_rows - 1 | 0,_Eq_=0;
          if(!(_Er_ < 0))
           {var i=_Eq_;
            for(;;)
             {caml_ba_set_generic(varr,[0,i,ind],caml_ba_get_1(vec_linear,i));
              var _Es_=i + 1 | 0;
              if(_Er_ !== i){var i=_Es_;continue}
              break}}
          return 0}
        throw [0,Invalid_argument,_i7_]}}
    function dot(varr_a,varr_b)
     {var dims_b=shape(varr_b),dims_a=shape(varr_a);
      check_is_matrix(dims_b);
      check_is_matrix(dims_a);
      var
       m=caml_check_bound(dims_a,0)[1],
       cdim=caml_check_bound(dims_a,1)[2],
       n=caml_check_bound(dims_b,1)[2];
      if(caml_check_bound(dims_b,0)[1] !== cdim)
       throw [0,Invalid_argument,_i8_];
      var
       varr_c=caml_ba_create(caml_ba_kind(varr_a),0,[0,m,n]),
       sum=[0,0],
       _Eg_=m - 1 | 0,
       _Ef_=0;
      if(!(_Eg_ < 0))
       {var i=_Ef_;
        for(;;)
         {var _Ei_=n - 1 | 0,_Eh_=0;
          if(!(_Ei_ < 0))
           {var j=_Eh_;
            for(;;)
             {sum[1] = 0;
              var _El_=cdim - 1 | 0,_Ek_=0;
              if(!(_El_ < 0))
               {var k=_Ek_;
                for(;;)
                 {var
                   _En_=caml_ba_get_generic(varr_b,[0,k,j]),
                   _Eo_=caml_ba_get_generic(varr_a,[0,i,k]) * _En_;
                  sum[1] = sum[1] + _Eo_;
                  var _Ep_=k + 1 | 0;
                  if(_El_ !== k){var k=_Ep_;continue}
                  break}}
              caml_ba_set_generic(varr_c,[0,i,j],sum[1]);
              var _Em_=j + 1 | 0;
              if(_Ei_ !== j){var j=_Em_;continue}
              break}}
          var _Ej_=i + 1 | 0;
          if(_Eg_ !== i){var i=_Ej_;continue}
          break}}
      return varr_c}
    function trace(varr)
     {var dims=shape(varr);
      check_is_matrix(dims);
      var n=caml_check_bound(dims,0)[1];
      if(caml_check_bound(dims,1)[2] !== n)throw [0,Invalid_argument,_i9_];
      var sum=[0,0],_Ec_=n - 1 | 0,_Eb_=0;
      if(!(_Ec_ < 0))
       {var i=_Eb_;
        for(;;)
         {var _Ed_=caml_ba_get_generic(varr,[0,i,i]);
          sum[1] = sum[1] + _Ed_;
          var _Ee_=i + 1 | 0;
          if(_Ec_ !== i){var i=_Ee_;continue}
          break}}
      return sum[1]}
    function to_rows(varr)
     {var dims=shape(varr);
      check_is_matrix(dims);
      var m=caml_check_bound(dims,0)[1];
      return init(m,function(i){return caml_ba_slice(varr,[0,i])})}
    function of_rows(rows)
     {var
       m=rows.length - 1,
       row_dim=shape(caml_check_bound(rows,0)[1]),
       dims=append$0([0,m],row_dim),
       varr=caml_ba_create(caml_ba_kind(caml_check_bound(rows,0)[1]),0,dims),
       _D__=m - 1 | 0,
       _D9_=0;
      if(!(_D__ < 0))
       {var i=_D9_;
        for(;;)
         {var _D$_=caml_ba_slice(varr,[0,i]);
          caml_ba_blit(caml_check_bound(rows,i)[i + 1],_D$_);
          var _Ea_=i + 1 | 0;
          if(_D__ !== i){var i=_Ea_;continue}
          break}}
      return varr}
    function transpose(axis,varr)
     {var dims=shape(varr),rank=dims.length - 1;
      if(axis)
       var perm=axis[1],axis_perm=perm;
      else
       var axis_perm=init(rank,function(i){return (rank - i | 0) - 1 | 0});
      var
       new_dims=apply_perm(dims,axis_perm),
       new_varr=caml_ba_create(caml_ba_kind(varr),0,new_dims),
       ind=caml_make_vect(rank,0),
       should_stop=[0,0];
      for(;;)
       {if(should_stop[1])return new_varr;
        var _D8_=caml_ba_get_generic(varr,ind);
        caml_ba_set_generic(new_varr,apply_perm(ind,axis_perm),_D8_);
        if(1 - next_index(ind,dims)){should_stop[1] = 1;continue}
        continue}}
    function inv(varr)
     {var dims=shape(varr);
      check_is_matrix(dims);
      var n=dims[1];
      if(dims[2] !== n)return failwith(_i__);
      var
       pivot_row=caml_make_vect(n,0),
       result_varr=copy$0(varr),
       _DS_=n - 1 | 0,
       _DR_=0;
      if(!(_DS_ < 0))
       {var p=_DR_;
        for(;;)
         {var pivot_elem=caml_ba_get_generic(result_varr,[0,p,p]);
          if(caml_ba_get_generic(result_varr,[0,p,p]) == 0)failwith(_i$_);
          var _DU_=n - 1 | 0,_DT_=0;
          if(!(_DU_ < 0))
           {var j$0=_DT_;
            for(;;)
             {caml_array_set
               (pivot_row,j$0,caml_ba_get_generic(result_varr,[0,p,j$0]));
              if(j$0 !== p)
               caml_ba_set_generic
                (result_varr,
                 [0,p,j$0],
                 caml_array_get(pivot_row,j$0) / pivot_elem);
              var _D7_=j$0 + 1 | 0;
              if(_DU_ !== j$0){var j$0=_D7_;continue}
              break}}
          var _DW_=n - 1 | 0,_DV_=0;
          if(!(_DW_ < 0))
           {var i$0=_DV_;
            for(;;)
             {if(i$0 !== p)
               caml_ba_set_generic
                (result_varr,
                 [0,i$0,p],
                 caml_ba_get_generic(result_varr,[0,i$0,p]) / -pivot_elem);
              var _D6_=i$0 + 1 | 0;
              if(_DW_ !== i$0){var i$0=_D6_;continue}
              break}}
          var _DY_=n - 1 | 0,_DX_=0;
          if(!(_DY_ < 0))
           {var i=_DX_;
            for(;;)
             {var
               pivot_col_elem=caml_ba_get_generic(result_varr,[0,i,p]),
               _D1_=n - 1 | 0,
               _D0_=0;
              if(!(_D1_ < 0))
               {var j=_D0_;
                for(;;)
                 {var _D3_=i !== p?1:0,_D4_=_D3_?j !== p?1:0:_D3_;
                  if(_D4_)
                   {var
                     pivot_row_elem=caml_array_get(pivot_row,j),
                     old_val=caml_ba_get_generic(result_varr,[0,i,j]),
                     new_val=old_val + pivot_row_elem * pivot_col_elem;
                    caml_ba_set_generic(result_varr,[0,i,j],new_val)}
                  var _D5_=j + 1 | 0;
                  if(_D1_ !== j){var j=_D5_;continue}
                  break}}
              var _D2_=i + 1 | 0;
              if(_DY_ !== i){var i=_D2_;continue}
              break}}
          caml_ba_set_generic(result_varr,[0,p,p],1 / pivot_elem);
          var _DZ_=p + 1 | 0;
          if(_DS_ !== p){var p=_DZ_;continue}
          break}}
      return result_varr}
    function empty(dims){return caml_ba_create(0,0,dims)}
    function create$2(dims,value){return create$1(0,dims,value)}
    function init$1(dims,f)
     {var
       varr=caml_ba_create(0,0,dims),
       varr_flat=array1_of_genarray(flatten(varr)),
       n=numel(varr),
       _DP_=n - 1 | 0,
       _DO_=0;
      if(!(_DP_ < 0))
       {var i=_DO_;
        for(;;)
         {caml_ba_set_1(varr_flat,i,caml_call1(f,i));
          var _DQ_=i + 1 | 0;
          if(_DP_ !== i){var i=_DQ_;continue}
          break}}
      return varr}
    function zeros$0(dims){return zeros(0,dims)}
    function ones(dims){return create$1(0,dims,one$0(0))}
    function sequential(a$0,step$0,dims)
     {if(a$0)var sth=a$0[1],a=sth;else var a=0;
      if(step$0)var sth$0=step$0[1],step=sth$0;else var step=1;
      var varr=caml_ba_create(0,0,dims),count=[0,0];
      function seq_fun(x)
       {count[1] = count[1] + 1;return a + (count[1] - 1) * step}
      apply_fun(seq_fun,varr);
      return varr}
    function of_array(arr,dims)
     {var
       varr=caml_ba_create(0,0,dims),
       flat_varr=array1_of_genarray(flatten(varr)),
       n=numel(varr),
       _DM_=n - 1 | 0,
       _DL_=0;
      if(!(_DM_ < 0))
       {var i=_DL_;
        for(;;)
         {caml_ba_set_1(flat_varr,i,caml_check_bound(arr,i)[i + 1]);
          var _DN_=i + 1 | 0;
          if(_DM_ !== i){var i=_DN_;continue}
          break}}
      return varr}
    function of_arrays(arrays)
     {var
       m=arrays.length - 1,
       n=caml_check_bound(arrays,0)[1].length - 1,
       varr=caml_ba_create(0,0,[0,m,n]),
       _DG_=n - 1 | 0,
       _DF_=0;
      if(!(_DG_ < 0))
       {var i=_DF_;
        for(;;)
         {var _DI_=m - 1 | 0,_DH_=0;
          if(!(_DI_ < 0))
           {var j=_DH_;
            for(;;)
             {caml_ba_set_generic
               (varr,[0,i,j],caml_check_bound(arrays,i)[i + 1][j + 1]);
              var _DK_=j + 1 | 0;
              if(_DI_ !== j){var j=_DK_;continue}
              break}}
          var _DJ_=i + 1 | 0;
          if(_DG_ !== i){var i=_DJ_;continue}
          break}}
      return varr}
    function uniform(a$0,b$0,dims)
     {if(a$0)var sth=a$0[1],a=sth;else var a=0;
      if(b$0)var sth$0=b$0[1],b=sth$0;else var b=1;
      function uniform_gen_fun(param)
       {return a + (b - a) * float$0(rand_gen,1)}
      var varr=caml_ba_create(0,0,dims);
      apply_fun(uniform_gen_fun,varr);
      return varr}
    function bernoulli(p$0,dims)
     {if(p$0)var sth=p$0[1],p=sth;else var p=0.5;
      function bernoulli_gen_fun(param)
       {if(0 <= p)if(p <= 1)return float$0(rand_gen,1) <= p?1:0;
        throw [0,Assert_failure,_hn_]}
      var varr=caml_ba_create(0,0,dims);
      apply_fun(bernoulli_gen_fun,varr);
      return varr}
    function gaussian(mu$0,sigma$0,dims)
     {if(mu$0)var sth=mu$0[1],mu=sth;else var mu=0;
      if(sigma$0)var sth$0=sigma$0[1],sigma=sth$0;else var sigma=1;
      function gaussian_gen_fun(param)
       {return case$0[1]
                ?(case$0[1] = 0,mu + sigma * z1[1])
                :(case$0[1]
                  =
                  1,
                  u1[1]
                  =
                  float$0(rand_gen,1),
                  u2[1]
                  =
                  float$0(rand_gen,1),
                  z0[1]
                  =
                  Math.sqrt(-2 * Math.log(u1[1]))
                  *
                  Math.cos(6.28318530717958623 * u2[1]),
                  z1[1]
                  =
                  Math.sqrt(-2 * Math.log(u1[1]))
                  *
                  Math.sin(6.28318530717958623 * u2[1]),
                  mu
                  +
                  sigma
                  *
                  z0[1])}
      var varr=caml_ba_create(0,0,dims);
      apply_fun(gaussian_gen_fun,varr);
      return varr}
    function level_to_int(param)
     {switch(param)
       {case 0:return 0;
        case 1:return 1;
        case 2:return 2;
        case 3:return 3;
        default:return 4}}
    var _jb_=1;
    function info(fmt$0)
     {var _Du_=level_to_int(_jb_),match=_Du_ <= level_to_int(1)?1:0;
      if(0 === match)
       {var k=function(_DE_){return 0},fmt=fmt$0[1];
        return make_iprintf(k,oc,fmt)}
      var
       ts=unix_gettimeofday(0),
       tm=unix_localtime(ts),
       _Dv_=_d_(_ja_,_d_(s,_jc_)),
       _Dw_=1e3 * caml_modf_float(ts)[1] | 0,
       _Dx_=tm[1],
       _Dy_=tm[2],
       _Dz_=tm[3],
       _DA_=tm[4],
       _DB_=tm[5] + 1 | 0,
       _DC_=tm[6] + 1900 | 0,
       _DD_=caml_call8(sprintf(_jd_),_DC_,_DB_,_DA_,_Dz_,_Dy_,_Dx_,_Dw_,_Dv_);
      return caml_call1(fprintf(oc,_j_(_jf_,_j_(fmt$0,_je_))),_DD_)}
    function Make$0(A)
     {var
       include=Make(A),
       global_tag=include[1],
       tag=include[2],
       cmp_tag=include[3],
       reset_zero=include[4],
       primal=include[5],
       primal$0=include[6],
       zero=include[7],
       tangent=include[8],
       adjref=include[9],
       adjval=include[10],
       shape=include[11],
       row_num=include[12],
       col_num=include[13],
       numel=include[14],
       clip_by_value=include[15],
       clip_by_l2norm=include[16],
       copy_primal=include[17],
       tile=include[18],
       repeat=include[19],
       pack_arr=include[20],
       unpack_arr=include[21],
       pack_flt=include[22],
       unpack_flt=include[23],
       deep_info=include[24],
       type_info=include[25],
       error_binop=include[26],
       error_uniop=include[27],
       Maths=include[28],
       reverse_reset=include[29],
       reverse_push=include[30],
       reverse_prop=include[31],
       make_forward=include[32],
       make_reverse=include[33],
       diff=include[34],
       diff$0=include[35],
       grad=include[36],
       grad$0=include[37],
       jacobianv=include[38],
       jacobianv$0=include[39],
       jacobianTv=include[40],
       jacobianTv$0=include[41],
       jacobian=include[42],
       jacobian$0=include[43],
       gradhessian=include[44],
       gradhessian$0=include[45],
       hessian=include[46],
       hessian$0=include[47],
       gradhessianv=include[48],
       gradhessianv$0=include[49],
       hessianv=include[50],
       hessianv$0=include[51],
       laplacian=include[52],
       laplacian$0=include[53],
       Mat=include[54],
       Arr=include[55],
       traverse_trace=include[56],
       convert_terminal_output=include[57],
       convert_dot_output=include[58],
       to_trace=include[59],
       to_dot=include[60],
       pp_num=include[61];
      function calc_fans(s)
       {function prod(x)
         {var _Dt_=1;
          return fold_left$0(function(p,q){return caml_mul(p,q)},_Dt_,x)}
        var l=s.length - 1;
        if(2 === l)
         var
          fan_out=caml_check_bound(s,1)[2],
          fan_in=caml_check_bound(s,0)[1],
          fan_out$0=fan_out;
        else
         {if(2 < l)
           if(6 <= l)
            var switch$0=0;
           else
            var
             s$0=sub$1(s,0,l - 2 | 0),
             receptive=prod(s$0),
             _Dr_=l - 2 | 0,
             i=caml_mul(caml_check_bound(s,_Dr_)[_Dr_ + 1],receptive),
             _Ds_=l - 1 | 0,
             o=caml_mul(caml_check_bound(s,_Ds_)[_Ds_ + 1],receptive),
             fan_in=i,
             fan_out$0=o,
             switch$0=1;
          else
           var switch$0=0;
          if(!switch$0)var i_o=Math.sqrt(prod(s)),fan_in=i_o,fan_out$0=i_o}
        return [0,fan_in,fan_out$0]}
      function run(t,s,x)
       {var
         match=calc_fans(s),
         fan_out=match[2],
         fan_in=match[1],
         r0=Math.sqrt(1 / fan_in),
         r1=Math.sqrt(6 / (fan_in + fan_out)),
         r2=Math.sqrt(2 / (fan_in + fan_out));
        if(1 === x[0])
         if(typeof t === "number")
          switch(t)
           {case 0:return caml_call3(Arr[4],[0,-r0],[0,r0],s);
            case 1:return caml_call3(Arr[4],[0,-r1],[0,r1],s);
            case 2:return caml_call3(Arr[5],0,[0,r2],s);
            case 3:return caml_call3(Arr[4],[0,-r1],[0,r1],s);
            default:return caml_call3(Arr[5],0,[0,r0],s)}
         else
          switch(t[0])
           {case 0:var b=t[2],a=t[1];return caml_call3(Arr[4],[0,a],[0,b],s);
            case 1:
             var sigma=t[2],mu=t[1];
             return caml_call3(Arr[5],[0,mu],[0,sigma],s);
            default:var f=t[1];return caml_call1(f,s)}
        return failwith(_jg_)}
      function to_string(param)
       {if(typeof param === "number")
         switch(param)
          {case 0:return sprintf(_jh_);
           case 1:return sprintf(_ji_);
           case 2:return sprintf(_jj_);
           case 3:return sprintf(_jk_);
           default:return sprintf(_jl_)}
        else
         switch(param[0])
          {case 0:
            var b=param[2],a=param[1];return caml_call2(sprintf(_jm_),a,b);
           case 1:
            var b$0=param[2],a$0=param[1];
            return caml_call2(sprintf(_jn_),a$0,b$0);
           default:return sprintf(_jo_)}}
      function to_name(param){return _jp_}
      var Init=[0,calc_fans,run,to_string,to_name];
      function create(inputs)
       {var _Dq_=copy(inputs);return [0,copy(inputs),_Dq_]}
      function copy$0(l){return create(l[1])}
      function run$0(x,l)
       {var param=caml_call1(primal,x);
        if(1 === param[0])
         {var
           in_shape=caml_call1(Arr[8],x),
           in_shape$0=sub$1(in_shape,1,in_shape.length - 1 - 1 | 0);
          if(!caml_equal(in_shape$0,l[1]))throw [0,Assert_failure,_jr_]}
        else
         failwith(_jq_);
        return x}
      function to_string$0(l)
       {var in_str=string_of_array(0,0,0,string_of_int,l[1]);
        return caml_call1(sprintf(_js_),in_str)}
      function to_name$0(param){return _jt_}
      var Input=[0,create,copy$0,run$0,to_string$0,to_name$0];
      function create$1(activation){return [0,activation,[0],[0]]}
      function connect(out_shape,l)
       {l[2] = copy(out_shape);l[3] = copy(out_shape);return 0}
      function run_activation(x,activation)
       {if(typeof activation === "number")
         switch(activation)
          {case 0:
            var
             _Db_=caml_call1(Maths[17],x),
             _Dc_=caml_call1(Maths[56],_Db_),
             _Dd_=caml_call1(Maths[17],_Dc_),
             _De_=caml_call1(Maths[28],_Dd_),
             _Df_=caml_call1(Maths[56],x),
             _Dg_=caml_call2(Maths[4],_Df_,_De_);
            return caml_call2(Maths[6],_Dg_,_ju_);
           case 1:return caml_call1(Maths[56],x);
           case 2:return caml_call1(Maths[55],x);
           case 3:
            var
             _Dh_=caml_call2(Maths[8],_jw_,x),
             _Di_=caml_call2(Maths[4],_Dh_,_jv_),
             _Dj_=caml_call2(Maths[15],_jx_,_Di_);
            return caml_call2(Maths[16],_jy_,_Dj_);
           case 4:return caml_call2(Mat[21],Maths[60],x);
           case 5:return caml_call1(Maths[58],x);
           case 6:return caml_call1(Maths[59],x);
           case 7:return caml_call1(Maths[34],x);
           case 8:
            var _Dk_=caml_call1(Maths[56],x);
            return caml_call2(Maths[15],_Dk_,_jz_);
           default:return x}
        else
         switch(activation[0])
          {case 0:
            var
             a=activation[1],
             _Dl_=caml_call1(Maths[17],x),
             _Dm_=caml_call1(Maths[56],_Dl_),
             _Dn_=caml_call2(Maths[8],[0,a],_Dm_),
             _Do_=caml_call1(Maths[56],x);
            return caml_call2(Maths[6],_Do_,_Dn_);
           case 1:
            var a$0=activation[1],_Dp_=caml_call2(Maths[6],x,[0,a$0]);
            return caml_call1(Maths[56],_Dp_);
           default:var f=activation[1];return caml_call1(f,x)}}
      function copy$1(l){return create$1(l[1])}
      function run$1(x,l){return run_activation(x,l[1])}
      function activation_to_string(param)
       {if(typeof param === "number")
         switch(param)
          {case 0:return caml_call1(sprintf(_jB_),_jA_);
           case 1:return caml_call1(sprintf(_jD_),_jC_);
           case 2:return caml_call1(sprintf(_jF_),_jE_);
           case 3:return caml_call1(sprintf(_jH_),_jG_);
           case 4:return caml_call1(sprintf(_jJ_),_jI_);
           case 5:return caml_call1(sprintf(_jL_),_jK_);
           case 6:return caml_call1(sprintf(_jN_),_jM_);
           case 7:return caml_call1(sprintf(_jP_),_jO_);
           case 8:return caml_call1(sprintf(_jR_),_jQ_);
           default:return caml_call1(sprintf(_jT_),_jS_)}
        else
         switch(param[0])
          {case 0:var a=param[1];return caml_call2(sprintf(_jV_),_jU_,a);
           case 1:var a$0=param[1];return caml_call2(sprintf(_jX_),_jW_,a$0);
           default:return caml_call1(sprintf(_jZ_),_jY_)}}
      function to_string$1(l)
       {var
         in_str=string_of_array(0,0,0,string_of_int,l[2]),
         act_str=activation_to_string(l[1]);
        return _d_(caml_call2(sprintf(_j1_),act_str,in_str),_j0_)}
      function to_name$1(param){return _j2_}
      var
       Activation=
        [0,
         create$1,
         connect,
         run_activation,
         copy$1,
         run$1,
         activation_to_string,
         to_string$1,
         to_name$1];
      function create$2(inputs,o,init_typ)
       {if(inputs)var i=inputs[1],in_shape=[0,i];else var in_shape=[0,0];
        var _Da_=caml_call2(Mat[1],0,0);
        return [0,caml_call2(Mat[1],0,0),_Da_,init_typ,in_shape,[0,o]]}
      function connect$0(out_shape,l)
       {if(out_shape.length - 1 === l[4].length - 1)
         {var _C$_=caml_check_bound(out_shape,0)[1];
          return caml_check_bound(l[4],0)[1] = _C$_}
        throw [0,Assert_failure,_j3_]}
      function init$0(l)
       {var m=caml_check_bound(l[4],0)[1],n=caml_check_bound(l[5],0)[1];
        l[1] = caml_call3(Init[2],l[3],[0,m,n],l[1]);
        l[2] = caml_call2(Mat[2],1,n);
        return 0}
      function reset(l)
       {caml_call1(Mat[6],l[1]);return caml_call1(Mat[6],l[2])}
      function mktag(t,l)
       {l[1] = caml_call2(make_reverse,l[1],t);
        l[2] = caml_call2(make_reverse,l[2],t);
        return 0}
      function mkpar(l){return [0,l[1],l[2]]}
      function mkpri(l)
       {var _C__=caml_call1(primal,l[2]);
        return [0,caml_call1(primal,l[1]),_C__]}
      function mkadj(l)
       {var _C9_=caml_call1(adjval,l[2]);
        return [0,caml_call1(adjval,l[1]),_C9_]}
      function update(l,u)
       {l[1] = caml_call1(primal$0,caml_check_bound(u,0)[1]);
        l[2] = caml_call1(primal$0,caml_check_bound(u,1)[2]);
        return 0}
      function copy$2(l)
       {var _C8_=l[3],l$0=create$2(0,caml_check_bound(l[5],0)[1],_C8_);
        update(l$0,map$0(copy_primal,mkpri(l)));
        return l$0}
      function run$2(x,l)
       {var _C6_=l[2],_C7_=caml_call2(Maths[49],x,l[1]);
        return caml_call2(Maths[4],_C7_,_C6_)}
      function to_string$2(l)
       {var
         wn=caml_check_bound(l[5],0)[1],
         wm=caml_check_bound(l[4],0)[1],
         bn=caml_check_bound(l[5],0)[1],
         _CZ_=_d_(caml_call2(sprintf(_j5_),1,bn),_j4_),
         _C0_=_d_(caml_call2(sprintf(_j6_),wm,wn),_CZ_),
         _C1_=_d_(caml_call1(sprintf(_j7_),caml_mul(wm,wn) + bn | 0),_C0_),
         _C2_=caml_call1(Init[3],l[3]),
         _C3_=_d_(caml_call1(sprintf(_j8_),_C2_),_C1_),
         _C4_=caml_check_bound(l[5],0)[1],
         _C5_=caml_check_bound(l[4],0)[1];
        return _d_(caml_call2(sprintf(_j9_),_C5_,_C4_),_C3_)}
      function to_name$2(param){return _j__}
      var
       Linear=
        [0,
         create$2,
         connect$0,
         init$0,
         reset,
         mktag,
         mkpar,
         mkpri,
         mkadj,
         update,
         copy$2,
         run$2,
         to_string$2,
         to_name$2];
      function create$3(inputs,o,init_typ)
       {if(inputs)var i=inputs[1],in_shape=[0,i];else var in_shape=[0,0];
        return [0,caml_call2(Mat[1],0,0),init_typ,in_shape,[0,o]]}
      function connect$1(out_shape,l)
       {if(out_shape.length - 1 === l[3].length - 1)
         {var _CY_=caml_check_bound(out_shape,0)[1];
          return caml_check_bound(l[3],0)[1] = _CY_}
        throw [0,Assert_failure,_j$_]}
      function init$1(l)
       {var m=caml_check_bound(l[3],0)[1],n=caml_check_bound(l[4],0)[1];
        l[1] = caml_call3(Init[2],l[2],[0,m,n],l[1]);
        return 0}
      function reset$0(l){return caml_call1(Mat[6],l[1])}
      function mktag$0(t,l){l[1] = caml_call2(make_reverse,l[1],t);return 0}
      function mkpar$0(l){return [0,l[1]]}
      function mkpri$0(l){return [0,caml_call1(primal,l[1])]}
      function mkadj$0(l){return [0,caml_call1(adjval,l[1])]}
      function update$0(l,u)
       {l[1] = caml_call1(primal$0,caml_check_bound(u,0)[1]);return 0}
      function copy$3(l)
       {var _CX_=l[2],l$0=create$3(0,caml_check_bound(l[4],0)[1],_CX_);
        update$0(l$0,map$0(copy_primal,mkpri$0(l)));
        return l$0}
      function run$3(x,l){return caml_call2(Maths[49],x,l[1])}
      function to_string$3(l)
       {var
         wn=caml_check_bound(l[4],0)[1],
         wm=caml_check_bound(l[3],0)[1],
         _CR_=_d_(caml_call2(sprintf(_kb_),wm,wn),_ka_),
         _CS_=_d_(caml_call1(sprintf(_kc_),caml_mul(wm,wn)),_CR_),
         _CT_=caml_call1(Init[3],l[2]),
         _CU_=_d_(caml_call1(sprintf(_kd_),_CT_),_CS_),
         _CV_=caml_check_bound(l[4],0)[1],
         _CW_=caml_check_bound(l[3],0)[1];
        return _d_(caml_call2(sprintf(_ke_),_CW_,_CV_),_CU_)}
      function to_name$3(param){return _kf_}
      var
       LinearNoBias=
        [0,
         create$3,
         connect$1,
         init$1,
         reset$0,
         mktag$0,
         mkpar$0,
         mkpri$0,
         mkadj$0,
         update$0,
         copy$3,
         run$3,
         to_string$3,
         to_name$3];
      function create$4(time_steps,inputs,hiddens,o,act,init_typ)
       {if(inputs)var i=inputs[1],i$0=i;else var i$0=0;
        if(time_steps)var i$1=time_steps[1],t=i$1;else var t=0;
        var
         _CM_=caml_call2(Mat[1],0,hiddens),
         _CN_=caml_call2(Mat[1],1,o),
         _CO_=caml_call2(Mat[1],1,hiddens),
         _CP_=caml_call2(Mat[1],hiddens,o),
         _CQ_=caml_call2(Mat[1],0,hiddens);
        return [0,
                caml_call2(Mat[1],hiddens,hiddens),
                _CQ_,
                _CP_,
                _CO_,
                _CN_,
                _CM_,
                hiddens,
                act,
                init_typ,
                [0,t,i$0],
                [0,o]]}
      function connect$2(out_shape,l)
       {if(out_shape.length - 1 === l[10].length - 1)
         {var _CK_=caml_check_bound(out_shape,0)[1];
          caml_check_bound(l[10],0)[1] = _CK_;
          var _CL_=caml_check_bound(out_shape,1)[2];
          return caml_check_bound(l[10],1)[2] = _CL_}
        throw [0,Assert_failure,_kg_]}
      function init$2(l)
       {var
         i=caml_check_bound(l[10],1)[2],
         o=caml_check_bound(l[11],0)[1],
         h=l[7];
        l[1] = caml_call3(Init[2],l[9],[0,h,h],l[1]);
        l[2] = caml_call3(Init[2],l[9],[0,i,h],l[2]);
        l[3] = caml_call3(Init[2],l[9],[0,h,o],l[3]);
        l[4] = caml_call2(Mat[2],1,h);
        l[5] = caml_call2(Mat[2],1,o);
        return 0}
      function reset$1(l)
       {caml_call1(Mat[6],l[1]);
        caml_call1(Mat[6],l[2]);
        caml_call1(Mat[6],l[3]);
        caml_call1(Mat[6],l[4]);
        return caml_call1(Mat[6],l[5])}
      function mktag$1(t,l)
       {l[1] = caml_call2(make_reverse,l[1],t);
        l[2] = caml_call2(make_reverse,l[2],t);
        l[3] = caml_call2(make_reverse,l[3],t);
        l[4] = caml_call2(make_reverse,l[4],t);
        l[5] = caml_call2(make_reverse,l[5],t);
        return 0}
      function mkpar$1(l){return [0,l[1],l[2],l[3],l[4],l[5]]}
      function mkpri$1(l)
       {var
         _CG_=caml_call1(primal,l[5]),
         _CH_=caml_call1(primal,l[4]),
         _CI_=caml_call1(primal,l[3]),
         _CJ_=caml_call1(primal,l[2]);
        return [0,caml_call1(primal,l[1]),_CJ_,_CI_,_CH_,_CG_]}
      function mkadj$1(l)
       {var
         _CC_=caml_call1(adjval,l[5]),
         _CD_=caml_call1(adjval,l[4]),
         _CE_=caml_call1(adjval,l[3]),
         _CF_=caml_call1(adjval,l[2]);
        return [0,caml_call1(adjval,l[1]),_CF_,_CE_,_CD_,_CC_]}
      function update$1(l,u)
       {l[1] = caml_call1(primal$0,caml_check_bound(u,0)[1]);
        l[2] = caml_call1(primal$0,caml_check_bound(u,1)[2]);
        l[3] = caml_call1(primal$0,caml_check_bound(u,2)[3]);
        l[4] = caml_call1(primal$0,caml_check_bound(u,3)[4]);
        l[5] = caml_call1(primal$0,caml_check_bound(u,4)[5]);
        return 0}
      function copy$4(l)
       {var
         _Cz_=l[9],
         _CA_=l[8],
         _CB_=caml_check_bound(l[11],0)[1],
         l$0=create$4(0,0,l[7],_CB_,_CA_,_Cz_);
        update$1(l$0,map$0(copy_primal,mkpri$1(l)));
        return l$0}
      function run$4(x,l)
       {var s=caml_call1(shape,x),_Cm_=l[7],_Cn_=caml_check_bound(s,0)[1];
        l[6] = caml_call2(Mat[2],_Cn_,_Cm_);
        var _Cp_=caml_check_bound(l[10],0)[1] - 1 | 0,_Co_=0;
        if(!(_Cp_ < 0))
         {var i=_Co_;
          for(;;)
           {var
             t=caml_call2(Maths[44],[0,0,[0,[0,i,0],_kh_]],x),
             _Cs_=caml_check_bound(s,2)[3],
             _Ct_=[0,caml_check_bound(s,0)[1],_Cs_],
             t$0=caml_call2(Maths[75],t,_Ct_),
             _Cu_=l[4],
             _Cv_=caml_call2(Maths[49],t$0,l[2]),
             _Cw_=caml_call2(Maths[49],l[6],l[1]),
             _Cx_=caml_call2(Maths[4],_Cw_,_Cv_),
             x$0=caml_call2(Maths[4],_Cx_,_Cu_);
            l[6] = caml_call2(Activation[3],x$0,l[8]);
            var _Cy_=i + 1 | 0;
            if(_Cp_ !== i){var i=_Cy_;continue}
            break}}
        var _Cq_=l[5],_Cr_=caml_call2(Maths[49],l[6],l[3]);
        return caml_call2(Maths[4],_Cr_,_Cq_)}
      function to_string$4(l)
       {var
         t=caml_check_bound(l[10],0)[1],
         i=caml_check_bound(l[10],1)[2],
         o=caml_check_bound(l[11],0)[1],
         h=l[7],
         _Cc_=caml_call1(Activation[6],l[8]),
         _Cd_=caml_call1(sprintf(_ki_),_Cc_),
         _Ce_=_d_(caml_call2(sprintf(_kj_),1,o),_Cd_),
         _Cf_=_d_(caml_call2(sprintf(_kk_),1,h),_Ce_),
         _Cg_=_d_(caml_call2(sprintf(_kl_),h,o),_Cf_),
         _Ch_=_d_(caml_call2(sprintf(_km_),i,h),_Cg_),
         _Ci_=_d_(caml_call2(sprintf(_kn_),h,h),_Ch_),
         _Cj_=
          _d_
           (caml_call1
             (sprintf(_ko_),
              (((caml_mul(h,h) + caml_mul(i,h) | 0) + caml_mul(h,o) | 0)
               +
               h
               |
               0)
              +
              o
              |
              0),
            _Ci_),
         _Ck_=caml_call1(Init[3],l[9]),
         _Cl_=_d_(caml_call1(sprintf(_kp_),_Ck_),_Cj_);
        return _d_(caml_call3(sprintf(_kq_),t,i,o),_Cl_)}
      function to_name$4(param){return _kr_}
      var
       Recurrent=
        [0,
         create$4,
         connect$2,
         init$2,
         reset$1,
         mktag$1,
         mkpar$1,
         mkpri$1,
         mkadj$1,
         update$1,
         copy$4,
         run$4,
         to_string$4,
         to_name$4];
      function create$5(time_steps,inputs,o,init_typ)
       {if(inputs)var i=inputs[1],i$0=i;else var i$0=0;
        if(time_steps)var i$1=time_steps[1],t=i$1;else var t=0;
        var
         _B1_=caml_call2(Mat[1],0,o),
         _B2_=caml_call2(Mat[1],0,o),
         _B3_=caml_call2(Mat[1],1,o),
         _B4_=caml_call2(Mat[1],1,o),
         _B5_=caml_call2(Mat[1],1,o),
         _B6_=caml_call2(Mat[1],1,o),
         _B7_=caml_call2(Mat[1],o,o),
         _B8_=caml_call2(Mat[1],0,o),
         _B9_=caml_call2(Mat[1],o,o),
         _B__=caml_call2(Mat[1],0,o),
         _B$_=caml_call2(Mat[1],o,o),
         _Ca_=caml_call2(Mat[1],0,o),
         _Cb_=caml_call2(Mat[1],o,o);
        return [0,
                caml_call2(Mat[1],0,o),
                _Cb_,
                _Ca_,
                _B$_,
                _B__,
                _B9_,
                _B8_,
                _B7_,
                _B6_,
                _B5_,
                _B4_,
                _B3_,
                _B2_,
                _B1_,
                init_typ,
                [0,t,i$0],
                [0,o]]}
      function connect$3(out_shape,l)
       {if(out_shape.length - 1 === l[16].length - 1)
         {var _BZ_=caml_check_bound(out_shape,0)[1];
          caml_check_bound(l[16],0)[1] = _BZ_;
          var _B0_=caml_check_bound(out_shape,1)[2];
          return caml_check_bound(l[16],1)[2] = _B0_}
        throw [0,Assert_failure,_ks_]}
      function init$3(l)
       {var i=caml_check_bound(l[16],1)[2],o=caml_check_bound(l[17],0)[1];
        l[1] = caml_call3(Init[2],l[15],[0,i,o],l[1]);
        l[2] = caml_call3(Init[2],l[15],[0,o,o],l[2]);
        l[3] = caml_call3(Init[2],l[15],[0,i,o],l[3]);
        l[4] = caml_call3(Init[2],l[15],[0,o,o],l[4]);
        l[5] = caml_call3(Init[2],l[15],[0,i,o],l[5]);
        l[6] = caml_call3(Init[2],l[15],[0,o,o],l[6]);
        l[7] = caml_call3(Init[2],l[15],[0,i,o],l[7]);
        l[8] = caml_call3(Init[2],l[15],[0,o,o],l[8]);
        l[9] = caml_call2(Mat[2],1,o);
        l[10] = caml_call2(Mat[2],1,o);
        l[11] = caml_call2(Mat[2],1,o);
        l[12] = caml_call2(Mat[2],1,o);
        return 0}
      function reset$2(l)
       {caml_call1(Mat[6],l[1]);
        caml_call1(Mat[6],l[2]);
        caml_call1(Mat[6],l[3]);
        caml_call1(Mat[6],l[4]);
        caml_call1(Mat[6],l[5]);
        caml_call1(Mat[6],l[6]);
        caml_call1(Mat[6],l[7]);
        caml_call1(Mat[6],l[8]);
        caml_call1(Mat[6],l[9]);
        caml_call1(Mat[6],l[10]);
        caml_call1(Mat[6],l[11]);
        return caml_call1(Mat[6],l[12])}
      function mktag$2(t,l)
       {l[1] = caml_call2(make_reverse,l[1],t);
        l[2] = caml_call2(make_reverse,l[2],t);
        l[3] = caml_call2(make_reverse,l[3],t);
        l[4] = caml_call2(make_reverse,l[4],t);
        l[5] = caml_call2(make_reverse,l[5],t);
        l[6] = caml_call2(make_reverse,l[6],t);
        l[7] = caml_call2(make_reverse,l[7],t);
        l[8] = caml_call2(make_reverse,l[8],t);
        l[9] = caml_call2(make_reverse,l[9],t);
        l[10] = caml_call2(make_reverse,l[10],t);
        l[11] = caml_call2(make_reverse,l[11],t);
        l[12] = caml_call2(make_reverse,l[12],t);
        return 0}
      function mkpar$2(l)
       {return [0,
                l[1],
                l[2],
                l[3],
                l[4],
                l[5],
                l[6],
                l[7],
                l[8],
                l[9],
                l[10],
                l[11],
                l[12]]}
      function mkpri$2(l)
       {var
         _BO_=caml_call1(primal,l[12]),
         _BP_=caml_call1(primal,l[11]),
         _BQ_=caml_call1(primal,l[10]),
         _BR_=caml_call1(primal,l[9]),
         _BS_=caml_call1(primal,l[8]),
         _BT_=caml_call1(primal,l[7]),
         _BU_=caml_call1(primal,l[6]),
         _BV_=caml_call1(primal,l[5]),
         _BW_=caml_call1(primal,l[4]),
         _BX_=caml_call1(primal,l[3]),
         _BY_=caml_call1(primal,l[2]);
        return [0,
                caml_call1(primal,l[1]),
                _BY_,
                _BX_,
                _BW_,
                _BV_,
                _BU_,
                _BT_,
                _BS_,
                _BR_,
                _BQ_,
                _BP_,
                _BO_]}
      function mkadj$2(l)
       {var
         _BD_=caml_call1(adjval,l[12]),
         _BE_=caml_call1(adjval,l[11]),
         _BF_=caml_call1(adjval,l[10]),
         _BG_=caml_call1(adjval,l[9]),
         _BH_=caml_call1(adjval,l[8]),
         _BI_=caml_call1(adjval,l[7]),
         _BJ_=caml_call1(adjval,l[6]),
         _BK_=caml_call1(adjval,l[5]),
         _BL_=caml_call1(adjval,l[4]),
         _BM_=caml_call1(adjval,l[3]),
         _BN_=caml_call1(adjval,l[2]);
        return [0,
                caml_call1(adjval,l[1]),
                _BN_,
                _BM_,
                _BL_,
                _BK_,
                _BJ_,
                _BI_,
                _BH_,
                _BG_,
                _BF_,
                _BE_,
                _BD_]}
      function update$2(l,u)
       {l[1] = caml_call1(primal$0,caml_check_bound(u,0)[1]);
        l[2] = caml_call1(primal$0,caml_check_bound(u,1)[2]);
        l[3] = caml_call1(primal$0,caml_check_bound(u,2)[3]);
        l[4] = caml_call1(primal$0,caml_check_bound(u,3)[4]);
        l[5] = caml_call1(primal$0,caml_check_bound(u,4)[5]);
        l[6] = caml_call1(primal$0,caml_check_bound(u,5)[6]);
        l[7] = caml_call1(primal$0,caml_check_bound(u,6)[7]);
        l[8] = caml_call1(primal$0,caml_check_bound(u,7)[8]);
        l[9] = caml_call1(primal$0,caml_check_bound(u,8)[9]);
        l[10] = caml_call1(primal$0,caml_check_bound(u,9)[10]);
        l[11] = caml_call1(primal$0,caml_check_bound(u,10)[11]);
        l[12] = caml_call1(primal$0,caml_check_bound(u,11)[12]);
        return 0}
      function copy$5(l)
       {var _BC_=l[15],l$0=create$5(0,0,caml_check_bound(l[17],0)[1],_BC_);
        update$2(l$0,map$0(copy_primal,mkpri$2(l)));
        return l$0}
      function run$5(x,l)
       {var
         s=caml_call1(shape,x),
         _A8_=caml_check_bound(l[17],0)[1],
         _A9_=caml_check_bound(s,0)[1];
        l[14] = caml_call2(Mat[2],_A9_,_A8_);
        var _A__=caml_check_bound(l[17],0)[1],_A$_=caml_check_bound(s,0)[1];
        l[13] = caml_call2(Mat[2],_A$_,_A__);
        var _Bb_=caml_check_bound(l[16],0)[1] - 1 | 0,_Ba_=0;
        if(!(_Bb_ < 0))
         {var i=_Ba_;
          for(;;)
           {var
             t=caml_call2(Maths[44],[0,0,[0,[0,i,0],_kt_]],x),
             _Bc_=caml_check_bound(s,2)[3],
             _Bd_=[0,caml_check_bound(s,0)[1],_Bc_],
             t$0=caml_call2(Maths[75],t,_Bd_),
             _Be_=l[9],
             _Bf_=caml_call2(Maths[49],l[14],l[2]),
             _Bg_=caml_call2(Maths[49],t$0,l[1]),
             _Bh_=caml_call2(Maths[4],_Bg_,_Bf_),
             _Bi_=caml_call2(Maths[4],_Bh_,_Be_),
             i$0=caml_call1(Maths[55],_Bi_),
             _Bj_=l[10],
             _Bk_=caml_call2(Maths[49],l[14],l[4]),
             _Bl_=caml_call2(Maths[49],t$0,l[3]),
             _Bm_=caml_call2(Maths[4],_Bl_,_Bk_),
             _Bn_=caml_call2(Maths[4],_Bm_,_Bj_),
             c=caml_call1(Maths[34],_Bn_),
             _Bo_=l[11],
             _Bp_=caml_call2(Maths[49],l[14],l[6]),
             _Bq_=caml_call2(Maths[49],t$0,l[5]),
             _Br_=caml_call2(Maths[4],_Bq_,_Bp_),
             _Bs_=caml_call2(Maths[4],_Br_,_Bo_),
             f=caml_call1(Maths[55],_Bs_),
             _Bt_=caml_call2(Maths[8],f,l[13]),
             _Bu_=caml_call2(Maths[8],i$0,c);
            l[13] = caml_call2(Maths[4],_Bu_,_Bt_);
            var
             _Bv_=l[12],
             _Bw_=caml_call2(Maths[49],l[14],l[8]),
             _Bx_=caml_call2(Maths[49],t$0,l[7]),
             _By_=caml_call2(Maths[4],_Bx_,_Bw_),
             _Bz_=caml_call2(Maths[4],_By_,_Bv_),
             o=caml_call1(Maths[55],_Bz_),
             _BA_=caml_call1(Maths[34],l[13]);
            l[14] = caml_call2(Maths[8],o,_BA_);
            var _BB_=i + 1 | 0;
            if(_Bb_ !== i){var i=_BB_;continue}
            break}}
        return l[14]}
      function to_string$5(l)
       {var
         t=caml_check_bound(l[16],0)[1],
         i=caml_check_bound(l[16],1)[2],
         o=caml_check_bound(l[17],0)[1],
         _AT_=_d_(caml_call2(sprintf(_kv_),1,o),_ku_),
         _AU_=_d_(caml_call2(sprintf(_kw_),1,o),_AT_),
         _AV_=_d_(caml_call2(sprintf(_kx_),1,o),_AU_),
         _AW_=_d_(caml_call2(sprintf(_ky_),1,o),_AV_),
         _AX_=_d_(caml_call2(sprintf(_kz_),o,o),_AW_),
         _AY_=_d_(caml_call2(sprintf(_kA_),i,o),_AX_),
         _AZ_=_d_(caml_call2(sprintf(_kB_),o,o),_AY_),
         _A0_=_d_(caml_call2(sprintf(_kC_),i,o),_AZ_),
         _A1_=_d_(caml_call2(sprintf(_kD_),o,o),_A0_),
         _A2_=_d_(caml_call2(sprintf(_kE_),i,o),_A1_),
         _A3_=_d_(caml_call2(sprintf(_kF_),o,o),_A2_),
         _A4_=_d_(caml_call2(sprintf(_kG_),i,o),_A3_),
         _A5_=
          _d_
           (caml_call1
             (sprintf(_kH_),
              ((((((((((caml_mul(i,o) + caml_mul(o,o) | 0)
                       +
                       caml_mul(i,o)
                       |
                       0)
                      +
                      caml_mul(o,o)
                      |
                      0)
                     +
                     caml_mul(i,o)
                     |
                     0)
                    +
                    caml_mul(o,o)
                    |
                    0)
                   +
                   caml_mul(i,o)
                   |
                   0)
                  +
                  caml_mul(o,o)
                  |
                  0)
                 +
                 o
                 |
                 0)
                +
                o
                |
                0)
               +
               o
               |
               0)
              +
              o
              |
              0),
            _A4_),
         _A6_=caml_call1(Init[3],l[15]),
         _A7_=_d_(caml_call1(sprintf(_kI_),_A6_),_A5_);
        return _d_(caml_call3(sprintf(_kJ_),i,t,o),_A7_)}
      function to_name$5(param){return _kK_}
      var
       LSTM=
        [0,
         create$5,
         connect$3,
         init$3,
         reset$2,
         mktag$2,
         mkpar$2,
         mkpri$2,
         mkadj$2,
         update$2,
         copy$5,
         run$5,
         to_string$5,
         to_name$5];
      function create$6(time_steps,inputs,o,init_typ)
       {if(inputs)var i=inputs[1],i$0=i;else var i$0=0;
        if(time_steps)var i$1=time_steps[1],t=i$1;else var t=0;
        var
         _AK_=caml_call2(Mat[1],0,o),
         _AL_=caml_call2(Mat[1],1,o),
         _AM_=caml_call2(Mat[1],1,o),
         _AN_=caml_call2(Mat[1],1,o),
         _AO_=caml_call2(Mat[1],o,o),
         _AP_=caml_call2(Mat[1],0,o),
         _AQ_=caml_call2(Mat[1],o,o),
         _AR_=caml_call2(Mat[1],0,o),
         _AS_=caml_call2(Mat[1],o,o);
        return [0,
                caml_call2(Mat[1],0,o),
                _AS_,
                _AR_,
                _AQ_,
                _AP_,
                _AO_,
                _AN_,
                _AM_,
                _AL_,
                _AK_,
                init_typ,
                [0,t,i$0],
                [0,o]]}
      function connect$4(out_shape,l)
       {if(out_shape.length - 1 === l[12].length - 1)
         {var _AI_=caml_check_bound(out_shape,0)[1];
          caml_check_bound(l[12],0)[1] = _AI_;
          var _AJ_=caml_check_bound(out_shape,1)[2];
          return caml_check_bound(l[12],1)[2] = _AJ_}
        throw [0,Assert_failure,_kL_]}
      function init$4(l)
       {var i=caml_check_bound(l[12],1)[2],o=caml_check_bound(l[13],0)[1];
        l[1] = caml_call3(Init[2],l[11],[0,i,o],l[1]);
        l[2] = caml_call3(Init[2],l[11],[0,o,o],l[2]);
        l[3] = caml_call3(Init[2],l[11],[0,i,o],l[3]);
        l[4] = caml_call3(Init[2],l[11],[0,o,o],l[4]);
        l[5] = caml_call3(Init[2],l[11],[0,i,o],l[5]);
        l[6] = caml_call3(Init[2],l[11],[0,o,o],l[6]);
        l[7] = caml_call2(Mat[2],1,o);
        l[8] = caml_call2(Mat[2],1,o);
        l[9] = caml_call2(Mat[2],1,o);
        return 0}
      function reset$3(l)
       {caml_call1(Mat[6],l[1]);
        caml_call1(Mat[6],l[2]);
        caml_call1(Mat[6],l[3]);
        caml_call1(Mat[6],l[4]);
        caml_call1(Mat[6],l[5]);
        caml_call1(Mat[6],l[6]);
        caml_call1(Mat[6],l[7]);
        caml_call1(Mat[6],l[8]);
        return caml_call1(Mat[6],l[9])}
      function mktag$3(t,l)
       {l[1] = caml_call2(make_reverse,l[1],t);
        l[2] = caml_call2(make_reverse,l[2],t);
        l[3] = caml_call2(make_reverse,l[3],t);
        l[4] = caml_call2(make_reverse,l[4],t);
        l[5] = caml_call2(make_reverse,l[5],t);
        l[6] = caml_call2(make_reverse,l[6],t);
        l[7] = caml_call2(make_reverse,l[7],t);
        l[8] = caml_call2(make_reverse,l[8],t);
        l[9] = caml_call2(make_reverse,l[9],t);
        return 0}
      function mkpar$3(l)
       {return [0,l[1],l[2],l[3],l[4],l[5],l[6],l[7],l[8],l[9]]}
      function mkpri$3(l)
       {var
         _AA_=caml_call1(primal,l[9]),
         _AB_=caml_call1(primal,l[8]),
         _AC_=caml_call1(primal,l[7]),
         _AD_=caml_call1(primal,l[6]),
         _AE_=caml_call1(primal,l[5]),
         _AF_=caml_call1(primal,l[4]),
         _AG_=caml_call1(primal,l[3]),
         _AH_=caml_call1(primal,l[2]);
        return [0,
                caml_call1(primal,l[1]),
                _AH_,
                _AG_,
                _AF_,
                _AE_,
                _AD_,
                _AC_,
                _AB_,
                _AA_]}
      function mkadj$3(l)
       {var
         _As_=caml_call1(adjval,l[9]),
         _At_=caml_call1(adjval,l[8]),
         _Au_=caml_call1(adjval,l[7]),
         _Av_=caml_call1(adjval,l[6]),
         _Aw_=caml_call1(adjval,l[5]),
         _Ax_=caml_call1(adjval,l[4]),
         _Ay_=caml_call1(adjval,l[3]),
         _Az_=caml_call1(adjval,l[2]);
        return [0,
                caml_call1(adjval,l[1]),
                _Az_,
                _Ay_,
                _Ax_,
                _Aw_,
                _Av_,
                _Au_,
                _At_,
                _As_]}
      function update$3(l,u)
       {l[1] = caml_call1(primal$0,caml_check_bound(u,0)[1]);
        l[2] = caml_call1(primal$0,caml_check_bound(u,1)[2]);
        l[3] = caml_call1(primal$0,caml_check_bound(u,2)[3]);
        l[4] = caml_call1(primal$0,caml_check_bound(u,3)[4]);
        l[5] = caml_call1(primal$0,caml_check_bound(u,4)[5]);
        l[6] = caml_call1(primal$0,caml_check_bound(u,5)[6]);
        l[7] = caml_call1(primal$0,caml_check_bound(u,6)[7]);
        l[8] = caml_call1(primal$0,caml_check_bound(u,7)[8]);
        l[9] = caml_call1(primal$0,caml_check_bound(u,8)[9]);
        return 0}
      function copy$6(l)
       {var _Ar_=l[11],l$0=create$6(0,0,caml_check_bound(l[13],0)[1],_Ar_);
        update$3(l$0,map$0(copy_primal,mkpri$3(l)));
        return l$0}
      function run$6(x,l)
       {var
         s=caml_call1(shape,x),
         _z4_=caml_check_bound(l[13],0)[1],
         _z5_=caml_check_bound(s,0)[1];
        l[10] = caml_call2(Mat[2],_z5_,_z4_);
        var _z7_=caml_check_bound(l[12],0)[1] - 1 | 0,_z6_=0;
        if(!(_z7_ < 0))
         {var i=_z6_;
          for(;;)
           {var
             t=caml_call2(Maths[44],[0,0,[0,[0,i,0],_kM_]],x),
             _z8_=caml_check_bound(s,2)[3],
             _z9_=[0,caml_check_bound(s,0)[1],_z8_],
             t$0=caml_call2(Maths[75],t,_z9_),
             _z__=l[7],
             _z$_=caml_call2(Maths[49],l[10],l[2]),
             _Aa_=caml_call2(Maths[49],t$0,l[1]),
             _Ab_=caml_call2(Maths[4],_Aa_,_z$_),
             _Ac_=caml_call2(Maths[4],_Ab_,_z__),
             z=caml_call1(Maths[55],_Ac_),
             _Ad_=l[8],
             _Ae_=caml_call2(Maths[49],l[10],l[4]),
             _Af_=caml_call2(Maths[49],t$0,l[3]),
             _Ag_=caml_call2(Maths[4],_Af_,_Ae_),
             _Ah_=caml_call2(Maths[4],_Ag_,_Ad_),
             r=caml_call1(Maths[55],_Ah_),
             _Ai_=l[6],
             _Aj_=caml_call2(Maths[8],l[10],r),
             _Ak_=caml_call2(Maths[49],_Aj_,_Ai_),
             _Al_=caml_call2(Maths[49],t$0,l[5]),
             _Am_=caml_call2(Maths[4],_Al_,_Ak_),
             h=caml_call1(Maths[34],_Am_),
             _An_=caml_call2(Maths[8],z,l[10]),
             _Ao_=caml_call2(Maths[6],_kN_,z),
             _Ap_=caml_call2(Maths[8],_Ao_,h);
            l[10] = caml_call2(Maths[4],_Ap_,_An_);
            var _Aq_=i + 1 | 0;
            if(_z7_ !== i){var i=_Aq_;continue}
            break}}
        return l[10]}
      function to_string$6(l)
       {var
         t=caml_check_bound(l[12],0)[1],
         i=caml_check_bound(l[12],1)[2],
         o=caml_check_bound(l[13],0)[1],
         _zS_=_d_(caml_call2(sprintf(_kP_),1,o),_kO_),
         _zT_=_d_(caml_call2(sprintf(_kQ_),1,o),_zS_),
         _zU_=_d_(caml_call2(sprintf(_kR_),1,o),_zT_),
         _zV_=_d_(caml_call2(sprintf(_kS_),o,o),_zU_),
         _zW_=_d_(caml_call2(sprintf(_kT_),i,o),_zV_),
         _zX_=_d_(caml_call2(sprintf(_kU_),o,o),_zW_),
         _zY_=_d_(caml_call2(sprintf(_kV_),i,o),_zX_),
         _zZ_=_d_(caml_call2(sprintf(_kW_),o,o),_zY_),
         _z0_=_d_(caml_call2(sprintf(_kX_),i,o),_zZ_),
         _z1_=
          _d_
           (caml_call1
             (sprintf(_kY_),
              (((((((caml_mul(i,o) + caml_mul(o,o) | 0) + caml_mul(i,o) | 0)
                   +
                   caml_mul(o,o)
                   |
                   0)
                  +
                  caml_mul(i,o)
                  |
                  0)
                 +
                 caml_mul(o,o)
                 |
                 0)
                +
                o
                |
                0)
               +
               o
               |
               0)
              +
              o
              |
              0),
            _z0_),
         _z2_=caml_call1(Init[3],l[11]),
         _z3_=_d_(caml_call1(sprintf(_kZ_),_z2_),_z1_);
        return _d_(caml_call3(sprintf(_k0_),t,i,o),_z3_)}
      function to_name$6(param){return _k1_}
      var
       GRU=
        [0,
         create$6,
         connect$4,
         init$4,
         reset$3,
         mktag$3,
         mkpar$3,
         mkpri$3,
         mkadj$3,
         update$3,
         copy$6,
         run$6,
         to_string$6,
         to_name$6];
      function create$7(inputs,padding,kernel,stride,init_typ)
       {var
         o=caml_check_bound(kernel,2)[3],
         i=caml_check_bound(kernel,1)[2],
         h=caml_check_bound(kernel,0)[1];
        if(inputs)
         {var a=inputs[1];
          if(i !== caml_check_bound(a,1)[2])throw [0,Assert_failure,_k2_];
          var in_shape=a}
        else
         var in_shape=[0,0,i];
        var _zR_=caml_call1(Arr[1],[0,o]);
        return [0,
                caml_call1(Arr[1],[0,h,i,o]),
                _zR_,
                kernel,
                stride,
                padding,
                init_typ,
                in_shape,
                [0,0,o]]}
      function connect$5(out_shape,l)
       {if(out_shape.length - 1 === l[7].length - 1)
         {var _zM_=caml_check_bound(l[7],1)[2];
          if(caml_check_bound(out_shape,1)[2] === _zM_)
           {var _zN_=caml_check_bound(out_shape,0)[1];
            caml_check_bound(l[7],0)[1] = _zN_;
            var
             _zO_=caml_check_bound(l[4],0)[1],
             _zP_=caml_check_bound(l[3],0)[1],
             _zQ_=caml_check_bound(l[7],0)[1],
             out_cols=calc_conv1d_output_shape(l[5],_zQ_,_zP_,_zO_);
            return caml_check_bound(l[8],0)[1] = out_cols}
          throw [0,Assert_failure,_k3_]}
        throw [0,Assert_failure,_k4_]}
      function init$5(l)
       {l[1] = caml_call3(Init[2],l[6],l[3],l[1]);
        var _zL_=caml_call1(Arr[8],l[2]);
        l[2] = caml_call1(Arr[2],_zL_);
        return 0}
      function reset$4(l)
       {caml_call1(Arr[6],l[1]);return caml_call1(Arr[6],l[2])}
      function mktag$4(t,l)
       {l[1] = caml_call2(make_reverse,l[1],t);
        l[2] = caml_call2(make_reverse,l[2],t);
        return 0}
      function mkpar$4(l){return [0,l[1],l[2]]}
      function mkpri$4(l)
       {var _zK_=caml_call1(primal,l[2]);
        return [0,caml_call1(primal,l[1]),_zK_]}
      function mkadj$4(l)
       {var _zJ_=caml_call1(adjval,l[2]);
        return [0,caml_call1(adjval,l[1]),_zJ_]}
      function update$4(l,u)
       {l[1] = caml_call1(primal$0,caml_check_bound(u,0)[1]);
        l[2] = caml_call1(primal$0,caml_check_bound(u,1)[2]);
        return 0}
      function copy$7(l)
       {var l$0=create$7(0,l[5],l[3],l[4],l[6]);
        update$4(l$0,map$0(copy_primal,mkpri$4(l)));
        return l$0}
      function run$7(x,l)
       {var _zH_=l[2],_zI_=caml_call4(Maths[66],[0,l[5]],x,l[1],l[4]);
        return caml_call2(Maths[4],_zI_,_zH_)}
      function to_string$7(l)
       {var
         ws=caml_call1(Arr[8],l[1]),
         bn=caml_call1(Arr[8],l[2]),
         in_str=string_of_array(0,0,0,string_of_int,l[7]),
         out_str=string_of_array(0,0,0,string_of_int,l[8]),
         _zs_=caml_check_bound(l[4],0)[1],
         _zt_=_d_(caml_call1(sprintf(_k6_),_zs_),_k5_),
         _zu_=caml_check_bound(bn,0)[1],
         _zv_=_d_(caml_call1(sprintf(_k7_),_zu_),_zt_),
         _zw_=caml_check_bound(ws,2)[3],
         _zx_=caml_check_bound(ws,1)[2],
         _zy_=caml_check_bound(ws,0)[1],
         _zz_=_d_(caml_call3(sprintf(_k8_),_zy_,_zx_,_zw_),_zv_),
         _zA_=caml_check_bound(bn,0)[1],
         _zB_=caml_check_bound(ws,2)[3],
         _zC_=caml_check_bound(ws,1)[2],
         _zD_=
          caml_mul(caml_mul(caml_check_bound(ws,0)[1],_zC_),_zB_)
          +
          _zA_
          |
          0,
         _zE_=_d_(caml_call1(sprintf(_k9_),_zD_),_zz_),
         _zF_=caml_call1(Init[3],l[6]),
         _zG_=_d_(caml_call1(sprintf(_k__),_zF_),_zE_);
        return _d_(caml_call2(sprintf(_k$_),in_str,out_str),_zG_)}
      function to_name$7(param){return _la_}
      var
       Conv1D=
        [0,
         create$7,
         connect$5,
         init$5,
         reset$4,
         mktag$4,
         mkpar$4,
         mkpri$4,
         mkadj$4,
         update$4,
         copy$7,
         run$7,
         to_string$7,
         to_name$7];
      function create$8(inputs,padding,kernel,stride,init_typ)
       {var
         o=caml_check_bound(kernel,3)[4],
         i=caml_check_bound(kernel,2)[3],
         h=caml_check_bound(kernel,1)[2],
         w=caml_check_bound(kernel,0)[1];
        if(inputs)
         {var a=inputs[1];
          if(i !== caml_check_bound(a,2)[3])throw [0,Assert_failure,_lb_];
          var in_shape=a}
        else
         var in_shape=[0,0,0,i];
        var _zr_=caml_call1(Arr[1],[0,o]);
        return [0,
                caml_call1(Arr[1],[0,w,h,i,o]),
                _zr_,
                kernel,
                stride,
                padding,
                init_typ,
                in_shape,
                [0,0,0,o]]}
      function connect$6(out_shape,l)
       {if(out_shape.length - 1 === l[7].length - 1)
         {var _zi_=caml_check_bound(l[7],2)[3];
          if(caml_check_bound(out_shape,2)[3] === _zi_)
           {var _zj_=caml_check_bound(out_shape,0)[1];
            caml_check_bound(l[7],0)[1] = _zj_;
            var _zk_=caml_check_bound(out_shape,1)[2];
            caml_check_bound(l[7],1)[2] = _zk_;
            var
             _zl_=caml_check_bound(l[4],1)[2],
             _zm_=caml_check_bound(l[4],0)[1],
             _zn_=caml_check_bound(l[3],1)[2],
             _zo_=caml_check_bound(l[3],0)[1],
             _zp_=caml_check_bound(l[7],1)[2],
             _zq_=caml_check_bound(l[7],0)[1],
             match=
              calc_conv2d_output_shape(l[5],_zq_,_zp_,_zo_,_zn_,_zm_,_zl_),
             out_rows=match[2],
             out_cols=match[1];
            caml_check_bound(l[8],0)[1] = out_cols;
            return caml_check_bound(l[8],1)[2] = out_rows}
          throw [0,Assert_failure,_lc_]}
        throw [0,Assert_failure,_ld_]}
      function init$6(l)
       {l[1] = caml_call3(Init[2],l[6],l[3],l[1]);
        var _zh_=caml_call1(Arr[8],l[2]);
        l[2] = caml_call1(Arr[2],_zh_);
        return 0}
      function reset$5(l)
       {caml_call1(Arr[6],l[1]);return caml_call1(Arr[6],l[2])}
      function mktag$5(t,l)
       {l[1] = caml_call2(make_reverse,l[1],t);
        l[2] = caml_call2(make_reverse,l[2],t);
        return 0}
      function mkpar$5(l){return [0,l[1],l[2]]}
      function mkpri$5(l)
       {var _zg_=caml_call1(primal,l[2]);
        return [0,caml_call1(primal,l[1]),_zg_]}
      function mkadj$5(l)
       {var _zf_=caml_call1(adjval,l[2]);
        return [0,caml_call1(adjval,l[1]),_zf_]}
      function update$5(l,u)
       {l[1] = caml_call1(primal$0,caml_check_bound(u,0)[1]);
        l[2] = caml_call1(primal$0,caml_check_bound(u,1)[2]);
        return 0}
      function copy$8(l)
       {var l$0=create$8(0,l[5],l[3],l[4],l[6]);
        update$5(l$0,map$0(copy_primal,mkpri$5(l)));
        return l$0}
      function run$8(x,l)
       {var _zd_=l[2],_ze_=caml_call4(Maths[69],[0,l[5]],x,l[1],l[4]);
        return caml_call2(Maths[4],_ze_,_zd_)}
      function to_string$8(l)
       {var
         ws=caml_call1(Arr[8],l[1]),
         bn=caml_call1(Arr[8],l[2]),
         in_str=string_of_array(0,0,0,string_of_int,l[7]),
         out_str=string_of_array(0,0,0,string_of_int,l[8]),
         _yX_=caml_check_bound(l[4],1)[2],
         _yY_=caml_check_bound(l[4],0)[1],
         _yZ_=_d_(caml_call2(sprintf(_lf_),_yY_,_yX_),_le_),
         _y0_=caml_check_bound(bn,0)[1],
         _y1_=_d_(caml_call1(sprintf(_lg_),_y0_),_yZ_),
         _y2_=caml_check_bound(ws,3)[4],
         _y3_=caml_check_bound(ws,2)[3],
         _y4_=caml_check_bound(ws,1)[2],
         _y5_=caml_check_bound(ws,0)[1],
         _y6_=_d_(caml_call4(sprintf(_lh_),_y5_,_y4_,_y3_,_y2_),_y1_),
         _y7_=caml_check_bound(bn,0)[1],
         _y8_=caml_check_bound(ws,3)[4],
         _y9_=caml_check_bound(ws,2)[3],
         _y__=caml_check_bound(ws,1)[2],
         _y$_=
          caml_mul
           (caml_mul(caml_mul(caml_check_bound(ws,0)[1],_y__),_y9_),_y8_)
          +
          _y7_
          |
          0,
         _za_=_d_(caml_call1(sprintf(_li_),_y$_),_y6_),
         _zb_=caml_call1(Init[3],l[6]),
         _zc_=_d_(caml_call1(sprintf(_lj_),_zb_),_za_);
        return _d_(caml_call2(sprintf(_lk_),in_str,out_str),_zc_)}
      function to_name$8(param){return _ll_}
      var
       Conv2D=
        [0,
         create$8,
         connect$6,
         init$6,
         reset$5,
         mktag$5,
         mkpar$5,
         mkpri$5,
         mkadj$5,
         update$5,
         copy$8,
         run$8,
         to_string$8,
         to_name$8];
      function create$9(inputs,padding,kernel,stride,init_typ)
       {var
         o=caml_check_bound(kernel,4)[5],
         i=caml_check_bound(kernel,3)[4],
         d=caml_check_bound(kernel,2)[3],
         h=caml_check_bound(kernel,1)[2],
         w=caml_check_bound(kernel,0)[1];
        if(inputs)
         {var a=inputs[1];
          if(i !== caml_check_bound(a,3)[4])throw [0,Assert_failure,_lm_];
          var in_shape=a}
        else
         var in_shape=[0,0,0,0,i];
        var _yW_=caml_call1(Arr[1],[0,o]);
        return [0,
                caml_call1(Arr[1],[0,w,h,d,i,o]),
                _yW_,
                kernel,
                stride,
                padding,
                init_typ,
                in_shape,
                [0,0,0,0,o]]}
      function connect$7(out_shape,l)
       {if(out_shape.length - 1 === l[7].length - 1)
         {var _yJ_=caml_check_bound(l[7],3)[4];
          if(caml_check_bound(out_shape,3)[4] === _yJ_)
           {var _yK_=caml_check_bound(out_shape,0)[1];
            caml_check_bound(l[7],0)[1] = _yK_;
            var _yL_=caml_check_bound(out_shape,1)[2];
            caml_check_bound(l[7],1)[2] = _yL_;
            var _yM_=caml_check_bound(out_shape,2)[3];
            caml_check_bound(l[7],2)[3] = _yM_;
            var
             _yN_=caml_check_bound(l[4],2)[3],
             _yO_=caml_check_bound(l[4],1)[2],
             _yP_=caml_check_bound(l[4],0)[1],
             _yQ_=caml_check_bound(l[3],2)[3],
             _yR_=caml_check_bound(l[3],1)[2],
             _yS_=caml_check_bound(l[3],0)[1],
             _yT_=caml_check_bound(l[7],2)[3],
             _yU_=caml_check_bound(l[7],1)[2],
             _yV_=caml_check_bound(l[7],0)[1],
             match=
              calc_conv3d_output_shape
               (l[5],_yV_,_yU_,_yT_,_yS_,_yR_,_yQ_,_yP_,_yO_,_yN_),
             out_dpts=match[3],
             out_rows=match[2],
             out_cols=match[1];
            caml_check_bound(l[8],0)[1] = out_cols;
            caml_check_bound(l[8],1)[2] = out_rows;
            return caml_check_bound(l[8],2)[3] = out_dpts}
          throw [0,Assert_failure,_ln_]}
        throw [0,Assert_failure,_lo_]}
      function init$7(l)
       {l[1] = caml_call3(Init[2],l[6],l[3],l[1]);
        var _yI_=caml_call1(Arr[8],l[2]);
        l[2] = caml_call1(Arr[2],_yI_);
        return 0}
      function reset$6(l)
       {caml_call1(Arr[6],l[1]);return caml_call1(Arr[6],l[2])}
      function mktag$6(t,l)
       {l[1] = caml_call2(make_reverse,l[1],t);
        l[2] = caml_call2(make_reverse,l[2],t);
        return 0}
      function mkpar$6(l){return [0,l[1],l[2]]}
      function mkpri$6(l)
       {var _yH_=caml_call1(primal,l[2]);
        return [0,caml_call1(primal,l[1]),_yH_]}
      function mkadj$6(l)
       {var _yG_=caml_call1(adjval,l[2]);
        return [0,caml_call1(adjval,l[1]),_yG_]}
      function update$6(l,u)
       {l[1] = caml_call1(primal$0,caml_check_bound(u,0)[1]);
        l[2] = caml_call1(primal$0,caml_check_bound(u,1)[2]);
        return 0}
      function copy$9(l)
       {var l$0=create$9(0,l[5],l[3],l[4],l[6]);
        update$6(l$0,map$0(copy_primal,mkpri$6(l)));
        return l$0}
      function run$9(x,l)
       {var _yE_=l[2],_yF_=caml_call4(Maths[72],[0,l[5]],x,l[1],l[4]);
        return caml_call2(Maths[4],_yF_,_yE_)}
      function to_string$9(l)
       {var
         ws=caml_call1(Arr[8],l[1]),
         bn=caml_call1(Arr[8],l[2]),
         in_str=string_of_array(0,0,0,string_of_int,l[7]),
         out_str=string_of_array(0,0,0,string_of_int,l[8]),
         _yj_=caml_check_bound(l[4],2)[3],
         _yk_=caml_check_bound(l[4],1)[2],
         _yl_=caml_check_bound(l[4],0)[1],
         _ym_=_d_(caml_call3(sprintf(_lq_),_yl_,_yk_,_yj_),_lp_),
         _yn_=caml_check_bound(bn,0)[1],
         _yo_=_d_(caml_call1(sprintf(_lr_),_yn_),_ym_),
         _yp_=caml_check_bound(ws,4)[5],
         _yq_=caml_check_bound(ws,3)[4],
         _yr_=caml_check_bound(ws,2)[3],
         _ys_=caml_check_bound(ws,1)[2],
         _yt_=caml_check_bound(ws,0)[1],
         _yu_=_d_(caml_call5(sprintf(_ls_),_yt_,_ys_,_yr_,_yq_,_yp_),_yo_),
         _yv_=caml_check_bound(bn,0)[1],
         _yw_=caml_check_bound(ws,4)[5],
         _yx_=caml_check_bound(ws,3)[4],
         _yy_=caml_check_bound(ws,2)[3],
         _yz_=caml_check_bound(ws,1)[2],
         _yA_=
          caml_mul
           (caml_mul
             (caml_mul(caml_mul(caml_check_bound(ws,0)[1],_yz_),_yy_),_yx_),
            _yw_)
          +
          _yv_
          |
          0,
         _yB_=_d_(caml_call1(sprintf(_lt_),_yA_),_yu_),
         _yC_=caml_call1(Init[3],l[6]),
         _yD_=_d_(caml_call1(sprintf(_lu_),_yC_),_yB_);
        return _d_(caml_call2(sprintf(_lv_),in_str,out_str),_yD_)}
      function to_name$9(param){return _lw_}
      var
       Conv3D=
        [0,
         create$9,
         connect$7,
         init$7,
         reset$6,
         mktag$6,
         mkpar$6,
         mkpri$6,
         mkadj$6,
         update$6,
         copy$9,
         run$9,
         to_string$9,
         to_name$9];
      function create$10(inputs,o,init_typ)
       {if(inputs)var i=inputs[1],in_shape=[0,i];else var in_shape=[0,0];
        var _yi_=caml_call2(Mat[1],1,o);
        return [0,caml_call2(Mat[1],0,o),_yi_,init_typ,in_shape,[0,o]]}
      function connect$8(out_shape,l)
       {if(0 < out_shape.length - 1){l[4] = copy(out_shape);return 0}
        throw [0,Assert_failure,_lx_]}
      function init$8(l)
       {var
         _yg_=l[4],
         _yh_=1,
         m=fold_left$0(function(a,b){return caml_mul(a,b)},_yh_,_yg_),
         n=caml_check_bound(l[5],0)[1];
        l[1] = caml_call3(Init[2],l[3],[0,m,n],l[1]);
        l[2] = caml_call2(Mat[2],1,n);
        return 0}
      function reset$7(l)
       {caml_call1(Mat[6],l[1]);return caml_call1(Mat[6],l[2])}
      function mktag$7(t,l)
       {l[1] = caml_call2(make_reverse,l[1],t);
        l[2] = caml_call2(make_reverse,l[2],t);
        return 0}
      function mkpar$7(l){return [0,l[1],l[2]]}
      function mkpri$7(l)
       {var _yf_=caml_call1(primal,l[2]);
        return [0,caml_call1(primal,l[1]),_yf_]}
      function mkadj$7(l)
       {var _ye_=caml_call1(adjval,l[2]);
        return [0,caml_call1(adjval,l[1]),_ye_]}
      function update$7(l,u)
       {l[1] = caml_call1(primal$0,caml_check_bound(u,0)[1]);
        l[2] = caml_call1(primal$0,caml_check_bound(u,1)[2]);
        return 0}
      function copy$10(l)
       {var _yd_=l[3],l$0=create$10(0,caml_check_bound(l[5],0)[1],_yd_);
        update$7(l$0,map$0(copy_primal,mkpri$7(l)));
        return l$0}
      function run$10(x,l)
       {var
         m=caml_call1(Mat[9],l[1]),
         n=caml_div(caml_call1(Arr[9],x),m),
         x$0=caml_call2(Maths[75],x,[0,n,m]),
         _yb_=l[2],
         _yc_=caml_call2(Maths[49],x$0,l[1]),
         y=caml_call2(Maths[4],_yc_,_yb_);
        return y}
      function to_string$10(l)
       {var
         _x5_=l[4],
         _x6_=1,
         wm=fold_left$0(function(a,b){return caml_mul(a,b)},_x6_,_x5_),
         wn=caml_check_bound(l[5],0)[1],
         bn=caml_check_bound(l[5],0)[1],
         in_str=string_of_array(0,0,0,string_of_int,l[4]),
         _x7_=_d_(caml_call2(sprintf(_lz_),1,bn),_ly_),
         _x8_=_d_(caml_call2(sprintf(_lA_),wm,wn),_x7_),
         _x9_=_d_(caml_call1(sprintf(_lB_),caml_mul(wm,wn) + bn | 0),_x8_),
         _x__=caml_call1(Init[3],l[3]),
         _x$_=_d_(caml_call1(sprintf(_lC_),_x__),_x9_),
         _ya_=caml_check_bound(l[5],0)[1];
        return _d_(caml_call2(sprintf(_lD_),in_str,_ya_),_x$_)}
      function to_name$10(param){return _lE_}
      var
       FullyConnected=
        [0,
         create$10,
         connect$8,
         init$8,
         reset$7,
         mktag$7,
         mkpar$7,
         mkpri$7,
         mkadj$7,
         update$7,
         copy$10,
         run$10,
         to_string$10,
         to_name$10];
      function create$11(padding,kernel,stride)
       {return [0,padding,kernel,stride,[0,0,0],[0,0,0]]}
      function connect$9(out_shape,l)
       {if(out_shape.length - 1 === l[4].length - 1)
         {var _xZ_=caml_check_bound(out_shape,0)[1];
          caml_check_bound(l[4],0)[1] = _xZ_;
          var _x0_=caml_check_bound(out_shape,1)[2];
          caml_check_bound(l[4],1)[2] = _x0_;
          var
           _x1_=caml_check_bound(l[3],0)[1],
           _x2_=caml_check_bound(l[2],0)[1],
           _x3_=caml_check_bound(l[4],0)[1],
           out_cols=calc_conv1d_output_shape(l[1],_x3_,_x2_,_x1_);
          caml_check_bound(l[5],0)[1] = out_cols;
          var _x4_=caml_check_bound(out_shape,1)[2];
          return caml_check_bound(l[5],1)[2] = _x4_}
        throw [0,Assert_failure,_lF_]}
      function copy$11(l){return create$11(l[1],l[2],l[3])}
      function run$11(x,l){return caml_call4(Maths[77],l[1],x,l[2],l[3])}
      function to_string$11(l)
       {var
         padding_s=0 === l[1]?_lG_:_lM_,
         _xQ_=caml_check_bound(l[3],0)[1],
         _xR_=_d_(caml_call1(sprintf(_lI_),_xQ_),_lH_),
         _xS_=caml_check_bound(l[2],0)[1],
         _xT_=_d_(caml_call1(sprintf(_lJ_),_xS_),_xR_),
         _xU_=_d_(caml_call1(sprintf(_lK_),padding_s),_xT_),
         _xV_=caml_check_bound(l[5],1)[2],
         _xW_=caml_check_bound(l[5],0)[1],
         _xX_=caml_check_bound(l[4],1)[2],
         _xY_=caml_check_bound(l[4],0)[1];
        return _d_(caml_call4(sprintf(_lL_),_xY_,_xX_,_xW_,_xV_),_xU_)}
      function to_name$11(param){return _lN_}
      var
       MaxPool1D=
        [0,create$11,connect$9,copy$11,run$11,to_string$11,to_name$11];
      function create$12(padding,kernel,stride)
       {return [0,padding,kernel,stride,[0,0,0,0],[0,0,0,0]]}
      function connect$10(out_shape,l)
       {if(out_shape.length - 1 === l[4].length - 1)
         {var _xG_=caml_check_bound(out_shape,0)[1];
          caml_check_bound(l[4],0)[1] = _xG_;
          var _xH_=caml_check_bound(out_shape,1)[2];
          caml_check_bound(l[4],1)[2] = _xH_;
          var _xI_=caml_check_bound(out_shape,2)[3];
          caml_check_bound(l[4],2)[3] = _xI_;
          var
           _xJ_=caml_check_bound(l[3],1)[2],
           _xK_=caml_check_bound(l[3],0)[1],
           _xL_=caml_check_bound(l[2],1)[2],
           _xM_=caml_check_bound(l[2],0)[1],
           _xN_=caml_check_bound(l[4],1)[2],
           _xO_=caml_check_bound(l[4],0)[1],
           match=calc_conv2d_output_shape(l[1],_xO_,_xN_,_xM_,_xL_,_xK_,_xJ_),
           out_rows=match[2],
           out_cols=match[1];
          caml_check_bound(l[5],0)[1] = out_cols;
          caml_check_bound(l[5],1)[2] = out_rows;
          var _xP_=caml_check_bound(out_shape,2)[3];
          return caml_check_bound(l[5],2)[3] = _xP_}
        throw [0,Assert_failure,_lO_]}
      function copy$12(l){return create$12(l[1],l[2],l[3])}
      function run$12(x,l){return caml_call4(Maths[79],l[1],x,l[2],l[3])}
      function to_string$12(l)
       {var
         padding_s=0 === l[1]?_lP_:_lV_,
         _xt_=caml_check_bound(l[3],1)[2],
         _xu_=caml_check_bound(l[3],0)[1],
         _xv_=_d_(caml_call2(sprintf(_lR_),_xu_,_xt_),_lQ_),
         _xw_=caml_check_bound(l[2],1)[2],
         _xx_=caml_check_bound(l[2],0)[1],
         _xy_=_d_(caml_call2(sprintf(_lS_),_xx_,_xw_),_xv_),
         _xz_=_d_(caml_call1(sprintf(_lT_),padding_s),_xy_),
         _xA_=caml_check_bound(l[5],2)[3],
         _xB_=caml_check_bound(l[5],1)[2],
         _xC_=caml_check_bound(l[5],0)[1],
         _xD_=caml_check_bound(l[4],2)[3],
         _xE_=caml_check_bound(l[4],1)[2],
         _xF_=caml_check_bound(l[4],0)[1];
        return _d_
                (caml_call6(sprintf(_lU_),_xF_,_xE_,_xD_,_xC_,_xB_,_xA_),_xz_)}
      function to_name$12(param){return _lW_}
      var
       MaxPool2D=
        [0,create$12,connect$10,copy$12,run$12,to_string$12,to_name$12];
      function create$13(padding,kernel,stride)
       {return [0,padding,kernel,stride,[0,0,0],[0,0,0]]}
      function connect$11(out_shape,l)
       {if(out_shape.length - 1 === l[4].length - 1)
         {var _xn_=caml_check_bound(out_shape,0)[1];
          caml_check_bound(l[4],0)[1] = _xn_;
          var _xo_=caml_check_bound(out_shape,1)[2];
          caml_check_bound(l[4],1)[2] = _xo_;
          var
           _xp_=caml_check_bound(l[3],0)[1],
           _xq_=caml_check_bound(l[2],0)[1],
           _xr_=caml_check_bound(l[4],0)[1],
           out_cols=calc_conv1d_output_shape(l[1],_xr_,_xq_,_xp_);
          caml_check_bound(l[5],0)[1] = out_cols;
          var _xs_=caml_check_bound(out_shape,1)[2];
          return caml_check_bound(l[5],1)[2] = _xs_}
        throw [0,Assert_failure,_lX_]}
      function copy$13(l){return create$13(l[1],l[2],l[3])}
      function run$13(x,l){return caml_call4(Maths[83],l[1],x,l[2],l[3])}
      function to_string$13(l)
       {var
         padding_s=0 === l[1]?_lY_:_l4_,
         _xe_=caml_check_bound(l[3],0)[1],
         _xf_=_d_(caml_call1(sprintf(_l0_),_xe_),_lZ_),
         _xg_=caml_check_bound(l[2],0)[1],
         _xh_=_d_(caml_call1(sprintf(_l1_),_xg_),_xf_),
         _xi_=_d_(caml_call1(sprintf(_l2_),padding_s),_xh_),
         _xj_=caml_check_bound(l[5],1)[2],
         _xk_=caml_check_bound(l[5],0)[1],
         _xl_=caml_check_bound(l[4],1)[2],
         _xm_=caml_check_bound(l[4],0)[1];
        return _d_(caml_call4(sprintf(_l3_),_xm_,_xl_,_xk_,_xj_),_xi_)}
      function to_name$13(param){return _l5_}
      var
       AvgPool1D=
        [0,create$13,connect$11,copy$13,run$13,to_string$13,to_name$13];
      function create$14(padding,kernel,stride)
       {return [0,padding,kernel,stride,[0,0,0,0],[0,0,0,0]]}
      function connect$12(out_shape,l)
       {if(out_shape.length - 1 === l[4].length - 1)
         {var _w6_=caml_check_bound(out_shape,0)[1];
          caml_check_bound(l[4],0)[1] = _w6_;
          var _w7_=caml_check_bound(out_shape,1)[2];
          caml_check_bound(l[4],1)[2] = _w7_;
          var _w8_=caml_check_bound(out_shape,2)[3];
          caml_check_bound(l[4],2)[3] = _w8_;
          var
           _w9_=caml_check_bound(l[3],1)[2],
           _w__=caml_check_bound(l[3],0)[1],
           _w$_=caml_check_bound(l[2],1)[2],
           _xa_=caml_check_bound(l[2],0)[1],
           _xb_=caml_check_bound(l[4],1)[2],
           _xc_=caml_check_bound(l[4],0)[1],
           match=calc_conv2d_output_shape(l[1],_xc_,_xb_,_xa_,_w$_,_w__,_w9_),
           out_rows=match[2],
           out_cols=match[1];
          caml_check_bound(l[5],0)[1] = out_cols;
          caml_check_bound(l[5],1)[2] = out_rows;
          var _xd_=caml_check_bound(out_shape,2)[3];
          return caml_check_bound(l[5],2)[3] = _xd_}
        throw [0,Assert_failure,_l6_]}
      function copy$14(l){return create$14(l[1],l[2],l[3])}
      function run$14(x,l){return caml_call4(Maths[85],l[1],x,l[2],l[3])}
      function to_string$14(l)
       {var
         padding_s=0 === l[1]?_l7_:_mb_,
         _wT_=caml_check_bound(l[3],1)[2],
         _wU_=caml_check_bound(l[3],0)[1],
         _wV_=_d_(caml_call2(sprintf(_l9_),_wU_,_wT_),_l8_),
         _wW_=caml_check_bound(l[2],1)[2],
         _wX_=caml_check_bound(l[2],0)[1],
         _wY_=_d_(caml_call2(sprintf(_l__),_wX_,_wW_),_wV_),
         _wZ_=_d_(caml_call1(sprintf(_l$_),padding_s),_wY_),
         _w0_=caml_check_bound(l[5],2)[3],
         _w1_=caml_check_bound(l[5],1)[2],
         _w2_=caml_check_bound(l[5],0)[1],
         _w3_=caml_check_bound(l[4],2)[3],
         _w4_=caml_check_bound(l[4],1)[2],
         _w5_=caml_check_bound(l[4],0)[1];
        return _d_
                (caml_call6(sprintf(_ma_),_w5_,_w4_,_w3_,_w2_,_w1_,_w0_),_wZ_)}
      function to_name$14(param){return _mc_}
      var
       AvgPool2D=
        [0,create$14,connect$12,copy$14,run$14,to_string$14,to_name$14];
      function create$15(param){return [0,[0,0,0],[0,0]]}
      function connect$13(out_shape,l)
       {if(2 === out_shape.length - 1)
         {var _wQ_=caml_check_bound(out_shape,0)[1];
          caml_check_bound(l[1],0)[1] = _wQ_;
          var _wR_=caml_check_bound(out_shape,1)[2];
          caml_check_bound(l[1],1)[2] = _wR_;
          var _wS_=caml_check_bound(out_shape,1)[2];
          return caml_check_bound(l[2],0)[1] = _wS_}
        throw [0,Assert_failure,_md_]}
      function copy$15(l){return create$15(0)}
      function run$15(x,l)
       {var
         kernel=[0,caml_check_bound(l[1],0)[1]],
         a=caml_call4(Maths[77],1,x,kernel,[0,1]),
         s=caml_call1(Arr[8],a),
         o=caml_check_bound(s,2)[3],
         b=caml_check_bound(s,0)[1];
        return caml_call2(Arr[7],a,[0,b,o])}
      function to_string$15(l)
       {var
         _wN_=caml_check_bound(l[2],0)[1],
         _wO_=caml_check_bound(l[1],1)[2],
         _wP_=caml_check_bound(l[1],0)[1];
        return _d_(caml_call3(sprintf(_mf_),_wP_,_wO_,_wN_),_me_)}
      function to_name$15(param){return _mg_}
      var
       GlobalMaxPool1D=
        [0,create$15,connect$13,copy$15,run$15,to_string$15,to_name$15];
      function create$16(param){return [0,[0,0,0,0],[0,0]]}
      function connect$14(out_shape,l)
       {if(3 === out_shape.length - 1)
         {var _wJ_=caml_check_bound(out_shape,0)[1];
          caml_check_bound(l[1],0)[1] = _wJ_;
          var _wK_=caml_check_bound(out_shape,1)[2];
          caml_check_bound(l[1],1)[2] = _wK_;
          var _wL_=caml_check_bound(out_shape,2)[3];
          caml_check_bound(l[1],2)[3] = _wL_;
          var _wM_=caml_check_bound(out_shape,2)[3];
          return caml_check_bound(l[2],0)[1] = _wM_}
        throw [0,Assert_failure,_mh_]}
      function copy$16(l){return create$16(0)}
      function run$16(x,l)
       {var
         _wI_=caml_check_bound(l[1],1)[2],
         kernel=[0,caml_check_bound(l[1],0)[1],_wI_],
         a=caml_call4(Maths[79],1,x,kernel,[0,1,1]),
         s=caml_call1(Arr[8],a),
         o=caml_check_bound(s,3)[4],
         b=caml_check_bound(s,0)[1];
        return caml_call2(Arr[7],a,[0,b,o])}
      function to_string$16(l)
       {var
         _wE_=caml_check_bound(l[2],0)[1],
         _wF_=caml_check_bound(l[1],2)[3],
         _wG_=caml_check_bound(l[1],1)[2],
         _wH_=caml_check_bound(l[1],0)[1];
        return _d_(caml_call4(sprintf(_mj_),_wH_,_wG_,_wF_,_wE_),_mi_)}
      function to_name$16(param){return _mk_}
      var
       GlobalMaxPool2D=
        [0,create$16,connect$14,copy$16,run$16,to_string$16,to_name$16];
      function create$17(param){return [0,[0,0,0],[0,0]]}
      function connect$15(out_shape,l)
       {if(2 === out_shape.length - 1)
         {var _wB_=caml_check_bound(out_shape,0)[1];
          caml_check_bound(l[1],0)[1] = _wB_;
          var _wC_=caml_check_bound(out_shape,1)[2];
          caml_check_bound(l[1],1)[2] = _wC_;
          var _wD_=caml_check_bound(out_shape,1)[2];
          return caml_check_bound(l[2],0)[1] = _wD_}
        throw [0,Assert_failure,_ml_]}
      function copy$17(l){return create$17(0)}
      function run$17(x,l)
       {var
         kernel=[0,caml_check_bound(l[1],0)[1]],
         a=caml_call4(Maths[83],1,x,kernel,[0,1]),
         s=caml_call1(Arr[8],a),
         o=caml_check_bound(s,2)[3],
         b=caml_check_bound(s,0)[1];
        return caml_call2(Arr[7],a,[0,b,o])}
      function to_string$17(l)
       {var
         _wy_=caml_check_bound(l[2],0)[1],
         _wz_=caml_check_bound(l[1],1)[2],
         _wA_=caml_check_bound(l[1],0)[1];
        return _d_(caml_call3(sprintf(_mn_),_wA_,_wz_,_wy_),_mm_)}
      function to_name$17(param){return _mo_}
      var
       GlobalAvgPool1D=
        [0,create$17,connect$15,copy$17,run$17,to_string$17,to_name$17];
      function create$18(param){return [0,[0,0,0,0],[0,0]]}
      function connect$16(out_shape,l)
       {if(3 === out_shape.length - 1)
         {var _wu_=caml_check_bound(out_shape,0)[1];
          caml_check_bound(l[1],0)[1] = _wu_;
          var _wv_=caml_check_bound(out_shape,1)[2];
          caml_check_bound(l[1],1)[2] = _wv_;
          var _ww_=caml_check_bound(out_shape,2)[3];
          caml_check_bound(l[1],2)[3] = _ww_;
          var _wx_=caml_check_bound(out_shape,2)[3];
          return caml_check_bound(l[2],0)[1] = _wx_}
        throw [0,Assert_failure,_mp_]}
      function copy$18(l){return create$18(0)}
      function run$18(x,l)
       {var
         _wt_=caml_check_bound(l[1],1)[2],
         kernel=[0,caml_check_bound(l[1],0)[1],_wt_],
         a=caml_call4(Maths[85],1,x,kernel,[0,1,1]),
         s=caml_call1(Arr[8],a),
         o=caml_check_bound(s,3)[4],
         b=caml_check_bound(s,0)[1];
        return caml_call2(Arr[7],a,[0,b,o])}
      function to_string$18(l)
       {var
         _wp_=caml_check_bound(l[2],0)[1],
         _wq_=caml_check_bound(l[1],2)[3],
         _wr_=caml_check_bound(l[1],1)[2],
         _ws_=caml_check_bound(l[1],0)[1];
        return _d_(caml_call4(sprintf(_mr_),_ws_,_wr_,_wq_,_wp_),_mq_)}
      function to_name$18(param){return _ms_}
      var
       GlobalAvgPool2D=
        [0,create$18,connect$16,copy$18,run$18,to_string$18,to_name$18],
       UpSampling1D=[0],
       UpSampling2D=[0],
       UpSampling3D=[0],
       Padding1D=[0],
       Padding2D=[0],
       Padding3D=[0];
      function create$19(lambda){return [0,lambda,[0],[0]]}
      function connect$17(out_shape,l)
       {l[2] = copy(out_shape);l[3] = copy(out_shape);return 0}
      function copy$19(l){return create$19(l[1])}
      function run$19(x,l){return caml_call1(l[1],x)}
      function to_string$19(l)
       {var
         in_str=string_of_array(0,0,0,string_of_int,l[2]),
         out_str=string_of_array(0,0,0,string_of_int,l[3]),
         _wo_=_d_(sprintf(_mu_),_mt_);
        return _d_(caml_call2(sprintf(_mv_),in_str,out_str),_wo_)}
      function to_name$19(param){return _mw_}
      var
       Lambda=
        [0,create$19,connect$17,copy$19,run$19,to_string$19,to_name$19];
      function create$20(rate){return [0,rate,[0],[0]]}
      function connect$18(out_shape,l)
       {l[2] = copy(out_shape);l[3] = copy(out_shape);return 0}
      function copy$20(l){return create$20(l[1])}
      function run$20(x,l)
       {var a=[0,1 / (1 - l[1])],b=caml_call2(Maths[89],[0,l[1]],x);
        return caml_call2(Maths[8],a,b)}
      function to_string$20(l)
       {var
         in_str=string_of_array(0,0,0,string_of_int,l[2]),
         out_str=string_of_array(0,0,0,string_of_int,l[3]),
         _wm_=l[1],
         _wn_=caml_call1(sprintf(_mx_),_wm_);
        return _d_(caml_call2(sprintf(_my_),in_str,out_str),_wn_)}
      function to_name$20(param){return _mz_}
      var
       Dropout=
        [0,create$20,connect$18,copy$20,run$20,to_string$20,to_name$20];
      function create$21(inputs,o)
       {if(inputs)var i=inputs[1],in_shape=i;else var in_shape=[0];
        return [0,in_shape,o]}
      function connect$19(out_shape,l)
       {var
         _wj_=1,
         m=fold_left$0(function(a,b){return caml_mul(a,b)},_wj_,out_shape),
         _wk_=l[2],
         _wl_=1,
         n=fold_left$0(function(a,b){return caml_mul(a,b)},_wl_,_wk_);
        if(m === n){l[1] = copy(out_shape);return 0}
        throw [0,Assert_failure,_mA_]}
      function copy$21(l){return create$21(0,l[2])}
      function run$21(x,l)
       {var
         x_shape=caml_call1(shape,x),
         _wi_=l[2],
         out_shape=append$0([0,caml_check_bound(x_shape,0)[1]],_wi_);
        return caml_call2(Maths[75],x,out_shape)}
      function to_string$21(l)
       {var
         in_str=string_of_array(0,0,0,string_of_int,l[1]),
         out_str=string_of_array(0,0,0,string_of_int,l[2]);
        return caml_call2(sprintf(_mB_),in_str,out_str)}
      function to_name$21(param){return _mC_}
      var
       Reshape=
        [0,create$21,connect$19,copy$21,run$21,to_string$21,to_name$21];
      function create$22(param){return [0,[0],[0]]}
      function connect$20(out_shape,l)
       {var
         _wh_=1,
         o=fold_left$0(function(a,b){return caml_mul(a,b)},_wh_,out_shape);
        l[1] = copy(out_shape);
        l[2] = [0,o];
        return 0}
      function copy$22(l){return create$22(0)}
      function run$22(x,l)
       {var
         _wf_=caml_check_bound(l[2],0)[1],
         _wg_=[0,caml_check_bound(caml_call1(shape,x),0)[1],_wf_];
        return caml_call2(Maths[75],x,_wg_)}
      function to_string$22(l)
       {var
         in_str=string_of_array(0,0,0,string_of_int,l[1]),
         _we_=caml_check_bound(l[2],0)[1];
        return caml_call2(sprintf(_mD_),in_str,_we_)}
      function to_name$22(param){return _mE_}
      var
       Flatten=
        [0,create$22,connect$20,copy$22,run$22,to_string$22,to_name$22];
      function create$23(param){return [0,[0],[0]]}
      function connect$21(out_shapes,l)
       {iter
         (function(s)
           {if(caml_equal(s,caml_check_bound(out_shapes,0)[1]))return 0;
            throw [0,Assert_failure,_mF_]},
          out_shapes);
        l[1] = copy(caml_check_bound(out_shapes,0)[1]);
        l[2] = copy(caml_check_bound(out_shapes,0)[1]);
        return 0}
      function copy$23(l){return create$23(0)}
      function run$23(x,l)
       {var n=x.length - 1;
        if(1 < n)
         {var acc=[0,caml_check_bound(x,0)[1]],_wb_=n - 1 | 0,_wa_=1;
          if(!(_wb_ < 1))
           {var i=_wa_;
            for(;;)
             {var _wc_=caml_check_bound(x,i)[i + 1];
              acc[1] = caml_call2(Maths[4],acc[1],_wc_);
              var _wd_=i + 1 | 0;
              if(_wb_ !== i){var i=_wd_;continue}
              break}}
          return acc[1]}
        throw [0,Assert_failure,_mG_]}
      function to_string$23(l)
       {var
         in_str=string_of_array(0,0,0,string_of_int,l[1]),
         out_str=string_of_array(0,0,0,string_of_int,l[2]);
        return caml_call2(sprintf(_mH_),in_str,out_str)}
      function to_name$23(param){return _mI_}
      var Add=[0,create$23,connect$21,copy$23,run$23,to_string$23,to_name$23];
      function create$24(param){return [0,[0],[0]]}
      function connect$22(out_shapes,l)
       {iter
         (function(s)
           {if(caml_equal(s,caml_check_bound(out_shapes,0)[1]))return 0;
            throw [0,Assert_failure,_mJ_]},
          out_shapes);
        l[1] = copy(caml_check_bound(out_shapes,0)[1]);
        l[2] = copy(caml_check_bound(out_shapes,0)[1]);
        return 0}
      function copy$24(l){return create$24(0)}
      function run$24(x,l)
       {var n=x.length - 1;
        if(1 < n)
         {var acc=[0,caml_check_bound(x,0)[1]],_v9_=n - 1 | 0,_v8_=1;
          if(!(_v9_ < 1))
           {var i=_v8_;
            for(;;)
             {var _v__=caml_check_bound(x,i)[i + 1];
              acc[1] = caml_call2(Maths[8],acc[1],_v__);
              var _v$_=i + 1 | 0;
              if(_v9_ !== i){var i=_v$_;continue}
              break}}
          return acc[1]}
        throw [0,Assert_failure,_mK_]}
      function to_string$24(l)
       {var
         in_str=string_of_array(0,0,0,string_of_int,l[1]),
         out_str=string_of_array(0,0,0,string_of_int,l[2]);
        return caml_call2(sprintf(_mL_),in_str,out_str)}
      function to_name$24(param){return _mM_}
      var Mul=[0,create$24,connect$22,copy$24,run$24,to_string$24,to_name$24];
      function create$25(param){return [0,[0],[0]]}
      function connect$23(out_shapes,l)
       {var
         m=caml_check_bound(caml_check_bound(out_shapes,1)[2],0)[1],
         n=caml_check_bound(caml_check_bound(out_shapes,1)[2],1)[2];
        if(m === caml_check_bound(caml_check_bound(out_shapes,0)[1],1)[2])
         {l[1] = [0,m,n];l[2] = [0,n];return 0}
        throw [0,Assert_failure,_mN_]}
      function copy$25(l){return create$25(0)}
      function run$25(x,l)
       {if(2 === x.length - 1)
         {var _v6_=caml_check_bound(x,1)[2],_v7_=caml_check_bound(x,0)[1];
          return caml_call2(Maths[49],_v7_,_v6_)}
        throw [0,Assert_failure,_mO_]}
      function to_string$25(l)
       {var m=caml_check_bound(l[1],0)[1],n=caml_check_bound(l[1],1)[2];
        return caml_call4(sprintf(_mP_),m,m,n,n)}
      function to_name$25(param){return _mQ_}
      var Dot=[0,create$25,connect$23,copy$25,run$25,to_string$25,to_name$25];
      function create$26(param){return [0,[0],[0]]}
      function connect$24(out_shapes,l)
       {iter
         (function(s)
           {if(caml_equal(s,caml_check_bound(out_shapes,0)[1]))return 0;
            throw [0,Assert_failure,_mR_]},
          out_shapes);
        l[1] = copy(caml_check_bound(out_shapes,0)[1]);
        l[2] = copy(caml_check_bound(out_shapes,0)[1]);
        return 0}
      function copy$26(l){return create$26(0)}
      function run$26(x,l)
       {var n=x.length - 1;
        if(1 < n)
         {var acc=[0,caml_check_bound(x,0)[1]],_v3_=n - 1 | 0,_v2_=1;
          if(!(_v3_ < 1))
           {var i=_v2_;
            for(;;)
             {var _v4_=caml_check_bound(x,i)[i + 1];
              acc[1] = caml_call2(Maths[16],acc[1],_v4_);
              var _v5_=i + 1 | 0;
              if(_v3_ !== i){var i=_v5_;continue}
              break}}
          return acc[1]}
        throw [0,Assert_failure,_mS_]}
      function to_string$26(l)
       {var
         in_str=string_of_array(0,0,0,string_of_int,l[1]),
         out_str=string_of_array(0,0,0,string_of_int,l[2]);
        return caml_call2(sprintf(_mT_),in_str,out_str)}
      function to_name$26(param){return _mU_}
      var Max=[0,create$26,connect$24,copy$26,run$26,to_string$26,to_name$26];
      function create$27(param){return [0,[0],[0]]}
      function connect$25(out_shapes,l)
       {iter
         (function(s)
           {if(caml_equal(s,caml_check_bound(out_shapes,0)[1]))return 0;
            throw [0,Assert_failure,_mV_]},
          out_shapes);
        l[1] = copy(caml_check_bound(out_shapes,0)[1]);
        l[2] = copy(caml_check_bound(out_shapes,0)[1]);
        return 0}
      function copy$27(l){return create$27(0)}
      function run$27(x,l)
       {var n=x.length - 1;
        if(1 < n)
         {var acc=[0,caml_check_bound(x,0)[1]],_vZ_=n - 1 | 0,_vY_=1;
          if(!(_vZ_ < 1))
           {var i=_vY_;
            for(;;)
             {var _v0_=caml_check_bound(x,i)[i + 1];
              acc[1] = caml_call2(Maths[4],acc[1],_v0_);
              var _v1_=i + 1 | 0;
              if(_vZ_ !== i){var i=_v1_;continue}
              break}}
          return caml_call2(Maths[10],acc[1],[0,n])}
        throw [0,Assert_failure,_mW_]}
      function to_string$27(l)
       {var
         in_str=string_of_array(0,0,0,string_of_int,l[1]),
         out_str=string_of_array(0,0,0,string_of_int,l[2]);
        return caml_call2(sprintf(_mX_),in_str,out_str)}
      function to_name$27(param){return _mY_}
      var
       Average=
        [0,create$27,connect$25,copy$27,run$27,to_string$27,to_name$27];
      function create$28(axis){return [0,axis,[0],[0]]}
      function connect$26(out_shapes,l)
       {var s0=caml_check_bound(out_shapes,0)[1],d=[0,0];
        iter
         (function(s1)
           {return iteri
                    (function(i,d$0)
                      {if((i + 1 | 0) !== l[1])
                        {if(d$0 === caml_check_bound(s0,i)[i + 1])return 0;
                         throw [0,Assert_failure,_mZ_]}
                       d[1] = d[1] + d$0 | 0;
                       return 0},
                     s1)},
          out_shapes);
        l[2] = copy(s0);
        l[3] = copy(s0);
        if(0 < l[1])
         {var _vV_=l[1] - 1 | 0;
          caml_check_bound(l[2],_vV_)[_vV_ + 1] = -1;
          var _vX_=l[1] - 1 | 0,_vW_=d[1];
          return caml_check_bound(l[3],_vX_)[_vX_ + 1] = _vW_}
        throw [0,Assert_failure,_m0_]}
      function copy$28(l){return create$28(l[1])}
      function run$28(x,l)
       {var n=x.length - 1;
        if(1 < n)
         {var acc=[0,caml_check_bound(x,0)[1]],_vS_=n - 1 | 0,_vR_=1;
          if(!(_vS_ < 1))
           {var i=_vR_;
            for(;;)
             {var _vT_=caml_check_bound(x,i)[i + 1];
              acc[1] = caml_call3(Maths[90],l[1],acc[1],_vT_);
              var _vU_=i + 1 | 0;
              if(_vS_ !== i){var i=_vU_;continue}
              break}}
          return acc[1]}
        throw [0,Assert_failure,_m1_]}
      function to_string$28(l)
       {var
         _vO_=l[2],
         in_str=
          string_of_array
           (0,
            0,
            0,
            function(i){return -1 === i?_m2_:caml_new_string("" + i)},
            _vO_),
         out_str=string_of_array(0,0,0,string_of_int,l[3]),
         _vP_=l[1],
         _vQ_=_d_(caml_call1(sprintf(_m4_),_vP_),_m3_);
        return _d_(caml_call2(sprintf(_m5_),in_str,out_str),_vQ_)}
      function to_name$28(param){return _m6_}
      var
       Concatenate=
        [0,create$28,connect$26,copy$28,run$28,to_string$28,to_name$28];
      function create$29(opt,_vH_,mu,var$0,axis)
       {if(opt)var sth=opt[1],training=sth;else var training=1;
        if(_vH_)var sth$0=_vH_[1],decay=sth$0;else var decay=0.99;
        var _vI_=[0],_vJ_=[0],_vK_=[0,decay];
        if(var$0)
         var a=var$0[1],_vL_=[1,a];
        else
         var _vL_=caml_call1(Arr[1],[0,0]);
        if(mu)
         var a$0=mu[1],_vM_=[1,a$0];
        else
         var _vM_=caml_call1(Arr[1],[0,0]);
        var _vN_=caml_call1(Arr[1],[0,0]);
        return [0,
                axis,
                caml_call1(Arr[1],[0,0]),
                _vN_,
                _vM_,
                _vL_,
                _vK_,
                training,
                _vJ_,
                _vI_]}
      function connect$27(out_shape,l)
       {if(l[1] < 0)l[1] = (out_shape.length - 1 + l[1] | 0) + 1 | 0;
        l[8] = copy(out_shape);
        l[9] = copy(out_shape);
        return 0}
      function init$9(l)
       {var
         s=caml_make_vect(l[8].length - 1 + 1 | 0,1),
         _vE_=l[1] - 1 | 0,
         _vF_=caml_check_bound(l[8],_vE_)[_vE_ + 1],
         _vG_=l[1];
        caml_check_bound(s,_vG_)[_vG_ + 1] = _vF_;
        l[2] = caml_call1(Arr[2],s);
        l[3] = caml_call1(Arr[3],s);
        l[4] = caml_call1(Arr[2],s);
        l[5] = caml_call1(Arr[3],s);
        return 0}
      function reset$8(l)
       {caml_call1(Arr[6],l[2]);return caml_call1(Arr[6],l[3])}
      function mktag$8(t,l)
       {l[2] = caml_call2(make_reverse,l[2],t);
        l[3] = caml_call2(make_reverse,l[3],t);
        return 0}
      function mkpar$8(l){return [0,l[2],l[3]]}
      function mkpri$8(l)
       {var _vD_=caml_call1(primal,l[3]);
        return [0,caml_call1(primal,l[2]),_vD_]}
      function mkadj$8(l)
       {var _vC_=caml_call1(adjval,l[3]);
        return [0,caml_call1(adjval,l[2]),_vC_]}
      function update$8(l,u)
       {l[2] = caml_call1(primal$0,caml_check_bound(u,0)[1]);
        l[3] = caml_call1(primal$0,caml_check_bound(u,1)[2]);
        return 0}
      function copy$29(l)
       {var
         _vy_=l[1],
         _vz_=[0,caml_call1(unpack_arr,l[5])],
         _vA_=[0,caml_call1(unpack_arr,l[4])],
         _vB_=[0,caml_call1(unpack_flt,l[6])],
         l$0=create$29([0,l[7]],_vB_,_vA_,_vz_,_vy_);
        update$8(l$0,map$0(copy_primal,mkpri$8(l)));
        return l$0}
      function run$29(x,l)
       {var
         _vj_=l[1],
         a=[0,1 / caml_check_bound(caml_call1(shape,x),_vj_)[_vj_ + 1]];
        if(1 === l[7])
         {var
           _vk_=caml_call2(Maths[47],[0,l[1]],x),
           mu=caml_call2(Maths[8],a,_vk_),
           _vl_=caml_call2(Maths[8],x,x),
           _vm_=caml_call2(Maths[47],[0,l[1]],_vl_),
           var$0=caml_call2(Maths[8],a,_vm_),
           _vn_=caml_call2(Maths[6],_m7_,l[6]),
           _vo_=caml_call2(Maths[8],_vn_,mu),
           _vp_=caml_call2(Maths[8],l[6],l[4]);
          l[4] = caml_call1(primal$0,caml_call2(Maths[4],_vp_,_vo_));
          var
           _vq_=caml_call2(Maths[6],_m8_,l[6]),
           _vr_=caml_call2(Maths[8],_vq_,var$0),
           _vs_=caml_call2(Maths[8],l[6],l[5]);
          l[5] = caml_call1(primal$0,caml_call2(Maths[4],_vs_,_vr_))}
        var
         _vt_=caml_call2(Maths[4],l[5],_m9_),
         _vu_=caml_call1(Maths[24],_vt_),
         _vv_=caml_call2(Maths[6],x,l[4]),
         x$0=caml_call2(Maths[10],_vv_,_vu_),
         _vw_=l[2],
         _vx_=caml_call2(Maths[8],x$0,l[3]);
        return caml_call2(Maths[4],_vx_,_vw_)}
      function to_string$29(l)
       {var
         in_str=string_of_array(0,0,0,string_of_int,l[8]),
         out_str=string_of_array(0,0,0,string_of_int,l[9]),
         s=caml_make_vect(l[8].length - 1 + 1 | 0,1),
         _u7_=l[1] - 1 | 0,
         _u8_=caml_check_bound(l[8],_u7_)[_u7_ + 1],
         _u9_=l[1];
        caml_check_bound(s,_u9_)[_u9_ + 1] = _u8_;
        var
         s_str=string_of_array(0,0,0,string_of_int,s),
         _u__=caml_call1(sprintf(_m__),s_str),
         _u$_=_d_(caml_call1(sprintf(_m$_),s_str),_u__),
         _va_=l[1] - 1 | 0,
         _vb_=caml_check_bound(l[8],_va_)[_va_ + 1] * 2 | 0,
         _vc_=_d_(caml_call1(sprintf(_na_),_vb_),_u$_),
         _vd_=caml_call1(unpack_flt,l[6]),
         _ve_=_d_(caml_call1(sprintf(_nb_),_vd_),_vc_),
         _vf_=l[1],
         _vg_=_d_(caml_call1(sprintf(_nc_),_vf_),_ve_),
         _vh_=l[7],
         _vi_=_d_(caml_call1(sprintf(_nd_),_vh_),_vg_);
        return _d_(caml_call2(sprintf(_ne_),in_str,out_str),_vi_)}
      function to_name$29(param){return _nf_}
      var
       Normalisation=
        [0,
         create$29,
         connect$27,
         init$9,
         reset$8,
         mktag$8,
         mkpar$8,
         mkpri$8,
         mkadj$8,
         update$8,
         copy$29,
         run$29,
         to_string$29,
         to_name$29];
      function create$30(sigma){return [0,sigma,[0],[0]]}
      function connect$28(out_shape,l)
       {l[2] = copy(out_shape);l[3] = copy(out_shape);return 0}
      function copy$30(l){return create$30(l[1])}
      function run$30(x,l)
       {var
         s=caml_call1(shape,x),
         match=caml_call1(primal$0,x),
         a=1 === match[0]?caml_call3(Arr[5],0,[0,l[1]],s):failwith(_ng_);
        return caml_call2(Maths[4],x,a)}
      function to_string$30(l)
       {var
         in_str=string_of_array(0,0,0,string_of_int,l[2]),
         out_str=string_of_array(0,0,0,string_of_int,l[3]),
         _u5_=l[1],
         _u6_=caml_call1(sprintf(_nh_),_u5_);
        return _d_(caml_call2(sprintf(_ni_),in_str,out_str),_u6_)}
      function to_name$30(param){return _nj_}
      var
       GaussianNoise=
        [0,create$30,connect$28,copy$30,run$30,to_string$30,to_name$30];
      function create$31(rate){return [0,rate,[0],[0]]}
      function connect$29(out_shape,l)
       {l[2] = copy(out_shape);l[3] = copy(out_shape);return 0}
      function copy$31(l){return create$31(l[1])}
      function run$31(x,l)
       {var
         s=caml_call1(shape,x),
         sigma=Math.sqrt(l[1] / (1 - l[1])),
         match=caml_call1(primal$0,x),
         a=1 === match[0]?caml_call3(Arr[5],0,[0,sigma],s):failwith(_nk_),
         _u4_=caml_call2(Maths[4],a,_nl_);
        return caml_call2(Maths[8],x,_u4_)}
      function to_string$31(l)
       {var
         in_str=string_of_array(0,0,0,string_of_int,l[2]),
         out_str=string_of_array(0,0,0,string_of_int,l[3]),
         _u2_=l[1],
         _u3_=caml_call1(sprintf(_nm_),_u2_);
        return _d_(caml_call2(sprintf(_nn_),in_str,out_str),_u3_)}
      function to_name$31(param){return _no_}
      var
       GaussianDropout=
        [0,create$31,connect$29,copy$31,run$31,to_string$31,to_name$31];
      function create$32(rate){return [0,rate,[0],[0]]}
      function connect$30(out_shape,l)
       {l[2] = copy(out_shape);l[3] = copy(out_shape);return 0}
      function copy$32(l){return create$32(l[1])}
      function run$32(x,l)
       {var
         p=-1.67326324235437718 * 1.05070098735548045,
         a=Math.pow((1 - l[1]) * (1 + l[1] * Math.pow(p,2)),-0.5),
         b=-a * p * l[1],
         s=caml_call1(shape,x),
         match=caml_call1(primal$0,x);
        if(1 === match[0])
         var c=caml_call3(A[6],0,0,s),mask=[1,caml_call2(A[140],c,l[1])];
        else
         var mask=failwith(_np_);
        var
         p$0=[0,p],
         a$0=[0,a],
         b$0=[0,b],
         _uY_=caml_call2(Maths[6],_nq_,mask),
         _uZ_=caml_call2(Maths[8],p$0,_uY_),
         _u0_=caml_call2(Maths[8],x,mask),
         x$0=caml_call2(Maths[4],_u0_,_uZ_),
         _u1_=caml_call2(Maths[8],a$0,x$0);
        return caml_call2(Maths[4],_u1_,b$0)}
      function to_string$32(l)
       {var
         in_str=string_of_array(0,0,0,string_of_int,l[2]),
         out_str=string_of_array(0,0,0,string_of_int,l[3]),
         _uW_=l[1],
         _uX_=caml_call1(sprintf(_nr_),_uW_);
        return _d_(caml_call2(sprintf(_ns_),in_str,out_str),_uX_)}
      function to_name$32(param){return _nt_}
      var
       AlphaDropout=
        [0,create$32,connect$30,copy$32,run$32,to_string$32,to_name$32];
      function create$33(inputs,in_dim,out_dim,init_typ)
       {if(inputs)var i=inputs[1],i$0=i;else var i$0=0;
        return [0,
                caml_call2(Mat[1],0,0),
                init_typ,
                in_dim,
                [0,i$0],
                [0,i$0,out_dim]]}
      function connect$31(out_shape,l)
       {if(1 === out_shape.length - 1)
         {var _uU_=caml_check_bound(out_shape,0)[1];
          caml_check_bound(l[4],0)[1] = _uU_;
          var _uV_=caml_check_bound(out_shape,0)[1];
          return caml_check_bound(l[5],0)[1] = _uV_}
        throw [0,Assert_failure,_nu_]}
      function init$10(l)
       {var m=l[3],n=caml_check_bound(l[5],1)[2];
        l[1] = caml_call3(Init[2],l[2],[0,m,n],l[1]);
        return 0}
      function reset$9(l){return caml_call1(Mat[6],l[1])}
      function mktag$9(t,l){l[1] = caml_call2(make_reverse,l[1],t);return 0}
      function mkpar$9(l){return [0,l[1]]}
      function mkpri$9(l){return [0,caml_call1(primal,l[1])]}
      function mkadj$9(l){return [0,caml_call1(adjval,l[1])]}
      function update$9(l,u)
       {l[1] = caml_call1(primal$0,caml_check_bound(u,0)[1]);return 0}
      function copy$33(l)
       {var
         _uS_=l[2],
         _uT_=caml_check_bound(l[5],1)[2],
         l$0=create$33(0,l[3],_uT_,_uS_);
        update$9(l$0,map$0(copy_primal,mkpri$9(l)));
        return l$0}
      function run$33(x,l)
       {var
         x$0=caml_call1(unpack_arr,caml_call1(primal$0,x)),
         s=caml_call1(A[10],x$0),
         n=caml_check_bound(s,1)[2],
         m=caml_check_bound(s,0)[1],
         y=caml_call1(A[2],[0,caml_mul(m,n),l[3]]),
         i=[0,0],
         _uM_=m - 1 | 0,
         _uL_=0;
        if(!(_uM_ < 0))
         {var i$0=_uL_;
          for(;;)
           {i[1] = caml_mul(i$0,n);
            var _uP_=n - 1 | 0,_uO_=0;
            if(!(_uP_ < 0))
             {var j=_uO_;
              for(;;)
               {var k=caml_call2(A[12],x$0,[0,i$0,j]) | 0;
                caml_call3(A[13],y,[0,i[1] + j | 0,k],1);
                var _uR_=j + 1 | 0;
                if(_uP_ !== j){var j=_uR_;continue}
                break}}
            var _uQ_=i$0 + 1 | 0;
            if(_uM_ !== i$0){var i$0=_uQ_;continue}
            break}}
        var
         y$0=caml_call2(Maths[49],[1,y],l[1]),
         _uN_=[0,m,n,caml_check_bound(l[5],1)[2]];
        return caml_call2(Maths[75],y$0,_uN_)}
      function to_string$33(l)
       {var
         wn=caml_check_bound(l[5],1)[2],
         wm=l[3],
         _uC_=_d_(caml_call2(sprintf(_nw_),wm,wn),_nv_),
         _uD_=_d_(caml_call1(sprintf(_nx_),caml_mul(wm,wn)),_uC_),
         _uE_=l[3],
         _uF_=_d_(caml_call1(sprintf(_ny_),_uE_),_uD_),
         _uG_=caml_call1(Init[3],l[2]),
         _uH_=_d_(caml_call1(sprintf(_nz_),_uG_),_uF_),
         _uI_=caml_check_bound(l[5],1)[2],
         _uJ_=caml_check_bound(l[5],0)[1],
         _uK_=caml_check_bound(l[4],0)[1];
        return _d_(caml_call3(sprintf(_nA_),_uK_,_uJ_,_uI_),_uH_)}
      function to_name$33(param){return _nB_}
      var
       Embedding=
        [0,
         create$33,
         connect$31,
         init$10,
         reset$9,
         mktag$9,
         mkpar$9,
         mkpri$9,
         mkadj$9,
         update$9,
         copy$33,
         run$33,
         to_string$33,
         to_name$33],
       Masking=[0];
      function get_in_out_shape(param)
       {switch(param[0])
         {case 0:var l=param[1];return [0,l[1],l[2]];
          case 1:var l$0=param[1];return [0,l$0[4],l$0[5]];
          case 2:var l$1=param[1];return [0,l$1[3],l$1[4]];
          case 3:var l$2=param[1];return [0,l$2[4],l$2[5]];
          case 4:var l$3=param[1];return [0,l$3[16],l$3[17]];
          case 5:var l$4=param[1];return [0,l$4[12],l$4[13]];
          case 6:var l$5=param[1];return [0,l$5[10],l$5[11]];
          case 7:var l$6=param[1];return [0,l$6[7],l$6[8]];
          case 8:var l$7=param[1];return [0,l$7[7],l$7[8]];
          case 9:var l$8=param[1];return [0,l$8[7],l$8[8]];
          case 10:var l$9=param[1];return [0,l$9[4],l$9[5]];
          case 11:var l$10=param[1];return [0,l$10[4],l$10[5]];
          case 12:var l$11=param[1];return [0,l$11[4],l$11[5]];
          case 13:var l$12=param[1];return [0,l$12[4],l$12[5]];
          case 14:var l$13=param[1];return [0,l$13[4],l$13[5]];
          case 15:var l$14=param[1];return [0,l$14[1],l$14[2]];
          case 16:var l$15=param[1];return [0,l$15[1],l$15[2]];
          case 17:var l$16=param[1];return [0,l$16[1],l$16[2]];
          case 18:var l$17=param[1];return [0,l$17[1],l$17[2]];
          case 19:var l$18=param[1];return [0,l$18[2],l$18[3]];
          case 20:var l$19=param[1];return [0,l$19[1],l$19[2]];
          case 21:var l$20=param[1];return [0,l$20[1],l$20[2]];
          case 22:var l$21=param[1];return [0,l$21[2],l$21[3]];
          case 23:var l$22=param[1];return [0,l$22[2],l$22[3]];
          case 24:var l$23=param[1];return [0,l$23[2],l$23[3]];
          case 25:var l$24=param[1];return [0,l$24[2],l$24[3]];
          case 26:var l$25=param[1];return [0,l$25[2],l$25[3]];
          case 27:var l$26=param[1];return [0,l$26[8],l$26[9]];
          case 28:var l$27=param[1];return [0,l$27[1],l$27[2]];
          case 29:var l$28=param[1];return [0,l$28[1],l$28[2]];
          case 30:var l$29=param[1];return [0,l$29[1],l$29[2]];
          case 31:var l$30=param[1];return [0,l$30[1],l$30[2]];
          case 32:var l$31=param[1];return [0,l$31[1],l$31[2]];
          default:var l$32=param[1];return [0,l$32[2],l$32[3]]}}
      function get_in_shape(x){return get_in_out_shape(x)[1]}
      function get_out_shape(x){return get_in_out_shape(x)[2]}
      function connect$32(out_shapes,l)
       {switch(l[0])
         {case 0:return 0;
          case 1:
           var l$0=l[1],_ub_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(Linear[2],_ub_,l$0);
          case 2:
           var l$1=l[1],_uc_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(LinearNoBias[2],_uc_,l$1);
          case 3:
           var l$2=l[1],_ud_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(Embedding[2],_ud_,l$2);
          case 4:
           var l$3=l[1],_ue_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(LSTM[2],_ue_,l$3);
          case 5:
           var l$4=l[1],_uf_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(GRU[2],_uf_,l$4);
          case 6:
           var l$5=l[1],_ug_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(Recurrent[2],_ug_,l$5);
          case 7:
           var l$6=l[1],_uh_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(Conv1D[2],_uh_,l$6);
          case 8:
           var l$7=l[1],_ui_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(Conv2D[2],_ui_,l$7);
          case 9:
           var l$8=l[1],_uj_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(Conv3D[2],_uj_,l$8);
          case 10:
           var l$9=l[1],_uk_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(FullyConnected[2],_uk_,l$9);
          case 11:
           var l$10=l[1],_ul_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(MaxPool1D[2],_ul_,l$10);
          case 12:
           var l$11=l[1],_um_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(MaxPool2D[2],_um_,l$11);
          case 13:
           var l$12=l[1],_un_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(AvgPool1D[2],_un_,l$12);
          case 14:
           var l$13=l[1],_uo_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(AvgPool2D[2],_uo_,l$13);
          case 15:
           var l$14=l[1],_up_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(GlobalMaxPool1D[2],_up_,l$14);
          case 16:
           var l$15=l[1],_uq_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(GlobalMaxPool2D[2],_uq_,l$15);
          case 17:
           var l$16=l[1],_ur_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(GlobalAvgPool1D[2],_ur_,l$16);
          case 18:
           var l$17=l[1],_us_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(GlobalAvgPool2D[2],_us_,l$17);
          case 19:
           var l$18=l[1],_ut_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(Dropout[2],_ut_,l$18);
          case 20:
           var l$19=l[1],_uu_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(Reshape[2],_uu_,l$19);
          case 21:
           var l$20=l[1],_uv_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(Flatten[2],_uv_,l$20);
          case 22:
           var l$21=l[1],_uw_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(Lambda[2],_uw_,l$21);
          case 23:
           var l$22=l[1],_ux_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(Activation[2],_ux_,l$22);
          case 24:
           var l$23=l[1],_uy_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(GaussianNoise[2],_uy_,l$23);
          case 25:
           var l$24=l[1],_uz_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(GaussianDropout[2],_uz_,l$24);
          case 26:
           var l$25=l[1],_uA_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(AlphaDropout[2],_uA_,l$25);
          case 27:
           var l$26=l[1],_uB_=caml_check_bound(out_shapes,0)[1];
           return caml_call2(Normalisation[2],_uB_,l$26);
          case 28:var l$27=l[1];return caml_call2(Add[2],out_shapes,l$27);
          case 29:var l$28=l[1];return caml_call2(Mul[2],out_shapes,l$28);
          case 30:var l$29=l[1];return caml_call2(Dot[2],out_shapes,l$29);
          case 31:var l$30=l[1];return caml_call2(Max[2],out_shapes,l$30);
          case 32:var l$31=l[1];return caml_call2(Average[2],out_shapes,l$31);
          default:
           var l$32=l[1];return caml_call2(Concatenate[2],out_shapes,l$32)}}
      function init$11(param)
       {switch(param[0])
         {case 1:var l=param[1];return caml_call1(Linear[3],l);
          case 2:var l$0=param[1];return caml_call1(LinearNoBias[3],l$0);
          case 3:var l$1=param[1];return caml_call1(Embedding[3],l$1);
          case 4:var l$2=param[1];return caml_call1(LSTM[3],l$2);
          case 5:var l$3=param[1];return caml_call1(GRU[3],l$3);
          case 6:var l$4=param[1];return caml_call1(Recurrent[3],l$4);
          case 7:var l$5=param[1];return caml_call1(Conv1D[3],l$5);
          case 8:var l$6=param[1];return caml_call1(Conv2D[3],l$6);
          case 9:var l$7=param[1];return caml_call1(Conv3D[3],l$7);
          case 10:var l$8=param[1];return caml_call1(FullyConnected[3],l$8);
          case 27:var l$9=param[1];return caml_call1(Normalisation[3],l$9);
          default:return 0}}
      function reset$10(param)
       {switch(param[0])
         {case 1:var l=param[1];return caml_call1(Linear[4],l);
          case 2:var l$0=param[1];return caml_call1(LinearNoBias[4],l$0);
          case 3:var l$1=param[1];return caml_call1(Embedding[4],l$1);
          case 4:var l$2=param[1];return caml_call1(LSTM[4],l$2);
          case 5:var l$3=param[1];return caml_call1(GRU[4],l$3);
          case 6:var l$4=param[1];return caml_call1(Recurrent[4],l$4);
          case 7:var l$5=param[1];return caml_call1(Conv1D[4],l$5);
          case 8:var l$6=param[1];return caml_call1(Conv2D[4],l$6);
          case 9:var l$7=param[1];return caml_call1(Conv3D[4],l$7);
          case 10:var l$8=param[1];return caml_call1(FullyConnected[4],l$8);
          case 27:var l$9=param[1];return caml_call1(Normalisation[4],l$9);
          default:return 0}}
      function mktag$10(t,param)
       {switch(param[0])
         {case 1:var l=param[1];return caml_call2(Linear[5],t,l);
          case 2:var l$0=param[1];return caml_call2(LinearNoBias[5],t,l$0);
          case 3:var l$1=param[1];return caml_call2(Embedding[5],t,l$1);
          case 4:var l$2=param[1];return caml_call2(LSTM[5],t,l$2);
          case 5:var l$3=param[1];return caml_call2(GRU[5],t,l$3);
          case 6:var l$4=param[1];return caml_call2(Recurrent[5],t,l$4);
          case 7:var l$5=param[1];return caml_call2(Conv1D[5],t,l$5);
          case 8:var l$6=param[1];return caml_call2(Conv2D[5],t,l$6);
          case 9:var l$7=param[1];return caml_call2(Conv3D[5],t,l$7);
          case 10:var l$8=param[1];return caml_call2(FullyConnected[5],t,l$8);
          case 27:var l$9=param[1];return caml_call2(Normalisation[5],t,l$9);
          default:return 0}}
      function mkpar$10(param)
       {switch(param[0])
         {case 1:var l=param[1];return caml_call1(Linear[6],l);
          case 2:var l$0=param[1];return caml_call1(LinearNoBias[6],l$0);
          case 3:var l$1=param[1];return caml_call1(Embedding[6],l$1);
          case 4:var l$2=param[1];return caml_call1(LSTM[6],l$2);
          case 5:var l$3=param[1];return caml_call1(GRU[6],l$3);
          case 6:var l$4=param[1];return caml_call1(Recurrent[6],l$4);
          case 7:var l$5=param[1];return caml_call1(Conv1D[6],l$5);
          case 8:var l$6=param[1];return caml_call1(Conv2D[6],l$6);
          case 9:var l$7=param[1];return caml_call1(Conv3D[6],l$7);
          case 10:var l$8=param[1];return caml_call1(FullyConnected[6],l$8);
          case 27:var l$9=param[1];return caml_call1(Normalisation[6],l$9);
          default:return [0]}}
      function mkpri$10(param)
       {switch(param[0])
         {case 1:var l=param[1];return caml_call1(Linear[7],l);
          case 2:var l$0=param[1];return caml_call1(LinearNoBias[7],l$0);
          case 3:var l$1=param[1];return caml_call1(Embedding[7],l$1);
          case 4:var l$2=param[1];return caml_call1(LSTM[7],l$2);
          case 5:var l$3=param[1];return caml_call1(GRU[7],l$3);
          case 6:var l$4=param[1];return caml_call1(Recurrent[7],l$4);
          case 7:var l$5=param[1];return caml_call1(Conv1D[7],l$5);
          case 8:var l$6=param[1];return caml_call1(Conv2D[7],l$6);
          case 9:var l$7=param[1];return caml_call1(Conv3D[7],l$7);
          case 10:var l$8=param[1];return caml_call1(FullyConnected[7],l$8);
          case 27:var l$9=param[1];return caml_call1(Normalisation[7],l$9);
          default:return [0]}}
      function mkadj$10(param)
       {switch(param[0])
         {case 1:var l=param[1];return caml_call1(Linear[8],l);
          case 2:var l$0=param[1];return caml_call1(LinearNoBias[8],l$0);
          case 3:var l$1=param[1];return caml_call1(Embedding[8],l$1);
          case 4:var l$2=param[1];return caml_call1(LSTM[8],l$2);
          case 5:var l$3=param[1];return caml_call1(GRU[8],l$3);
          case 6:var l$4=param[1];return caml_call1(Recurrent[8],l$4);
          case 7:var l$5=param[1];return caml_call1(Conv1D[8],l$5);
          case 8:var l$6=param[1];return caml_call1(Conv2D[8],l$6);
          case 9:var l$7=param[1];return caml_call1(Conv3D[8],l$7);
          case 10:var l$8=param[1];return caml_call1(FullyConnected[8],l$8);
          case 27:var l$9=param[1];return caml_call1(Normalisation[8],l$9);
          default:return [0]}}
      function update$10(l,u)
       {switch(l[0])
         {case 1:var l$0=l[1];return caml_call2(Linear[9],l$0,u);
          case 2:var l$1=l[1];return caml_call2(LinearNoBias[9],l$1,u);
          case 3:var l$2=l[1];return caml_call2(Embedding[9],l$2,u);
          case 4:var l$3=l[1];return caml_call2(LSTM[9],l$3,u);
          case 5:var l$4=l[1];return caml_call2(GRU[9],l$4,u);
          case 6:var l$5=l[1];return caml_call2(Recurrent[9],l$5,u);
          case 7:var l$6=l[1];return caml_call2(Conv1D[9],l$6,u);
          case 8:var l$7=l[1];return caml_call2(Conv2D[9],l$7,u);
          case 9:var l$8=l[1];return caml_call2(Conv3D[9],l$8,u);
          case 10:var l$9=l[1];return caml_call2(FullyConnected[9],l$9,u);
          case 27:var l$10=l[1];return caml_call2(Normalisation[9],l$10,u);
          default:return 0}}
      function copy$34(param)
       {switch(param[0])
         {case 0:var l=param[1];return [0,caml_call1(Input[2],l)];
          case 1:var l$0=param[1];return [1,caml_call1(Linear[10],l$0)];
          case 2:var l$1=param[1];return [2,caml_call1(LinearNoBias[10],l$1)];
          case 3:var l$2=param[1];return [3,caml_call1(Embedding[10],l$2)];
          case 4:var l$3=param[1];return [4,caml_call1(LSTM[10],l$3)];
          case 5:var l$4=param[1];return [5,caml_call1(GRU[10],l$4)];
          case 6:var l$5=param[1];return [6,caml_call1(Recurrent[10],l$5)];
          case 7:var l$6=param[1];return [7,caml_call1(Conv1D[10],l$6)];
          case 8:var l$7=param[1];return [8,caml_call1(Conv2D[10],l$7)];
          case 9:var l$8=param[1];return [9,caml_call1(Conv3D[10],l$8)];
          case 10:
           var l$9=param[1];return [10,caml_call1(FullyConnected[10],l$9)];
          case 11:var l$10=param[1];return [11,caml_call1(MaxPool1D[3],l$10)];
          case 12:var l$11=param[1];return [12,caml_call1(MaxPool2D[3],l$11)];
          case 13:var l$12=param[1];return [13,caml_call1(AvgPool1D[3],l$12)];
          case 14:var l$13=param[1];return [14,caml_call1(AvgPool2D[3],l$13)];
          case 15:
           var l$14=param[1];return [15,caml_call1(GlobalMaxPool1D[3],l$14)];
          case 16:
           var l$15=param[1];return [16,caml_call1(GlobalMaxPool2D[3],l$15)];
          case 17:
           var l$16=param[1];return [17,caml_call1(GlobalAvgPool1D[3],l$16)];
          case 18:
           var l$17=param[1];return [18,caml_call1(GlobalAvgPool2D[3],l$17)];
          case 19:var l$18=param[1];return [19,caml_call1(Dropout[3],l$18)];
          case 20:var l$19=param[1];return [20,caml_call1(Reshape[3],l$19)];
          case 21:var l$20=param[1];return [21,caml_call1(Flatten[3],l$20)];
          case 22:var l$21=param[1];return [22,caml_call1(Lambda[3],l$21)];
          case 23:
           var l$22=param[1];return [23,caml_call1(Activation[4],l$22)];
          case 24:
           var l$23=param[1];return [24,caml_call1(GaussianNoise[3],l$23)];
          case 25:
           var l$24=param[1];return [25,caml_call1(GaussianDropout[3],l$24)];
          case 26:
           var l$25=param[1];return [26,caml_call1(AlphaDropout[3],l$25)];
          case 27:
           var l$26=param[1];return [27,caml_call1(Normalisation[10],l$26)];
          case 28:var l$27=param[1];return [28,caml_call1(Add[3],l$27)];
          case 29:var l$28=param[1];return [29,caml_call1(Mul[3],l$28)];
          case 30:var l$29=param[1];return [30,caml_call1(Dot[3],l$29)];
          case 31:var l$30=param[1];return [31,caml_call1(Max[3],l$30)];
          case 32:var l$31=param[1];return [32,caml_call1(Average[3],l$31)];
          default:
           var l$32=param[1];return [33,caml_call1(Concatenate[3],l$32)]}}
      function run$34(a,l)
       {switch(l[0])
         {case 0:
           var l$0=l[1],_tL_=caml_check_bound(a,0)[1];
           return caml_call2(Input[3],_tL_,l$0);
          case 1:
           var l$1=l[1],_tM_=caml_check_bound(a,0)[1];
           return caml_call2(Linear[11],_tM_,l$1);
          case 2:
           var l$2=l[1],_tN_=caml_check_bound(a,0)[1];
           return caml_call2(LinearNoBias[11],_tN_,l$2);
          case 3:
           var l$3=l[1],_tO_=caml_check_bound(a,0)[1];
           return caml_call2(Embedding[11],_tO_,l$3);
          case 4:
           var l$4=l[1],_tP_=caml_check_bound(a,0)[1];
           return caml_call2(LSTM[11],_tP_,l$4);
          case 5:
           var l$5=l[1],_tQ_=caml_check_bound(a,0)[1];
           return caml_call2(GRU[11],_tQ_,l$5);
          case 6:
           var l$6=l[1],_tR_=caml_check_bound(a,0)[1];
           return caml_call2(Recurrent[11],_tR_,l$6);
          case 7:
           var l$7=l[1],_tS_=caml_check_bound(a,0)[1];
           return caml_call2(Conv1D[11],_tS_,l$7);
          case 8:
           var l$8=l[1],_tT_=caml_check_bound(a,0)[1];
           return caml_call2(Conv2D[11],_tT_,l$8);
          case 9:
           var l$9=l[1],_tU_=caml_check_bound(a,0)[1];
           return caml_call2(Conv3D[11],_tU_,l$9);
          case 10:
           var l$10=l[1],_tV_=caml_check_bound(a,0)[1];
           return caml_call2(FullyConnected[11],_tV_,l$10);
          case 11:
           var l$11=l[1],_tW_=caml_check_bound(a,0)[1];
           return caml_call2(MaxPool1D[4],_tW_,l$11);
          case 12:
           var l$12=l[1],_tX_=caml_check_bound(a,0)[1];
           return caml_call2(MaxPool2D[4],_tX_,l$12);
          case 13:
           var l$13=l[1],_tY_=caml_check_bound(a,0)[1];
           return caml_call2(AvgPool1D[4],_tY_,l$13);
          case 14:
           var l$14=l[1],_tZ_=caml_check_bound(a,0)[1];
           return caml_call2(AvgPool2D[4],_tZ_,l$14);
          case 15:
           var l$15=l[1],_t0_=caml_check_bound(a,0)[1];
           return caml_call2(GlobalMaxPool1D[4],_t0_,l$15);
          case 16:
           var l$16=l[1],_t1_=caml_check_bound(a,0)[1];
           return caml_call2(GlobalMaxPool2D[4],_t1_,l$16);
          case 17:
           var l$17=l[1],_t2_=caml_check_bound(a,0)[1];
           return caml_call2(GlobalAvgPool1D[4],_t2_,l$17);
          case 18:
           var l$18=l[1],_t3_=caml_check_bound(a,0)[1];
           return caml_call2(GlobalAvgPool2D[4],_t3_,l$18);
          case 19:
           var l$19=l[1],_t4_=caml_check_bound(a,0)[1];
           return caml_call2(Dropout[4],_t4_,l$19);
          case 20:
           var l$20=l[1],_t5_=caml_check_bound(a,0)[1];
           return caml_call2(Reshape[4],_t5_,l$20);
          case 21:
           var l$21=l[1],_t6_=caml_check_bound(a,0)[1];
           return caml_call2(Flatten[4],_t6_,l$21);
          case 22:
           var l$22=l[1],_t7_=caml_check_bound(a,0)[1];
           return caml_call2(Lambda[4],_t7_,l$22);
          case 23:
           var l$23=l[1],_t8_=caml_check_bound(a,0)[1];
           return caml_call2(Activation[5],_t8_,l$23);
          case 24:
           var l$24=l[1],_t9_=caml_check_bound(a,0)[1];
           return caml_call2(GaussianNoise[4],_t9_,l$24);
          case 25:
           var l$25=l[1],_t__=caml_check_bound(a,0)[1];
           return caml_call2(GaussianDropout[4],_t__,l$25);
          case 26:
           var l$26=l[1],_t$_=caml_check_bound(a,0)[1];
           return caml_call2(AlphaDropout[4],_t$_,l$26);
          case 27:
           var l$27=l[1],_ua_=caml_check_bound(a,0)[1];
           return caml_call2(Normalisation[11],_ua_,l$27);
          case 28:var l$28=l[1];return caml_call2(Add[4],a,l$28);
          case 29:var l$29=l[1];return caml_call2(Mul[4],a,l$29);
          case 30:var l$30=l[1];return caml_call2(Dot[4],a,l$30);
          case 31:var l$31=l[1];return caml_call2(Max[4],a,l$31);
          case 32:var l$32=l[1];return caml_call2(Average[4],a,l$32);
          default:var l$33=l[1];return caml_call2(Concatenate[4],a,l$33)}}
      function to_string$34(param)
       {switch(param[0])
         {case 0:var l=param[1];return caml_call1(Input[4],l);
          case 1:var l$0=param[1];return caml_call1(Linear[12],l$0);
          case 2:var l$1=param[1];return caml_call1(LinearNoBias[12],l$1);
          case 3:var l$2=param[1];return caml_call1(Embedding[12],l$2);
          case 4:var l$3=param[1];return caml_call1(LSTM[12],l$3);
          case 5:var l$4=param[1];return caml_call1(GRU[12],l$4);
          case 6:var l$5=param[1];return caml_call1(Recurrent[12],l$5);
          case 7:var l$6=param[1];return caml_call1(Conv1D[12],l$6);
          case 8:var l$7=param[1];return caml_call1(Conv2D[12],l$7);
          case 9:var l$8=param[1];return caml_call1(Conv3D[12],l$8);
          case 10:var l$9=param[1];return caml_call1(FullyConnected[12],l$9);
          case 11:var l$10=param[1];return caml_call1(MaxPool1D[5],l$10);
          case 12:var l$11=param[1];return caml_call1(MaxPool2D[5],l$11);
          case 13:var l$12=param[1];return caml_call1(AvgPool1D[5],l$12);
          case 14:var l$13=param[1];return caml_call1(AvgPool2D[5],l$13);
          case 15:
           var l$14=param[1];return caml_call1(GlobalMaxPool1D[5],l$14);
          case 16:
           var l$15=param[1];return caml_call1(GlobalMaxPool2D[5],l$15);
          case 17:
           var l$16=param[1];return caml_call1(GlobalAvgPool1D[5],l$16);
          case 18:
           var l$17=param[1];return caml_call1(GlobalAvgPool2D[5],l$17);
          case 19:var l$18=param[1];return caml_call1(Dropout[5],l$18);
          case 20:var l$19=param[1];return caml_call1(Reshape[5],l$19);
          case 21:var l$20=param[1];return caml_call1(Flatten[5],l$20);
          case 22:var l$21=param[1];return caml_call1(Lambda[5],l$21);
          case 23:var l$22=param[1];return caml_call1(Activation[7],l$22);
          case 24:var l$23=param[1];return caml_call1(GaussianNoise[5],l$23);
          case 25:
           var l$24=param[1];return caml_call1(GaussianDropout[5],l$24);
          case 26:var l$25=param[1];return caml_call1(AlphaDropout[5],l$25);
          case 27:var l$26=param[1];return caml_call1(Normalisation[12],l$26);
          case 28:var l$27=param[1];return caml_call1(Add[5],l$27);
          case 29:var l$28=param[1];return caml_call1(Mul[5],l$28);
          case 30:var l$29=param[1];return caml_call1(Dot[5],l$29);
          case 31:var l$30=param[1];return caml_call1(Max[5],l$30);
          case 32:var l$31=param[1];return caml_call1(Average[5],l$31);
          default:var l$32=param[1];return caml_call1(Concatenate[5],l$32)}}
      function to_name$34(param)
       {switch(param[0])
         {case 0:return caml_call1(Input[5],0);
          case 1:return caml_call1(Linear[13],0);
          case 2:return caml_call1(LinearNoBias[13],0);
          case 3:return caml_call1(Embedding[13],0);
          case 4:return caml_call1(LSTM[13],0);
          case 5:return caml_call1(GRU[13],0);
          case 6:return caml_call1(Recurrent[13],0);
          case 7:return caml_call1(Conv1D[13],0);
          case 8:return caml_call1(Conv2D[13],0);
          case 9:return caml_call1(Conv3D[13],0);
          case 10:return caml_call1(FullyConnected[13],0);
          case 11:return caml_call1(MaxPool1D[6],0);
          case 12:return caml_call1(MaxPool2D[6],0);
          case 13:return caml_call1(AvgPool1D[6],0);
          case 14:return caml_call1(AvgPool2D[6],0);
          case 15:return caml_call1(GlobalMaxPool1D[6],0);
          case 16:return caml_call1(GlobalMaxPool2D[6],0);
          case 17:return caml_call1(GlobalAvgPool1D[6],0);
          case 18:return caml_call1(GlobalAvgPool2D[6],0);
          case 19:return caml_call1(Dropout[6],0);
          case 20:return caml_call1(Reshape[6],0);
          case 21:return caml_call1(Flatten[6],0);
          case 22:return caml_call1(Lambda[6],0);
          case 23:return caml_call1(Activation[8],0);
          case 24:return caml_call1(GaussianNoise[6],0);
          case 25:return caml_call1(GaussianDropout[6],0);
          case 26:return caml_call1(AlphaDropout[6],0);
          case 27:return caml_call1(Normalisation[13],0);
          case 28:return caml_call1(Add[6],0);
          case 29:return caml_call1(Mul[6],0);
          case 30:return caml_call1(Dot[6],0);
          case 31:return caml_call1(Max[6],0);
          case 32:return caml_call1(Average[6],0);
          default:return caml_call1(Concatenate[6],0)}}
      var
       Neuron=
        [0,
         global_tag,
         tag,
         cmp_tag,
         reset_zero,
         primal,
         primal$0,
         zero,
         tangent,
         adjref,
         adjval,
         shape,
         row_num,
         col_num,
         numel,
         clip_by_value,
         clip_by_l2norm,
         copy_primal,
         tile,
         repeat,
         pack_arr,
         unpack_arr,
         pack_flt,
         unpack_flt,
         deep_info,
         type_info,
         error_binop,
         error_uniop,
         Maths,
         reverse_reset,
         reverse_push,
         reverse_prop,
         make_forward,
         make_reverse,
         diff,
         diff$0,
         grad,
         grad$0,
         jacobianv,
         jacobianv$0,
         jacobianTv,
         jacobianTv$0,
         jacobian,
         jacobian$0,
         gradhessian,
         gradhessian$0,
         hessian,
         hessian$0,
         gradhessianv,
         gradhessianv$0,
         hessianv,
         hessianv$0,
         laplacian,
         laplacian$0,
         Mat,
         Arr,
         traverse_trace,
         convert_terminal_output,
         convert_dot_output,
         to_trace,
         to_dot,
         pp_num,
         Init,
         Input,
         Activation,
         Linear,
         LinearNoBias,
         Recurrent,
         LSTM,
         GRU,
         Conv1D,
         Conv2D,
         Conv3D,
         FullyConnected,
         MaxPool1D,
         MaxPool2D,
         AvgPool1D,
         AvgPool2D,
         GlobalMaxPool1D,
         GlobalMaxPool2D,
         GlobalAvgPool1D,
         GlobalAvgPool2D,
         UpSampling1D,
         UpSampling2D,
         UpSampling3D,
         Padding1D,
         Padding2D,
         Padding3D,
         Lambda,
         Dropout,
         Reshape,
         Flatten,
         Add,
         Mul,
         Dot,
         Max,
         Average,
         Concatenate,
         Normalisation,
         GaussianNoise,
         GaussianDropout,
         AlphaDropout,
         Embedding,
         Masking,
         get_in_out_shape,
         get_in_shape,
         get_out_shape,
         connect$32,
         init$11,
         reset$10,
         mktag$10,
         mkpar$10,
         mkpri$10,
         mkadj$10,
         update$10,
         copy$34,
         run$34,
         to_string$34,
         to_name$34],
       include$0=Make(A),
       global_tag$0=include$0[1],
       tag$0=include$0[2],
       cmp_tag$0=include$0[3],
       reset_zero$0=include$0[4],
       primal$1=include$0[5],
       primal$2=include$0[6],
       zero$0=include$0[7],
       tangent$0=include$0[8],
       adjref$0=include$0[9],
       adjval$0=include$0[10],
       shape$0=include$0[11],
       row_num$0=include$0[12],
       col_num$0=include$0[13],
       numel$0=include$0[14],
       clip_by_value$0=include$0[15],
       clip_by_l2norm$0=include$0[16],
       copy_primal$0=include$0[17],
       tile$0=include$0[18],
       repeat$0=include$0[19],
       pack_arr$0=include$0[20],
       unpack_arr$0=include$0[21],
       pack_flt$0=include$0[22],
       unpack_flt$0=include$0[23],
       deep_info$0=include$0[24],
       type_info$0=include$0[25],
       error_binop$0=include$0[26],
       error_uniop$0=include$0[27],
       Maths$0=include$0[28],
       reverse_reset$0=include$0[29],
       reverse_push$0=include$0[30],
       reverse_prop$0=include$0[31],
       make_forward$0=include$0[32],
       make_reverse$0=include$0[33],
       diff$1=include$0[34],
       diff$2=include$0[35],
       grad$1=include$0[36],
       grad$2=include$0[37],
       jacobianv$1=include$0[38],
       jacobianv$2=include$0[39],
       jacobianTv$1=include$0[40],
       jacobianTv$2=include$0[41],
       jacobian$1=include$0[42],
       jacobian$2=include$0[43],
       gradhessian$1=include$0[44],
       gradhessian$2=include$0[45],
       hessian$1=include$0[46],
       hessian$2=include$0[47],
       gradhessianv$1=include$0[48],
       gradhessianv$2=include$0[49],
       hessianv$1=include$0[50],
       hessianv$2=include$0[51],
       laplacian$1=include$0[52],
       laplacian$2=include$0[53],
       Mat$0=include$0[54],
       Arr$0=include$0[55],
       traverse_trace$0=include$0[56],
       convert_terminal_output$0=include$0[57],
       convert_dot_output$0=include$0[58],
       to_trace$0=include$0[59],
       to_dot$0=include$0[60],
       pp_num$0=include$0[61];
      function sample_num(x)
       {return 1 === x[0]
                ?caml_check_bound(caml_call1(Arr$0[8],x),0)[1]
                :failwith(_d_(_nC_,caml_call1(type_info$0,x)))}
      function draw_samples(x,match,n)
       {if(1 === x[0])
         if(1 === match[0])
          {var
            y=match[1],
            x$0=x[1],
            match$0=caml_call3(A[24],_nE_,x$0,n),
            i=match$0[2],
            x$1=match$0[1],
            y$0=caml_call2(A[107],y,i);
           return [0,[1,x$1],[1,y$0]]}
        return failwith(_d_(_nD_,caml_call1(type_info$0,x)))}
      function get_chunk(x,match,i,c)
       {if(1 === x[0])
         if(1 === match[0])
          {var
            y=match[1],
            x$0=x[1],
            n=caml_call1(A[104],y),
            a=caml_mod(caml_mul(i,c),n),
            b=min((a + c | 0) - 1 | 0,n - 1 | 0),
            x$1=caml_call2(A[14],[0,[0,a,[0,b,0]],0],x$0),
            y$0=caml_call2(A[14],[0,[0,a,[0,b,0]],0],y);
           return [0,[1,x$1],[1,y$0]]}
        return failwith(_d_(_nF_,caml_call1(type_info$0,x)))}
      var Utils=[0,sample_num,draw_samples,get_chunk];
      function run$35(param)
       {switch(param[0])
         {case 0:
           var a=param[1];
           return function(param,_tG_,c)
            {var
              _tH_=caml_check_bound(c,0)[1],
              _tI_=caml_call2(Maths$0[4],_tH_,_nG_),
              _tJ_=caml_call1(Maths$0[24],_tI_);
             return caml_call2(Maths$0[10],[0,a],_tJ_)};
          case 1:
           var a$0=param[1];return function(param,_tF_,_tE_){return [0,a$0]};
          case 2:
           var k=param[2],a$1=param[1];
           return function(i,param,_tB_)
            {var
              _tC_=caml_call2(Maths$0[8],[0,k],[0,i]),
              _tD_=caml_call2(Maths$0[4],_nH_,_tC_);
             return caml_call2(Maths$0[10],[0,a$1],_tD_)};
          case 3:
           var k$0=param[2],a$2=param[1];
           return function(i,param,_tx_)
            {var
              _ty_=caml_call1(Maths$0[17],[0,k$0]),
              _tz_=caml_call2(Maths$0[8],_ty_,[0,i]),
              _tA_=caml_call1(Maths$0[28],_tz_);
             return caml_call2(Maths$0[8],[0,a$2],_tA_)};
          case 4:
           var a$3=param[1];
           return function(param,_tt_,c)
            {var
              _tu_=caml_check_bound(c,0)[1],
              _tv_=caml_call2(Maths$0[4],_tu_,_nI_),
              _tw_=caml_call1(Maths$0[24],_tv_);
             return caml_call2(Maths$0[10],[0,a$3],_tw_)};
          case 5:
           var b2=param[3],b1=param[2],a$4=param[1];
           return function(i,g,c)
            {var
              _tf_=caml_call2(Maths$0[4],g,_nJ_),
              _tg_=caml_check_bound(c,1)[2],
              _th_=caml_call1(Maths$0[24],_tg_),
              _ti_=caml_call2(Maths$0[4],_th_,_nK_),
              _tj_=caml_check_bound(c,0)[1],
              _tk_=caml_call2(Maths$0[12],[0,b1],[0,i]),
              _tl_=caml_call2(Maths$0[6],_nL_,_tk_),
              _tm_=caml_call2(Maths$0[12],[0,b2],[0,i]),
              _tn_=caml_call2(Maths$0[6],_nM_,_tm_),
              _to_=caml_call1(Maths$0[24],_tn_),
              _tp_=caml_call2(Maths$0[8],[0,a$4],_to_),
              _tq_=caml_call2(Maths$0[10],_tp_,_tl_),
              _tr_=caml_call2(Maths$0[8],_tq_,_tj_),
              _ts_=caml_call2(Maths$0[10],_tr_,_ti_);
             return caml_call2(Maths$0[10],_ts_,_tf_)};
          default:
           var a$5=param[1];
           return function(i,param,_tK_)
            {return [0,caml_array_get(a$5,caml_mod(i,a$5.length - 1))]}}}
      function default$0(param)
       {switch(param[0])
         {case 0:return _nN_;
          case 1:return _nO_;
          case 2:return _nP_;
          case 3:return _nQ_;
          case 4:return _nR_;
          case 5:return _nS_;
          default:return [6,[254,0.001]]}}
      function update_ch(typ,g,c)
       {switch(typ[0])
         {case 0:
           var
            _sZ_=caml_check_bound(c,1)[2],
            _s0_=caml_call2(Maths$0[8],g,g),
            _s1_=caml_check_bound(c,0)[1];
           return [0,caml_call2(Maths$0[4],_s1_,_s0_),_sZ_];
          case 4:
           var
            k=typ[2],
            _s2_=caml_check_bound(c,1)[2],
            _s3_=caml_call2(Maths$0[6],_nT_,[0,k]),
            _s4_=caml_call2(Maths$0[8],_s3_,g),
            _s5_=caml_call2(Maths$0[8],_s4_,g),
            _s6_=caml_check_bound(c,0)[1],
            _s7_=caml_call2(Maths$0[8],[0,k],_s6_);
           return [0,caml_call2(Maths$0[4],_s7_,_s5_),_s2_];
          case 5:
           var
            b2=typ[3],
            b1=typ[2],
            _s8_=caml_call2(Maths$0[6],_nU_,[0,b1]),
            _s9_=caml_call2(Maths$0[8],_s8_,g),
            _s__=caml_check_bound(c,0)[1],
            _s$_=caml_call2(Maths$0[8],[0,b1],_s__),
            m=caml_call2(Maths$0[4],_s$_,_s9_),
            _ta_=caml_call2(Maths$0[6],_nV_,[0,b2]),
            _tb_=caml_call2(Maths$0[8],_ta_,g),
            _tc_=caml_call2(Maths$0[8],_tb_,g),
            _td_=caml_check_bound(c,1)[2],
            _te_=caml_call2(Maths$0[8],[0,b2],_td_),
            v=caml_call2(Maths$0[4],_te_,_tc_);
           return [0,m,v];
          default:return c}}
      function to_string$35(param)
       {switch(param[0])
         {case 0:var a=param[1];return caml_call1(sprintf(_nW_),a);
          case 1:var a$0=param[1];return caml_call1(sprintf(_nX_),a$0);
          case 2:
           var k=param[2],a$1=param[1];return caml_call2(sprintf(_nY_),a$1,k);
          case 3:
           var k$0=param[2],a$2=param[1];
           return caml_call2(sprintf(_nZ_),a$2,k$0);
          case 4:
           var k$1=param[2],a$3=param[1];
           return caml_call2(sprintf(_n0_),a$3,k$1);
          case 5:
           var b2=param[3],b1=param[2],a$4=param[1];
           return caml_call3(sprintf(_n1_),a$4,b1,b2);
          default:
           var a$5=param[1];return caml_call1(sprintf(_n2_),a$5.length - 1)}}
      var Learning_Rate=[0,run$35,default$0,update_ch,to_string$35];
      function run$36(typ,x,y,i)
       {if(typeof typ === "number")
         return 0 === typ?[0,x,y]:caml_call3(Utils[2],x,y,1);
        else
         {if(0 === typ[0]){var c=typ[1];return caml_call4(Utils[3],x,y,i,c)}
          var c$0=typ[1];
          return caml_call3(Utils[2],x,y,c$0)}}
      function batches(typ,x)
       {if(typeof typ === "number")
         return 0 === typ?1:caml_call1(Utils[1],x);
        else
         {if(0 === typ[0])
           {var c=typ[1];return caml_div(caml_call1(Utils[1],x),c)}
          var c$0=typ[1];
          return caml_div(caml_call1(Utils[1],x),c$0)}}
      function to_string$36(param)
       {if(typeof param === "number")
         return 0 === param
                 ?caml_call1(sprintf(_n4_),_n3_)
                 :caml_call1(sprintf(_n6_),_n5_);
        else
         {if(0 === param[0])
           {var c=param[1];return caml_call1(sprintf(_n7_),c)}
          var c$0=param[1];
          return caml_call1(sprintf(_n8_),c$0)}}
      var Batch=[0,run$36,batches,to_string$36];
      function run$37(typ,y$0,y)
       {if(typeof typ === "number")
         switch(typ)
          {case 0:
            var
             _sT_=caml_call2(Maths$0[8],y$0,y),
             _sU_=caml_call2(Maths$0[6],_n9_,_sT_),
             _sV_=caml_call2(Maths$0[16],_n__,_sU_);
            return caml_call1(Maths$0[46],_sV_);
           case 1:
            var _sW_=caml_call2(Maths$0[6],y$0,y);
            return caml_call1(Maths$0[52],_sW_);
           case 2:
            var _sX_=caml_call2(Maths$0[6],y$0,y);
            return caml_call1(Maths$0[53],_sX_);
           case 3:
            var _sY_=caml_call2(Maths$0[6],y$0,y);
            return caml_call1(Maths$0[54],_sY_);
           default:return caml_call2(Maths$0[61],y$0,y)}
        var f=typ[1];
        return caml_call2(f,y$0,y)}
      function to_string$37(param)
       {if(typeof param === "number")
         switch(param)
          {case 0:return _n$_;
           case 1:return _oa_;
           case 2:return _ob_;
           case 3:return _oc_;
           default:return _od_}
        return _oe_}
      var Loss=[0,run$37,to_string$37];
      function run$38(param)
       {switch(param)
         {case 0:
           return function(param,_sO_,_sN_,_sM_,g)
            {return caml_call1(Maths$0[17],g)};
          case 1:
           return function(param,_sE_,g$0,p,g)
            {var
              y=caml_call2(Maths$0[6],g,g$0),
              _sF_=caml_call2(Maths$0[8],p,y),
              _sG_=caml_call1(Maths$0[46],_sF_),
              _sH_=caml_call2(Maths$0[4],_sG_,_of_),
              _sI_=caml_call2(Maths$0[8],g,y),
              _sJ_=caml_call1(Maths$0[46],_sI_),
              b=caml_call2(Maths$0[10],_sJ_,_sH_),
              _sK_=caml_call2(Maths$0[8],b,p),
              _sL_=caml_call1(Maths$0[17],g);
             return caml_call2(Maths$0[4],_sL_,_sK_)};
          case 2:
           return function(param,_sx_,g$0,p,g)
            {var
              _sy_=caml_call1(Maths$0[17],p),
              _sz_=caml_call2(Maths$0[8],_sy_,g$0),
              _sA_=caml_call1(Maths$0[46],_sz_),
              _sB_=caml_call1(Maths$0[54],g),
              b=caml_call2(Maths$0[10],_sB_,_sA_),
              _sC_=caml_call2(Maths$0[8],b,p),
              _sD_=caml_call1(Maths$0[17],g);
             return caml_call2(Maths$0[4],_sD_,_sC_)};
          case 3:
           return function(param,_ss_,g$0,p,g)
            {var
              _st_=caml_call1(Maths$0[54],g$0),
              _su_=caml_call1(Maths$0[54],g),
              b=caml_call2(Maths$0[10],_su_,_st_),
              _sv_=caml_call2(Maths$0[8],b,p),
              _sw_=caml_call1(Maths$0[17],g);
             return caml_call2(Maths$0[4],_sw_,_sv_)};
          case 4:
           return function(param,_sm_,g$0,p,g)
            {var
              y=caml_call2(Maths$0[6],g,g$0),
              _sn_=caml_call2(Maths$0[8],p,y),
              _so_=caml_call1(Maths$0[46],_sn_),
              _sp_=caml_call1(Maths$0[54],g),
              b=caml_call2(Maths$0[10],_sp_,_so_),
              _sq_=caml_call2(Maths$0[8],b,p),
              _sr_=caml_call1(Maths$0[17],g);
             return caml_call2(Maths$0[4],_sr_,_sq_)};
          case 5:
           return function(f,w,param,p,g)
            {var
              _sh_=caml_call3(hessianv$2,f,w,p),
              hv=caml_call1(Maths$0[51],_sh_),
              _si_=caml_call2(Maths$0[49],hv,p),
              _sj_=caml_call2(Maths$0[49],hv,g),
              b=caml_call2(Maths$0[10],_sj_,_si_),
              _sk_=caml_call2(Maths$0[49],p,b),
              _sl_=caml_call1(Maths$0[17],g);
             return caml_call2(Maths$0[4],_sl_,_sk_)};
          default:
           return function(f,w,param,_sQ_,_sP_)
            {var
              match=caml_call2(gradhessian$1,f,w),
              h=match[2],
              g=match[1],
              _sR_=caml_call1(Maths$0[57],h),
              _sS_=caml_call2(Maths$0[49],g,_sR_);
             return caml_call1(Maths$0[17],_sS_)}}}
      function to_string$38(param)
       {switch(param)
         {case 0:return _og_;
          case 1:return _oh_;
          case 2:return _oi_;
          case 3:return _oj_;
          case 4:return _ok_;
          case 5:return _ol_;
          default:return _om_}}
      var Gradient=[0,run$38,to_string$38];
      function run$39(param)
       {if(typeof param === "number")
         return function(param,u){return u};
        else
         {if(0 === param[0])
           {var m=param[1];
            return function(u$0,u)
             {var _sg_=caml_call2(Maths$0[8],[0,m],u$0);
              return caml_call2(Maths$0[4],_sg_,u)}}
          var m$0=param[1];
          return function(u$0,u)
           {var
             _sc_=caml_call2(Maths$0[4],[0,m$0],_on_),
             _sd_=caml_call2(Maths$0[8],_sc_,u),
             _se_=caml_call2(Maths$0[8],[0,m$0],[0,m$0]),
             _sf_=caml_call2(Maths$0[8],_se_,u$0);
            return caml_call2(Maths$0[4],_sf_,_sd_)}}}
      function default$1(param)
       {return typeof param === "number"?0:0 === param[0]?_oo_:_op_}
      function to_string$39(param)
       {if(typeof param === "number")
         return sprintf(_oq_);
        else
         {if(0 === param[0])
           {var m=param[1];return caml_call1(sprintf(_or_),m)}
          var m$0=param[1];
          return caml_call1(sprintf(_os_),m$0)}}
      var Momentum=[0,run$39,default$1,to_string$39];
      function run$40(typ,x)
       {if(typeof typ === "number")
         return _ot_;
        else
         switch(typ[0])
          {case 0:
            var a=typ[1],_r8_=caml_call1(Maths$0[52],x);
            return caml_call2(Maths$0[8],[0,a],_r8_);
           case 1:
            var a$0=typ[1],_r9_=caml_call1(Maths$0[53],x);
            return caml_call2(Maths$0[8],[0,a$0],_r9_);
           default:
            var
             b=typ[2],
             a$1=typ[1],
             _r__=caml_call1(Maths$0[53],x),
             _r$_=caml_call2(Maths$0[8],[0,b],_r__),
             _sa_=caml_call1(Maths$0[52],x),
             _sb_=caml_call2(Maths$0[8],[0,a$1],_sa_);
            return caml_call2(Maths$0[4],_sb_,_r$_)}}
      function to_string$40(param)
       {if(typeof param === "number")
         return _ou_;
        else
         switch(param[0])
          {case 0:var a=param[1];return caml_call1(sprintf(_ov_),a);
           case 1:var a$0=param[1];return caml_call1(sprintf(_ow_),a$0);
           default:
            var b=param[2],a$1=param[1];return caml_call2(sprintf(_ox_),a$1,b)}}
      var Regularisation=[0,run$40,to_string$40];
      function run$41(typ,x)
       {if(typeof typ === "number")
         return x;
        else
         {if(0 === typ[0])
           {var t=typ[1];return caml_call2(clip_by_l2norm$0,t,x)}
          var b=typ[2],a=typ[1];
          return caml_call3(clip_by_value$0,a,b,x)}}
      function default$2(param)
       {return typeof param === "number"?0:0 === param[0]?_oy_:_oz_}
      function to_string$41(param)
       {if(typeof param === "number")
         return _oA_;
        else
         {if(0 === param[0])
           {var t=param[1];return caml_call1(sprintf(_oB_),t)}
          var b=param[2],a=param[1];
          return caml_call2(sprintf(_oC_),a,b)}}
      var Clipping=[0,run$41,default$2,to_string$41];
      function run$42(typ,x)
       {if(typeof typ === "number")
         return 0;
        else
         {if(0 === typ[0]){var a=typ[1];return x < a?1:0}
          return failwith(_oD_)}}
      function default$3(param)
       {return typeof param === "number"?0:0 === param[0]?_oE_:_oF_}
      function to_string$42(param)
       {if(typeof param === "number")
         return _oG_;
        else
         {if(0 === param[0])
           {var a=param[1];return caml_call1(sprintf(_oH_),a)}
          var o=param[2],s=param[1];
          return caml_call2(sprintf(_oI_),s,o)}}
      var Stopping=[0,run$42,default$3,to_string$42];
      function init_state(batches_per_epoch,epochs)
       {var batches=batches_per_epoch * epochs | 0;
        return [0,
                1,
                batches_per_epoch,
                epochs,
                batches,
                caml_make_vect(batches + 1 | 0,_oO_),
                unix_gettimeofday(0),
                0,
                [0,[0,_oN_]],
                [0,[0,_oM_]],
                [0,[0,_oL_]],
                [0,[0,[0,_oK_,_oJ_]]]]}
      function default_checkpoint_fun(save_fun)
       {var
         _r6_=unix_time(0) | 0,
         _r7_=caml_sys_getcwd(0),
         file_name=caml_call3(sprintf(_oQ_),_r7_,_oP_,_r6_);
        caml_call1(info(_oR_),file_name);
        return caml_call1(save_fun,file_name)}
      function print_state_info(state)
       {var
         b_i=state[1],
         b_n=state[4],
         e_n=state[3],
         e_i=b_i / (b_n / e_n),
         _r4_=b_i - 1 | 0,
         l0=caml_call1(unpack_flt$0,caml_check_bound(state[5],_r4_)[_r4_ + 1]),
         l1=caml_call1(unpack_flt$0,caml_check_bound(state[5],b_i)[b_i + 1]),
         d=l0 - l1,
         s=d == 0?_oS_:d < 0?_oU_:_oV_,
         _r5_=state[6],
         t=format_time(unix_gettimeofday(0) - _r5_);
        return caml_call7(info(_oT_),t,e_i,e_n,b_i,b_n,l1,s)}
      function print_summary(state)
       {var _r2_=state[6],_r3_=format_time(unix_gettimeofday(0) - _r2_);
        return flush_all(caml_call1(printf(_oW_),_r3_))}
      function run$43(typ,save_fun,current_batch,current_loss,state)
       {caml_check_bound(state[5],current_batch)[current_batch + 1]
        =
        current_loss;
        state[7] = state[4] <= state[1]?1:0;
        if(typeof typ === "number")
         var interval=max_int;
        else
         switch(typ[0])
          {case 0:var i=typ[1],interval=i;break;
           case 1:var i$0=typ[1],interval=i$0 * state[2] | 0;break;
           default:var interval=1}
        var
         _r0_=0 === caml_mod(state[1],interval)?1:0,
         _r1_=_r0_?state[1] < state[4]?1:0:_r0_;
        if(_r1_)
         {if(typeof typ !== "number" && 2 === typ[0])
           {var f=typ[1];return caml_call1(f,state)}
          return default_checkpoint_fun(save_fun)}
        return _r1_}
      function to_string$43(param)
       {if(typeof param === "number")
         return sprintf(_oX_);
        else
         switch(param[0])
          {case 0:var i=param[1];return caml_call1(sprintf(_oY_),i);
           case 1:var i$0=param[1];return caml_call1(sprintf(_oZ_),i$0);
           default:return sprintf(_o0_)}}
      var
       Checkpoint=
        [0,
         init_state,
         default_checkpoint_fun,
         print_state_info,
         print_summary,
         run$43,
         to_string$43];
      function default$4(param)
       {return [0,1,_o2_,0,4,caml_call1(Learning_Rate[2],_o1_),0,0,0,0,0,1]}
      function config
       (batch,
        gradient,
        loss,
        learning_rate,
        regularisation,
        momentum,
        clipping,
        stopping,
        checkpoint,
        verbosity,
        epochs)
       {var p=default$4(0);
        if(batch){var x=batch[1];p[2] = x}
        if(gradient){var x$0=gradient[1];p[3] = x$0}
        if(loss){var x$1=loss[1];p[4] = x$1}
        if(learning_rate){var x$2=learning_rate[1];p[5] = x$2}
        if(regularisation){var x$3=regularisation[1];p[6] = x$3}
        if(momentum){var x$4=momentum[1];p[7] = x$4}
        if(clipping){var x$5=clipping[1];p[8] = x$5}
        if(stopping){var x$6=stopping[1];p[9] = x$6}
        if(checkpoint){var x$7=checkpoint[1];p[10] = x$7}
        if(verbosity){var x$8=verbosity[1];p[11] = x$8}
        p[1] = epochs;
        return p}
      function to_string$44(p)
       {var
         _rE_=p[11]?_o4_:_pf_,
         _rF_=_d_(caml_call1(sprintf(_o5_),_rE_),_o3_),
         _rG_=caml_call1(Checkpoint[6],p[10]),
         _rH_=_d_(caml_call1(sprintf(_o6_),_rG_),_rF_),
         _rI_=caml_call1(Stopping[3],p[9]),
         _rJ_=_d_(caml_call1(sprintf(_o7_),_rI_),_rH_),
         _rK_=caml_call1(Clipping[3],p[8]),
         _rL_=_d_(caml_call1(sprintf(_o8_),_rK_),_rJ_),
         _rM_=caml_call1(Momentum[3],p[7]),
         _rN_=_d_(caml_call1(sprintf(_o9_),_rM_),_rL_),
         _rO_=caml_call1(Regularisation[2],p[6]),
         _rP_=_d_(caml_call1(sprintf(_o__),_rO_),_rN_),
         _rQ_=caml_call1(Learning_Rate[4],p[5]),
         _rR_=_d_(caml_call1(sprintf(_o$_),_rQ_),_rP_),
         _rS_=caml_call1(Loss[2],p[4]),
         _rT_=_d_(caml_call1(sprintf(_pa_),_rS_),_rR_),
         _rU_=caml_call1(Gradient[2],p[3]),
         _rV_=_d_(caml_call1(sprintf(_pb_),_rU_),_rT_),
         _rW_=caml_call1(Batch[3],p[2]),
         _rX_=_d_(caml_call1(sprintf(_pc_),_rW_),_rV_),
         _rY_=p[1],
         _rZ_=_d_(caml_call1(sprintf(_pd_),_rY_),_rX_);
        return _d_(sprintf(_pe_),_rZ_)}
      var Params=[0,default$4,config,to_string$44];
      function minimise_weight(state,params,f,w,x,y)
       {var _rs_=1 === params[11]?1:0,_rt_=_rs_?0 === state?1:0:_rs_;
        if(_rt_)print_endline(caml_call1(Params[3],params));
        var
         bach_fun=caml_call1(Batch[1],params[2]),
         loss_fun=caml_call1(Loss[1],params[4]),
         grad_fun=caml_call1(Gradient[1],params[3]),
         rate_fun=caml_call1(Learning_Rate[1],params[5]),
         regl_fun=caml_call1(Regularisation[1],params[6]),
         momt_fun=caml_call1(Momentum[1],params[7]),
         upch_fun=caml_call1(Learning_Rate[3],params[5]),
         clip_fun=caml_call1(Clipping[1],params[8]),
         stop_fun=caml_call1(Stopping[1],params[9]),
         chkp_fun=caml_call1(Checkpoint[5],params[10]);
        function iterate(i,w)
         {var match=caml_call3(bach_fun,x,y,i),yi=match[2],xi=match[1];
          function optz(wi)
           {var
             _rC_=caml_call1(regl_fun,wi),
             _rD_=caml_call2(loss_fun,yi,caml_call2(f,wi,xi));
            return caml_call2(Maths$0[4],_rD_,_rC_)}
          var match$0=caml_call2(grad$1,optz,w),g=match$0[2],loss=match$0[1];
          return [0,caml_call1(primal$2,loss),g,optz]}
        if(state)
         var state$0=state[1],state$1=state$0;
        else
         {var
           batches_per_epoch=caml_call2(Batch[2],params[2],x),
           state$2=caml_call2(Checkpoint[1],batches_per_epoch,params[1]),
           match$0=iterate(0,w),
           g0=match$0[2],
           loss$0=match$0[1];
          state$2[8] = [0,[0,g0]];
          state$2[9] = [0,[0,caml_call1(Maths$0[17],g0)]];
          state$2[10] = [0,[0,_pg_]];
          state$2[11] = [0,[0,[0,_pi_,_ph_]]];
          caml_check_bound(state$2[5],0)[1] = loss$0;
          var state$1=state$2}
        var w$0=[0,w];
        for(;;)
         {if(0 === state$1[7])
           {var
             match=iterate(state$1[1],w$0[1]),
             optz=match[3],
             g=match[2],
             loss=match[1];
            state$1[7] = caml_call1(stop_fun,caml_call1(unpack_flt$0,loss));
            var _ru_=state$1[1];
            caml_call4(chkp_fun,function(param){return 0},_ru_,loss,state$1);
            if(1 === params[11])caml_call1(Checkpoint[3],state$1);
            var
             g$0=caml_call1(clip_fun,g),
             _rv_=caml_check_bound(caml_check_bound(state$1[9],0)[1],0)[1],
             _rw_=caml_check_bound(caml_check_bound(state$1[8],0)[1],0)[1],
             p=caml_call5(grad_fun,optz,w$0[1],_rw_,_rv_,g$0),
             _rx_=
              caml_call2
               (upch_fun,
                g$0,
                caml_check_bound(caml_check_bound(state$1[11],0)[1],0)[1]);
            caml_check_bound(caml_check_bound(state$1[11],0)[1],0)[1] = _rx_;
            var
             _ry_=caml_check_bound(caml_check_bound(state$1[11],0)[1],0)[1],
             _rz_=caml_call3(rate_fun,state$1[1],g$0,_ry_),
             u=caml_call2(Maths$0[8],p,_rz_),
             u$0=
              caml_call2
               (momt_fun,
                caml_check_bound(caml_check_bound(state$1[10],0)[1],0)[1],
                u);
            w$0[1] = caml_call1(primal$2,caml_call2(Maths$0[4],w$0[1],u$0));
            if(0 !== params[7])
             caml_check_bound(caml_check_bound(state$1[10],0)[1],0)[1] = u$0;
            caml_check_bound(caml_check_bound(state$1[8],0)[1],0)[1] = g$0;
            caml_check_bound(caml_check_bound(state$1[9],0)[1],0)[1] = p;
            state$1[1] = state$1[1] + 1 | 0;
            continue}
          var
           _rA_=1 === params[11]?1:0,
           _rB_=_rA_?state$1[4] <= state$1[1]?1:0:_rA_;
          if(_rB_)caml_call1(Checkpoint[4],state$1);
          return [0,state$1,w$0[1]]}}
      function minimise_network(state,params,forward,backward,update,save,x,y)
       {var _q9_=1 === params[11]?1:0,_q__=_q9_?0 === state?1:0:_q9_;
        if(_q__)print_endline(caml_call1(Params[3],params));
        var
         bach_fun=caml_call1(Batch[1],params[2]),
         loss_fun=caml_call1(Loss[1],params[4]),
         grad_fun=caml_call1(Gradient[1],params[3]),
         rate_fun=caml_call1(Learning_Rate[1],params[5]),
         regl_fun=caml_call1(Regularisation[1],params[6]),
         momt_fun=caml_call1(Momentum[1],params[7]),
         upch_fun=caml_call1(Learning_Rate[3],params[5]),
         clip_fun=caml_call1(Clipping[1],params[8]),
         stop_fun=caml_call1(Stopping[1],params[9]),
         chkp_fun=caml_call1(Checkpoint[5],params[10]);
        function iterate(i)
         {var
           match=caml_call3(bach_fun,x,y,i),
           yt=match[2],
           xt=match[1],
           match$0=caml_call1(forward,xt),
           ws=match$0[2],
           yt$0=match$0[1],
           loss=caml_call2(loss_fun,yt,yt$0),
           _ro_=[0,caml_call1(Mat$0[9],yt)],
           loss$0=caml_call2(Maths$0[10],loss,_ro_),
           match$1=0 !== params[6]?1:0;
          if(0 === match$1)
           var reg=_pj_;
          else
           {var
             a$0=[0,a],
             _rn_=
              function(w)
               {var _rq_=a$0[1],_rr_=caml_call1(regl_fun,w);
                a$0[1] = caml_call2(Maths$0[4],_rq_,_rr_);
                return 0};
            iter(function(_rp_){return iter(_rn_,_rp_)},ws);
            var reg=a$0[1]}
          var
           loss$1=caml_call2(Maths$0[4],loss$0,reg),
           match$2=caml_call1(backward,loss$1),
           gs=match$2[2],
           ws$0=match$2[1];
          return [0,caml_call1(primal$2,loss$1),ws$0,gs]}
        if(state)
         var state$0=state[1],state$1=state$0;
        else
         {var
           batches_per_epoch=caml_call2(Batch[2],params[2],x),
           state$2=caml_call2(Checkpoint[1],batches_per_epoch,params[1]),
           match$0=iterate(0),
           gs$0=match$0[3],
           ws$1=match$0[2],
           loss$0=match$0[1];
          caml_call1(update,ws$1);
          state$2[8] = gs$0;
          state$2[9] = aarr_map(Maths$0[17],gs$0);
          state$2[10] = aarr_map(function(param){return _pk_},gs$0);
          state$2[11] = aarr_map(function(param){return [0,_pm_,_pl_]},gs$0);
          caml_check_bound(state$2[5],0)[1] = loss$0;
          var state$1=state$2}
        for(;;)
         {if(0 === state$1[7])
           {var
             match=iterate(state$1[1]),
             gs=match[3],
             ws=match[2],
             loss=match[1];
            state$1[7] = caml_call1(stop_fun,caml_call1(unpack_flt$0,loss));
            caml_call4(chkp_fun,save,state$1[1],loss,state$1);
            if(1 === params[11])caml_call1(Checkpoint[3],state$1);
            var
             x3=aarr_map(clip_fun,gs),
             _q$_=state$1[9],
             _ra_=state$1[8],
             f=caml_call1(grad_fun,function(a){return a}),
             ps=
              init
               (ws.length - 1,
                function(ws,x3,_rh_,_ri_,f)
                  {return function(i)
                    {function _rj_(j)
                      {var
                        _rk_=
                         caml_check_bound(caml_check_bound(x3,i)[i + 1],j)[j + 1],
                        _rl_=
                         caml_check_bound(caml_check_bound(_rh_,i)[i + 1],j)[j + 1],
                        _rm_=
                         caml_check_bound(caml_check_bound(_ri_,i)[i + 1],j)[j + 1];
                       return caml_call4
                               (f,
                                caml_check_bound(caml_check_bound(ws,i)[i + 1],j)[j + 1],
                                _rm_,
                                _rl_,
                                _rk_)}
                     return init(caml_check_bound(ws,i)[i + 1].length - 1,_rj_)}}
                 (ws,x3,_q$_,_ra_,f));
            state$1[11] = aarr_map2(upch_fun,x3,state$1[11]);
            var
             _rb_=state$1[11],
             us=
              init
               (ps.length - 1,
                function(ps,x3,_re_)
                  {return function(i)
                    {function _rf_(j)
                      {var
                        c=caml_check_bound(caml_check_bound(_re_,i)[i + 1],j)[j + 1],
                        g=caml_check_bound(caml_check_bound(x3,i)[i + 1],j)[j + 1],
                        p=caml_check_bound(caml_check_bound(ps,i)[i + 1],j)[j + 1],
                        _rg_=caml_call3(rate_fun,state$1[1],g,c);
                       return caml_call2(Maths$0[8],p,_rg_)}
                     return init(caml_check_bound(ps,i)[i + 1].length - 1,_rf_)}}
                 (ps,x3,_rb_)),
             us$0=aarr_map2(momt_fun,state$1[10],us),
             ws$0=
              aarr_map2
               (function(w,u){return caml_call2(Maths$0[4],w,u)},ws,us$0);
            caml_call1(update,ws$0);
            if(0 !== params[7])state$1[10] = us$0;
            state$1[8] = x3;
            state$1[9] = ps;
            state$1[1] = state$1[1] + 1 | 0;
            continue}
          var
           _rc_=1 === params[11]?1:0,
           _rd_=_rc_?state$1[4] <= state$1[1]?1:0:_rc_;
          if(_rd_)caml_call1(Checkpoint[4],state$1);
          return state$1}}
      function minimise_fun(state,params,f,x)
       {var _qX_=1 === params[11]?1:0,_qY_=_qX_?0 === state?1:0:_qX_;
        if(_qY_)print_endline(caml_call1(Params[3],params));
        var
         grad_fun=caml_call1(Gradient[1],params[3]),
         rate_fun=caml_call1(Learning_Rate[1],params[5]),
         regl_fun=caml_call1(Regularisation[1],params[6]),
         momt_fun=caml_call1(Momentum[1],params[7]),
         upch_fun=caml_call1(Learning_Rate[3],params[5]),
         clip_fun=caml_call1(Clipping[1],params[8]),
         stop_fun=caml_call1(Stopping[1],params[9]),
         chkp_fun=caml_call1(Checkpoint[5],params[10]);
        function optz_fun(xi)
         {var _q7_=caml_call1(regl_fun,xi),_q8_=caml_call1(f,xi);
          return caml_call2(Maths$0[4],_q8_,_q7_)}
        function iterate(param,xi)
         {var match=caml_call2(grad$1,optz_fun,xi),g=match[2],loss=match[1];
          return [0,caml_call1(primal$2,loss),g,optz_fun]}
        if(state)
         var state$0=state[1],state$1=state$0;
        else
         {var
           state$2=caml_call2(Checkpoint[1],1,params[1]),
           match$0=iterate(0,x),
           g0=match$0[2],
           loss$0=match$0[1];
          state$2[8] = [0,[0,g0]];
          state$2[9] = [0,[0,caml_call1(Maths$0[17],g0)]];
          state$2[10] = [0,[0,_pn_]];
          state$2[11] = [0,[0,[0,_pp_,_po_]]];
          caml_check_bound(state$2[5],0)[1] = loss$0;
          var state$1=state$2}
        var x$0=[0,x];
        for(;;)
         {if(0 === state$1[7])
           {var
             match=iterate(state$1[1],x$0[1]),
             optz=match[3],
             g=match[2],
             loss=match[1];
            state$1[7] = caml_call1(stop_fun,caml_call1(unpack_flt$0,loss));
            var _qZ_=state$1[1];
            caml_call4(chkp_fun,function(param){return 0},_qZ_,loss,state$1);
            if(1 === params[11])caml_call1(Checkpoint[3],state$1);
            var
             g$0=caml_call1(clip_fun,g),
             _q0_=caml_check_bound(caml_check_bound(state$1[9],0)[1],0)[1],
             _q1_=caml_check_bound(caml_check_bound(state$1[8],0)[1],0)[1],
             p=caml_call5(grad_fun,optz,x$0[1],_q1_,_q0_,g$0),
             _q2_=
              caml_call2
               (upch_fun,
                g$0,
                caml_check_bound(caml_check_bound(state$1[11],0)[1],0)[1]);
            caml_check_bound(caml_check_bound(state$1[11],0)[1],0)[1] = _q2_;
            var
             _q3_=caml_check_bound(caml_check_bound(state$1[11],0)[1],0)[1],
             _q4_=caml_call3(rate_fun,state$1[1],g$0,_q3_),
             u=caml_call2(Maths$0[8],p,_q4_),
             u$0=
              caml_call2
               (momt_fun,
                caml_check_bound(caml_check_bound(state$1[10],0)[1],0)[1],
                u);
            x$0[1] = caml_call1(primal$2,caml_call2(Maths$0[4],x$0[1],u$0));
            if(0 !== params[7])
             caml_check_bound(caml_check_bound(state$1[10],0)[1],0)[1] = u$0;
            caml_check_bound(caml_check_bound(state$1[8],0)[1],0)[1] = g$0;
            caml_check_bound(caml_check_bound(state$1[9],0)[1],0)[1] = p;
            state$1[1] = state$1[1] + 1 | 0;
            continue}
          var
           _q5_=1 === params[11]?1:0,
           _q6_=_q5_?state$1[4] <= state$1[1]?1:0:_q5_;
          if(_q6_)caml_call1(Checkpoint[4],state$1);
          return [0,state$1,x$0[1]]}}
      var
       Optimise=
        [0,
         global_tag$0,
         tag$0,
         cmp_tag$0,
         reset_zero$0,
         primal$1,
         primal$2,
         zero$0,
         tangent$0,
         adjref$0,
         adjval$0,
         shape$0,
         row_num$0,
         col_num$0,
         numel$0,
         clip_by_value$0,
         clip_by_l2norm$0,
         copy_primal$0,
         tile$0,
         repeat$0,
         pack_arr$0,
         unpack_arr$0,
         pack_flt$0,
         unpack_flt$0,
         deep_info$0,
         type_info$0,
         error_binop$0,
         error_uniop$0,
         Maths$0,
         reverse_reset$0,
         reverse_push$0,
         reverse_prop$0,
         make_forward$0,
         make_reverse$0,
         diff$1,
         diff$2,
         grad$1,
         grad$2,
         jacobianv$1,
         jacobianv$2,
         jacobianTv$1,
         jacobianTv$2,
         jacobian$1,
         jacobian$2,
         gradhessian$1,
         gradhessian$2,
         hessian$1,
         hessian$2,
         gradhessianv$1,
         gradhessianv$2,
         hessianv$1,
         hessianv$2,
         laplacian$1,
         laplacian$2,
         Mat$0,
         Arr$0,
         traverse_trace$0,
         convert_terminal_output$0,
         convert_dot_output$0,
         to_trace$0,
         to_dot$0,
         pp_num$0,
         Utils,
         Learning_Rate,
         Batch,
         Loss,
         Gradient,
         Momentum,
         Regularisation,
         Clipping,
         Stopping,
         Checkpoint,
         Params,
         minimise_weight,
         minimise_network,
         minimise_fun];
      function make_network(nnid,size,root,topo)
       {if(nnid)var s=nnid[1],nnid$0=s;else var nnid$0=_pq_;
        return [0,nnid$0,size,root,topo]}
      function make_node(name,opt,prev,next,neuron,output,network)
       {if(opt)var sth=opt[1],train=sth;else var train=0;
        if(name)
         var s=name[1],name$0=s;
        else
         var
          _qV_=network[2],
          _qW_=caml_call1(Neuron[118],neuron),
          name$0=caml_call2(sprintf(_pr_),_qW_,_qV_);
        return [0,name$0,prev,next,neuron,output,network,train]}
      function get_root(nn)
       {var _qU_=nn[3];if(_qU_){var n=_qU_[1];return n}return failwith(_ps_)}
      function get_node(nn,name)
       {var
         _qT_=nn[4],
         x=filter(function(n){return caml_string_equal(n[1],name)},_qT_);
        return 0 === x.length - 1?failwith(_pt_):caml_check_bound(x,0)[1]}
      function get_network(n){return n[6]}
      function collect_output(nodes)
       {return map$0
                (function(n)
                  {var _qS_=n[5];
                   if(_qS_){var o=_qS_[1];return o}
                   return failwith(_pu_)},
                 nodes)}
      function connect_pair(prev,next)
       {if(0 === mem(prev,next[2]))next[2] = append$0(next[2],[0,prev]);
        var
         _qQ_=0 === mem(next,prev[3])?1:0,
         _qR_=_qQ_?(prev[3] = append$0(prev[3],[0,next]),0):_qQ_;
        return _qR_}
      function connect_to_parents(parents,child)
       {if(0 < parents.length - 1)
         {var
           out_shapes=
            map$0(function(n){return caml_call1(Neuron[106],n[4])},parents);
          caml_call2(Neuron[107],out_shapes,child[4])}
        return iter(function(p){return connect_pair(p,child)},parents)}
      function add_node(act_typ,nn,parents,child)
       {var act_typ$0=act_typ,parents$0=parents,child$0=child;
        for(;;)
         {nn[2] = nn[2] + 1 | 0;
          connect_to_parents(parents$0,child$0);
          nn[4] = append$0(nn[4],[0,child$0]);
          child$0[6] = nn;
          if(act_typ$0)
           {var
             act=act_typ$0[1],
             neuron=[23,caml_call1(Neuron[64][1],act)],
             child$1=make_node(0,0,[0],[0],neuron,0,nn),
             parents$1=[0,child$0],
             act_typ$0=0,
             parents$0=parents$1,
             child$0=child$1;
            continue}
          return child$0}}
      function init$12(nn)
       {var _qP_=nn[4];
        return iter(function(n){return caml_call1(Neuron[108],n[4])},_qP_)}
      function reset$11(nn)
       {var _qO_=nn[4];
        return iter(function(n){return caml_call1(Neuron[109],n[4])},_qO_)}
      function mktag$11(t,nn)
       {var _qN_=nn[4];
        return iter(function(n){return caml_call2(Neuron[110],t,n[4])},_qN_)}
      function mkpar$11(nn)
       {var _qM_=nn[4];
        return map$0(function(n){return caml_call1(Neuron[111],n[4])},_qM_)}
      function mkpri$11(nn)
       {var _qL_=nn[4];
        return map$0(function(n){return caml_call1(Neuron[112],n[4])},_qL_)}
      function mkadj$11(nn)
       {var _qK_=nn[4];
        return map$0(function(n){return caml_call1(Neuron[113],n[4])},_qK_)}
      function update$11(nn,us)
       {var _qJ_=nn[4];
        return iter2
                (function(n,u){return caml_call2(Neuron[114],n[4],u)},_qJ_,us)}
      function run$44(x,nn)
       {var _qH_=nn[4];
        iter
         (function(n)
           {var
             input=0 === n[4][0]?[0,x]:collect_output(n[2]),
             output=caml_call2(Neuron[116],input,n[4]);
            n[5] = [0,output];
            return 0},
          _qH_);
        var
         _qI_=nn[4].length - 1 - 1 | 0,
         sink=[0,caml_check_bound(nn[4],_qI_)[_qI_ + 1]];
        return caml_check_bound(collect_output(sink),0)[1]}
      function forward(nn,x)
       {mktag$11(caml_call1(Neuron[2],0),nn);
        var _qG_=mkpar$11(nn);
        return [0,run$44(x,nn),_qG_]}
      function backward(nn,y)
       {caml_call2(Neuron[31],_pv_,y);
        var _qF_=mkadj$11(nn);
        return [0,mkpri$11(nn),_qF_]}
      function copy$35(nn)
       {var nn$0=make_network([0,nn[1]],nn[2],0,[0]),_qA_=nn[4];
        nn$0[4]
        =
        map$0
         (function(node)
           {var neuron=caml_call1(Neuron[115],node[4]);
            return make_node([0,node[1]],[0,node[7]],[0],[0],neuron,0,nn$0)},
          _qA_);
        var _qB_=nn$0[4],_qC_=nn[4];
        iter2
         (function(node$0,node)
           {var _qD_=node$0[2];
            node[2] = map$0(function(n){return get_node(nn$0,n[1])},_qD_);
            var _qE_=node$0[3];
            node[3] = map$0(function(n){return get_node(nn$0,n[1])},_qE_);
            return connect_to_parents(node[2],node)},
          _qC_,
          _qB_);
        nn$0[3] = [0,get_node(nn$0,get_root(nn)[1])];
        return nn$0}
      function remove_training_nodes(nn)
       {var
         _qs_=nn[4],
         topo=
          filter
           (function(n)
             {if(1 === n[7])
               {var _qt_=n[2];
                iter
                 (function(m)
                   {var
                     _qz_=m[3],
                     next=
                      filter
                       (function(x){return caml_string_notequal(x[1],n[1])},_qz_);
                    m[3] = next;
                    return 0},
                  _qt_);
                var _qu_=n[3];
                iter
                 (function(m)
                   {var
                     _qy_=m[2],
                     prev=
                      filter
                       (function(x){return caml_string_notequal(x[1],n[1])},_qy_);
                    m[2] = prev;
                    return 0},
                  _qu_);
                var _qv_=n[3],_qw_=n[2];
                iter
                 (function(_qx_){return connect_to_parents(_qw_,_qx_)},_qv_)}
              return 1 - n[7]},
            _qs_);
        nn[4] = topo;
        return 0}
      function model(nn)
       {var nn$0=copy$35(nn);
        remove_training_nodes(nn$0);
        function inference(x)
         {var match=run$44([1,x],nn$0);
          if(1 === match[0]){var y=match[1];return y}
          return failwith(_pw_)}
        return inference}
      function input(name,inputs)
       {var
         neuron=[0,caml_call1(Neuron[63][1],inputs)],
         nn=make_network(0,0,0,[0]),
         n=make_node(name,0,[0],[0],neuron,0,nn);
        nn[3] = [0,n];
        return add_node(0,nn,[0],n)}
      function activation(name,act_typ,input_node)
       {var
         neuron=[23,caml_call1(Neuron[64][1],act_typ)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(0,nn,[0,input_node],n)}
      function linear(name,opt,act_typ,outputs,input_node)
       {if(opt)var sth=opt[1],init_typ=sth;else var init_typ=0;
        var
         neuron=[1,caml_call3(Neuron[65][1],0,outputs,init_typ)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function linear_nobias(name,opt,act_typ,outputs,input_node)
       {if(opt)var sth=opt[1],init_typ=sth;else var init_typ=0;
        var
         neuron=[2,caml_call3(Neuron[66][1],0,outputs,init_typ)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function embedding(name,opt,act_typ,in_dim,out_dim,input_node)
       {if(opt)var sth=opt[1],init_typ=sth;else var init_typ=0;
        var
         neuron=[3,caml_call4(Neuron[102][1],0,in_dim,out_dim,init_typ)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function recurrent(name,opt,act_typ,outputs,hiddens,input_node)
       {if(opt)var sth=opt[1],init_typ=sth;else var init_typ=0;
        var
         neuron=
          [6,caml_call6(Neuron[67][1],0,0,hiddens,outputs,act_typ,init_typ)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(0,nn,[0,input_node],n)}
      function lstm(name,opt,cells,input_node)
       {if(opt)var sth=opt[1],init_typ=sth;else var init_typ=1;
        var
         neuron=[4,caml_call4(Neuron[68][1],0,0,cells,init_typ)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(0,nn,[0,input_node],n)}
      function gru(name,opt,cells,input_node)
       {if(opt)var sth=opt[1],init_typ=sth;else var init_typ=1;
        var
         neuron=[5,caml_call4(Neuron[69][1],0,0,cells,init_typ)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(0,nn,[0,input_node],n)}
      function conv1d(name,opt,_qr_,act_typ,kernel,strides,input_node)
       {if(opt)var sth=opt[1],padding=sth;else var padding=0;
        if(_qr_)var sth$0=_qr_[1],init_typ=sth$0;else var init_typ=1;
        var
         neuron=
          [7,caml_call5(Neuron[70][1],0,padding,kernel,strides,init_typ)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function conv2d(name,opt,_qq_,act_typ,kernel,strides,input_node)
       {if(opt)var sth=opt[1],padding=sth;else var padding=0;
        if(_qq_)var sth$0=_qq_[1],init_typ=sth$0;else var init_typ=1;
        var
         neuron=
          [8,caml_call5(Neuron[71][1],0,padding,kernel,strides,init_typ)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function conv3d(name,opt,_qp_,act_typ,kernel,strides,input_node)
       {if(opt)var sth=opt[1],padding=sth;else var padding=0;
        if(_qp_)var sth$0=_qp_[1],init_typ=sth$0;else var init_typ=1;
        var
         neuron=
          [9,caml_call5(Neuron[72][1],0,padding,kernel,strides,init_typ)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function fully_connected(name,opt,act_typ,outputs,input_node)
       {if(opt)var sth=opt[1],init_typ=sth;else var init_typ=0;
        var
         neuron=[10,caml_call3(Neuron[73][1],0,outputs,init_typ)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function max_pool1d(name,opt,act_typ,kernel,stride,input_node)
       {if(opt)var sth=opt[1],padding=sth;else var padding=0;
        var
         neuron=[11,caml_call3(Neuron[74][1],padding,kernel,stride)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function max_pool2d(name,opt,act_typ,kernel,stride,input_node)
       {if(opt)var sth=opt[1],padding=sth;else var padding=0;
        var
         neuron=[12,caml_call3(Neuron[75][1],padding,kernel,stride)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function avg_pool1d(name,opt,act_typ,kernel,stride,input_node)
       {if(opt)var sth=opt[1],padding=sth;else var padding=0;
        var
         neuron=[13,caml_call3(Neuron[76][1],padding,kernel,stride)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function avg_pool2d(name,opt,act_typ,kernel,stride,input_node)
       {if(opt)var sth=opt[1],padding=sth;else var padding=0;
        var
         neuron=[14,caml_call3(Neuron[77][1],padding,kernel,stride)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function global_max_pool1d(name,act_typ,input_node)
       {var
         neuron=[15,caml_call1(Neuron[78][1],0)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function global_max_pool2d(name,act_typ,input_node)
       {var
         neuron=[16,caml_call1(Neuron[79][1],0)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function global_avg_pool1d(name,act_typ,input_node)
       {var
         neuron=[17,caml_call1(Neuron[80][1],0)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function global_avg_pool2d(name,act_typ,input_node)
       {var
         neuron=[18,caml_call1(Neuron[81][1],0)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function dropout(name,rate,input_node)
       {var
         neuron=[19,caml_call1(Neuron[89][1],rate)],
         nn=input_node[6],
         n=make_node(name,_px_,[0],[0],neuron,0,nn);
        return add_node(0,nn,[0,input_node],n)}
      function gaussian_noise(name,sigma,input_node)
       {var
         neuron=[24,caml_call1(Neuron[99][1],sigma)],
         nn=input_node[6],
         n=make_node(name,_py_,[0],[0],neuron,0,nn);
        return add_node(0,nn,[0,input_node],n)}
      function gaussian_dropout(name,rate,input_node)
       {var
         neuron=[25,caml_call1(Neuron[100][1],rate)],
         nn=input_node[6],
         n=make_node(name,_pz_,[0],[0],neuron,0,nn);
        return add_node(0,nn,[0,input_node],n)}
      function alpha_dropout(name,rate,input_node)
       {var
         neuron=[26,caml_call1(Neuron[101][1],rate)],
         nn=input_node[6],
         n=make_node(name,_pA_,[0],[0],neuron,0,nn);
        return add_node(0,nn,[0,input_node],n)}
      function normalisation(name,opt,training,decay,mu,var$0,input_node)
       {if(opt)var sth=opt[1],axis=sth;else var axis=-1;
        var
         neuron=[27,caml_call5(Neuron[98][1],training,decay,mu,var$0,axis)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(0,nn,[0,input_node],n)}
      function reshape(name,outputs,input_node)
       {var
         neuron=[20,caml_call2(Neuron[90][1],0,outputs)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(0,nn,[0,input_node],n)}
      function flatten(name,input_node)
       {var
         neuron=[21,caml_call1(Neuron[91][1],0)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(0,nn,[0,input_node],n)}
      function lambda(name,act_typ,lambda,input_node)
       {var
         neuron=[22,caml_call1(Neuron[88][1],lambda)],
         nn=input_node[6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,[0,input_node],n)}
      function add$0(name,act_typ,input_node)
       {var
         neuron=[28,caml_call1(Neuron[92][1],0)],
         nn=caml_check_bound(input_node,0)[1][6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,input_node,n)}
      function mul(name,act_typ,input_node)
       {var
         neuron=[29,caml_call1(Neuron[93][1],0)],
         nn=caml_check_bound(input_node,0)[1][6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,input_node,n)}
      function dot(name,act_typ,input_node)
       {var
         neuron=[30,caml_call1(Neuron[94][1],0)],
         nn=caml_check_bound(input_node,0)[1][6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,input_node,n)}
      function max(name,act_typ,input_node)
       {var
         neuron=[31,caml_call1(Neuron[95][1],0)],
         nn=caml_check_bound(input_node,0)[1][6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,input_node,n)}
      function average(name,act_typ,input_node)
       {var
         neuron=[32,caml_call1(Neuron[96][1],0)],
         nn=caml_check_bound(input_node,0)[1][6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,input_node,n)}
      function concatenate(name,act_typ,axis,input_node)
       {var
         neuron=[33,caml_call1(Neuron[97][1],axis)],
         nn=caml_check_bound(input_node,0)[1][6],
         n=make_node(name,0,[0],[0],neuron,0,nn);
        return add_node(act_typ,nn,input_node,n)}
      function to_string$45(nn)
       {var s=[0,_d_(nn[1],_pB_)],_qf_=nn[4];
        iter
         (function(n)
           {var
             _qg_=n[2],
             _qh_=map$0(function(n){return n[1]},_qg_),
             prev=string_of_array(0,0,0,function(s){return s},_qh_),
             _qi_=n[3],
             _qj_=map$0(function(n){return n[1]},_qi_),
             next=string_of_array(0,0,0,function(s){return s},_qj_),
             _qk_=caml_call2(sprintf(_pC_),prev,next),
             _ql_=caml_call1(Neuron[117],n[4]),
             _qm_=_d_(caml_call1(sprintf(_pD_),_ql_),_qk_),
             _qn_=n[1],
             _qo_=_d_(caml_call1(sprintf(_pE_),_qn_),_qm_);
            s[1] = _d_(s[1],_qo_);
            return 0},
          _qf_);
        return s[1]}
      function pp_network(formatter,nn)
       {open_box(0);
        var _qe_=to_string$45(nn);
        caml_call2(fprintf$0(formatter),_pF_,_qe_);
        return close_box(0)}
      function print(nn){return pp_network(formatter,nn)}
      function save(nn,f){return marshal_to_file(copy$35(nn),f)}
      function load(f){return marshal_from_file(f)}
      function save_weights(nn,f)
       {var h=create$0(0,nn[2]),_qd_=nn[4];
        iter
         (function(n)
           {var ws=caml_call1(Neuron[111],n[4]);return add(h,n[1],ws)},
          _qd_);
        return marshal_to_file(h,f)}
      function load_weights(nn,f)
       {var h=marshal_from_file(f),_qc_=nn[4];
        return iter
                (function(n)
                  {var ws=find(h,n[1]);return caml_call2(Neuron[114],n[4],ws)},
                 _qc_)}
      function train_generic(state,params,opt,nn,x,y)
       {if(opt)var sth=opt[1],init_model=sth;else var init_model=1;
        if(1 === init_model)init$12(nn);
        function f(_qb_){return forward(nn,_qb_)}
        function b(_qa_){return backward(nn,_qa_)}
        function u(_p$_){return update$11(nn,_p$_)}
        function s(_p__){return save(nn,_p__)}
        if(params)
         var p=params[1],p$0=p;
        else
         var p$0=caml_call1(Optimise[72][1],0);
        return caml_call8(Optimise[74],state,p$0,f,b,u,s,x,y)}
      function train(state,params,init_model,nn,x,y)
       {return train_generic(state,params,init_model,nn,[1,x],[1,y])}
      var
       Graph=
        [0,
         Neuron,
         Optimise,
         make_network,
         make_node,
         get_root,
         get_node,
         get_network,
         collect_output,
         connect_pair,
         connect_to_parents,
         add_node,
         init$12,
         reset$11,
         mktag$11,
         mkpar$11,
         mkpri$11,
         mkadj$11,
         update$11,
         run$44,
         forward,
         backward,
         copy$35,
         remove_training_nodes,
         model,
         input,
         activation,
         linear,
         linear_nobias,
         embedding,
         recurrent,
         lstm,
         gru,
         conv1d,
         conv2d,
         conv3d,
         fully_connected,
         max_pool1d,
         max_pool2d,
         avg_pool1d,
         avg_pool2d,
         global_max_pool1d,
         global_max_pool2d,
         global_avg_pool1d,
         global_avg_pool2d,
         dropout,
         gaussian_noise,
         gaussian_dropout,
         alpha_dropout,
         normalisation,
         reshape,
         flatten,
         lambda,
         add$0,
         mul,
         dot,
         max,
         average,
         concatenate,
         to_string$45,
         pp_network,
         print,
         save,
         load,
         save_weights,
         load_weights,
         train_generic,
         train];
      return [0,Graph,0,0,0,0,0,0,0,0,0,0,0,0]}
    var
     NL=
      Make$0
       ([0,
         empty,
         zeros$0,
         ones,
         create$2,
         sequential,
         uniform,
         gaussian,
         bernoulli,
         init$1,
         shape,
         numel,
         get,
         set,
         get_slice,
         set_slice,
         copy$0,
         reset,
         reshape,
         reverse,
         tile,
         repeat,
         concatenate,
         split,
         draw,
         map$2,
         fold$0,
         scan,
         print,
         abs$1,
         neg$0,
         floor$0,
         ceil$0,
         round$0,
         sqr$0,
         sqrt$0,
         log$0,
         log2$0,
         log10$0,
         exp$0,
         sin$0,
         cos$0,
         tan$0,
         sinh$0,
         cosh$0,
         tanh$0,
         asin$0,
         acos$0,
         atan$0,
         asinh$0,
         acosh$0,
         atanh$0,
         sum,
         sum_slices,
         signum$0,
         sigmoid$0,
         relu$0,
         min$0,
         max$0,
         sum$0,
         l1norm,
         l2norm,
         l2norm_sqr,
         clip_by_value,
         clip_by_l2norm,
         pow$0,
         scalar_pow,
         pow_scalar,
         atan2$0,
         scalar_atan2,
         atan2_scalar,
         add$2,
         sub$4,
         mul$1,
         div$1,
         add_scalar,
         sub_scalar,
         mul_scalar,
         div_scalar,
         scalar_add,
         scalar_sub,
         scalar_mul,
         scalar_div,
         conv1d,
         conv2d,
         conv3d,
         max_pool1d,
         max_pool2d,
         max_pool3d,
         avg_pool1d,
         avg_pool2d,
         avg_pool3d,
         conv1d_backward_input,
         conv1d_backward_kernel,
         conv2d_backward_input,
         conv2d_backward_kernel,
         conv3d_backward_input,
         conv3d_backward_kernel,
         max_pool1d_backward,
         max_pool2d_backward,
         max_pool3d_backward,
         avg_pool1d_backward,
         avg_pool2d_backward,
         avg_pool3d_backward,
         row_num,
         col_num,
         row,
         rows,
         copy_row_to,
         copy_col_to,
         dot,
         inv,
         trace,
         transpose,
         to_rows,
         of_rows,
         of_array,
         of_arrays,
         is_zero,
         is_positive,
         is_negative,
         is_nonpositive,
         is_nonnegative,
         equal,
         not_equal,
         less,
         greater,
         less_equal,
         greater_equal,
         elt_equal,
         elt_not_equal,
         elt_less,
         elt_greater,
         elt_less_equal,
         elt_greater_equal,
         elt_equal_scalar,
         elt_not_equal_scalar,
         elt_less_scalar,
         elt_greater_scalar,
         elt_less_equal_scalar,
         elt_greater_equal_scalar,
         approx_equal,
         approx_equal_scalar,
         approx_elt_equal,
         approx_elt_equal_scalar,
         [0,
          add$1,
          sub$3,
          mul$0,
          div$0,
          pow,
          atan2,
          abs$0,
          neg,
          sqr,
          sqrt,
          exp,
          log,
          log2,
          log10,
          signum,
          floor,
          ceil,
          round,
          sin,
          cos,
          tan,
          sinh,
          cosh,
          tanh,
          asin,
          acos,
          atan,
          asinh,
          acosh,
          atanh,
          relu,
          sigmoid]]),
     img_size=32;
    function infer(param)
     {var
       _p1_=caml_call2(NL[1][25],0,[0,img_size,img_size,3]),
       _p2_=caml_call7(NL[1][34],0,0,0,_pG_,[0,3,3,3,32],[0,1,1],_p1_),
       _p3_=caml_call7(NL[1][34],0,_pI_,0,_pH_,[0,3,3,32,32],[0,1,1],_p2_),
       _p4_=caml_call6(NL[1][38],0,_pJ_,0,[0,2,2],[0,2,2],_p3_),
       _p5_=caml_call7(NL[1][34],0,0,0,_pK_,[0,3,3,32,64],[0,1,1],_p4_),
       _p6_=caml_call7(NL[1][34],0,_pM_,0,_pL_,[0,3,3,64,64],[0,1,1],_p5_),
       _p7_=caml_call6(NL[1][38],0,_pN_,0,[0,2,2],[0,2,2],_p6_),
       _p8_=caml_call5(NL[1][36],0,0,_pO_,512,_p7_),
       _p9_=caml_call5(NL[1][27],0,0,_pP_,10,_p8_),
       nn=caml_call1(NL[1][7],_p9_);
      caml_call1(NL[1][12],nn);
      var
       img_ppm=uniform(0,0,[0,1,img_size,img_size,3]),
       start_time=caml_sys_time(0),
       result=caml_call2(NL[1][24],nn,img_ppm),
       end_time=caml_sys_time(0);
      caml_call1(printf(_pQ_),end_time - start_time);
      return result}
    var _pR_=infer(0);
    (function(eta){return print(0,_pS_,0,0,eta)}(_pR_));
    do_at_exit(0);
    return}
  (function(){return this}()));

//# sourceMappingURL=vgg_base.map
